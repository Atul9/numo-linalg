{"dsyconvf"=>
  ["If parameter WAY = 'C':",
   "DSYCONVF converts the factorization output format used in",
   "DSYTRF provided on entry in parameter A into the factorization",
   "output format used in DSYTRF_RK (or DSYTRF_BK) that is stored",
   "on exit in parameters A and E. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in DSYTRF into",
   "the format used in DSYTRF_RK (or DSYTRF_BK).",
   "If parameter WAY = 'R':",
   "DSYCONVF performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in DSYTRF_RK",
   "(or DSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in DSYTRF that is stored",
   "on exit in parameter A. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in DSYTRF_RK",
   "(or DSYTRF_BK) into the format used in DSYTRF."],
 "cla_hercond_c"=>
  ["   CLA_HERCOND_C computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a REAL vector."],
 "cgelqt3"=>
  ["CGELQT3 recursively computes a LQ factorization of a complex M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "dlasd4"=>
  ["This subroutine computes the square root of the I-th updated",
   "eigenvalue of a positive symmetric rank-one modification to",
   "a positive diagonal matrix whose entries are given as the squares",
   "of the corresponding entries in the array d, and that",
   "       0 <= D(i) < D(j)  for  i < j",
   "and that RHO > 0. This is arranged by the calling routine, and is",
   "no loss in generality.  The rank-one modified system is thus",
   "       diag( D ) * diag( D ) +  RHO * Z * Z_transpose.",
   "where we assume the Euclidean norm of Z is 1.",
   "The method consists of approximating the rational functions in the",
   "secular equation by simpler interpolating rational functions."],
 "cgeqr2p"=>
  ["CGEQR2P computes a QR factorization of a complex m by n matrix A:",
   "A = Q * R. The diagonal entries of R are real and nonnegative."],
 "cpptrs"=>
  ["CPPTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A in packed storage using the Cholesky",
   "factorization A = U**H*U or A = L*L**H computed by CPPTRF."],
 "dsyevd_2stage"=>
  ["DSYEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal. If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zggbak"=>
  ["ZGGBAK forms the right or left eigenvectors of a complex generalized",
   "eigenvalue problem A*x = lambda*B*x, by backward transformation on",
   "the computed eigenvectors of the balanced pair of matrices output by",
   "ZGGBAL."],
 "dlae2"=>
  ["DLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix",
   "   [  A   B  ]",
   "   [  B   C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, and RT2",
   "is the eigenvalue of smaller absolute value."],
 "zlansp"=>
  ["ZLANSP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex symmetric matrix A,  supplied in packed form.",
   "   ZLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dspgvd"=>
  ["DSPGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be symmetric, stored in packed format, and B is also",
   "positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dtzrzf"=>
  ["DTZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A",
   "to upper triangular form by means of orthogonal transformations.",
   "The upper trapezoidal matrix A is factored as",
   "   A = ( R  0 ) * Z,",
   "where Z is an N-by-N orthogonal matrix and R is an M-by-M upper",
   "triangular matrix."],
 "chptrs"=>
  ["CHPTRS solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A stored in packed format using the factorization",
   "A = U*D*U**H or A = L*D*L**H computed by CHPTRF."],
 "zggesx"=>
  ["ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the complex Schur form (S,T),",
   "and, optionally, the left and/or right matrices of Schur vectors (VSL",
   "and VSR).  This gives the generalized Schur factorization",
   "     (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T; computes",
   "a reciprocal condition number for the average of the selected",
   "eigenvalues (RCONDE); and computes a reciprocal condition number for",
   "the right and left deflating subspaces corresponding to the selected",
   "eigenvalues (RCONDV). The leading columns of VSL and VSR then form",
   "an orthonormal basis for the corresponding left and right eigenspaces",
   "(deflating subspaces).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if T is",
   "upper triangular with non-negative diagonal and S is upper",
   "triangular."],
 "sppcon"=>
  ["SPPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite packed matrix using",
   "the Cholesky factorization A = U**T*U or A = L*L**T computed by",
   "SPPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cheev_2stage"=>
  ["CHEEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "sorbdb"=>
  ["SORBDB simultaneously bidiagonalizes the blocks of an M-by-M",
   "partitioned orthogonal matrix X:",
   "                                [ B11 | B12 0  0 ]",
   "    [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T",
   "X = [-----------] = [---------] [----------------] [---------]   .",
   "    [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]",
   "                                [  0  |  0  0  I ]",
   "X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is",
   "not the case, then X must be transposed and/or permuted. This can be",
   "done in constant time using the TRANS and SIGNS options. See SORCSD",
   "for details.)",
   "The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-",
   "(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are",
   "represented implicitly by Householder vectors.",
   "B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented",
   "implicitly by angles THETA, PHI."],
 "spftrf"=>
  ["SPFTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "cgtrfs"=>
  ["CGTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is tridiagonal, and provides",
   "error bounds and backward error estimates for the solution."],
 "dpbrfs"=>
  ["DPBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and banded, and provides error bounds and backward error estimates",
   "for the solution."],
 "csycon_rook"=>
  ["CSYCON_ROOK estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dlasdq"=>
  ["DLASDQ computes the singular value decomposition (SVD) of a real",
   "(upper or lower) bidiagonal matrix with diagonal D and offdiagonal",
   "E, accumulating the transformations if desired. Letting B denote",
   "the input bidiagonal matrix, the algorithm computes orthogonal",
   "matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose",
   "of P). The singular values S are overwritten on D.",
   "The input matrix U  is changed to U  * Q  if desired.",
   "The input matrix VT is changed to P**T * VT if desired.",
   "The input matrix C  is changed to Q**T * C  if desired.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3, for a detailed description of the algorithm."],
 "slansf"=>
  ["SLANSF returns the value of the one norm, or the Frobenius norm, or",
   "the infinity norm, or the element of largest absolute value of a",
   "real symmetric matrix A in RFP format.",
   "   SLANSF = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm."],
 "slaqgb"=>
  ["SLAQGB equilibrates a general M by N band matrix A with KL",
   "subdiagonals and KU superdiagonals using the row and scaling factors",
   "in the vectors R and C."],
 "cladiv"=>
  ["CLADIV := X / Y, where X and Y are complex.  The computation of X / Y",
   "will not overflow on an intermediary step unless the results",
   "overflows."],
 "zunbdb1"=>[],
 "dlargv"=>
  ["DLARGV generates a vector of real plane rotations, determined by",
   "elements of the real vectors x and y. For i = 1,2,...,n",
   "   (  c(i)  s(i) ) ( x(i) ) = ( a(i) )",
   "   ( -s(i)  c(i) ) ( y(i) ) = (   0  )"],
 "strti2"=>
  ["STRTI2 computes the inverse of a real upper or lower triangular",
   "matrix.",
   "This is the Level 2 BLAS version of the algorithm."],
 "chbevx"=>
  ["CHBEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "ssyrfs"=>
  ["SSYRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "zsysvxx"=>
  ["   ZSYSVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a complex*16 system of linear equations A * X = B, where",
   "   A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "   matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. ZSYSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   ZSYSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   ZSYSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what ZSYSVXX would itself produce."],
 "cpocon"=>
  ["CPOCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite matrix using the",
   "Cholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dptcon"=>
  ["DPTCON computes the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite tridiagonal matrix",
   "using the factorization A = L*D*L**T or A = U**T*D*U computed by",
   "DPTTRF.",
   "Norm(inv(A)) is computed by a direct method, and the reciprocal of",
   "the condition number is computed as",
   "             RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zsytf2_rook"=>
  ["ZSYTF2_ROOK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "sormhr"=>
  ["SORMHR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "IHI-ILO elementary reflectors, as returned by SGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "zhetri_rook"=>
  ["ZHETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "ZHETRF_ROOK."],
 "cptts2"=>
  ["CPTTS2 solves a tridiagonal system of the form",
   "   A * X = B",
   "using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.",
   "D is a diagonal matrix specified in the vector D, U (or L) is a unit",
   "bidiagonal matrix whose superdiagonal (subdiagonal) is specified in",
   "the vector E, and X and B are N by NRHS matrices."],
 "zhbevd"=>
  ["ZHBEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A.  If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slantr"=>
  ["SLANTR  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "trapezoidal or triangular matrix A.",
   "   SLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "slasq3"=>
  ["SLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.",
   "In case of failure it changes shifts, and tries again until output",
   "is positive."],
 "zhetri2"=>
  ["ZHETRI2 computes the inverse of a COMPLEX*16 hermitian indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "ZHETRF. ZHETRI2 set the LEADING DIMENSION of the workspace",
   "before calling ZHETRI2X that actually computes the inverse."],
 "zgttrf"=>
  ["ZGTTRF computes an LU factorization of a complex tridiagonal matrix A",
   "using elimination with partial pivoting and row interchanges.",
   "The factorization has the form",
   "   A = L * U",
   "where L is a product of permutation and unit lower bidiagonal",
   "matrices and U is upper triangular with nonzeros in only the main",
   "diagonal and first two superdiagonals."],
 "sgetri"=>
  ["SGETRI computes the inverse of a matrix using the LU factorization",
   "computed by SGETRF.",
   "This method inverts U and then computes inv(A) by solving the system",
   "inv(A)*L = inv(U) for inv(A)."],
 "claqp2"=>
  ["CLAQP2 computes a QR factorization with column pivoting of",
   "the block A(OFFSET+1:M,1:N).",
   "The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "cpptri"=>
  ["CPPTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by CPPTRF."],
 "dgeqrfp"=>
  ["DGEQRFP computes a QR factorization of a real M-by-N matrix A:",
   "A = Q * R. The diagonal entries of R are nonnegative."],
 "zla_gbrfsx_extended"=>
  ["ZLA_GBRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by ZGBRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "dtrsyl"=>
  ["DTRSYL solves the real Sylvester matrix equation:",
   "   op(A)*X + X*op(B) = scale*C or",
   "   op(A)*X - X*op(B) = scale*C,",
   "where op(A) = A or A**T, and  A and B are both upper quasi-",
   "triangular. A is M-by-M and B is N-by-N; the right hand side C and",
   "the solution X are M-by-N; and scale is an output scale factor, set",
   "<= 1 to avoid overflow in X.",
   "A and B must be in Schur canonical form (as returned by DHSEQR), that",
   "is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;",
   "each 2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "stpqrt2"=>
  ["STPQRT2 computes a QR factorization of a real \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "cgges"=>
  ["CGGES computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the generalized complex Schur",
   "form (S, T), and optionally left and/or right Schur vectors (VSL",
   "and VSR). This gives the generalized Schur factorization",
   "        (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T. The leading",
   "columns of VSL and VSR then form an unitary basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "CGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0, and even for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if S",
   "and T are upper triangular and, in addition, the diagonal elements",
   "of T are non-negative real numbers."],
 "zpttrf"=>
  ["ZPTTRF computes the L*D*L**H factorization of a complex Hermitian",
   "positive definite tridiagonal matrix A.  The factorization may also",
   "be regarded as having the form A = U**H *D*U."],
 "sgeqrt2"=>
  ["SGEQRT2 computes a QR factorization of a real M-by-N matrix A,",
   "using the compact WY representation of Q."],
 "sgges3"=>
  ["SGGES3 computes for a pair of N-by-N real nonsymmetric matrices (A,B),",
   "the generalized eigenvalues, the generalized real Schur form (S,T),",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR). This gives the generalized Schur factorization",
   "         (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T.The",
   "leading columns of VSL and VSR then form an orthonormal basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "SGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "spotf2"=>
  ["SPOTF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U ,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "dsytri"=>
  ["DSYTRI computes the inverse of a real symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "DSYTRF."],
 "sorml2"=>
  ["SORML2 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by SGELQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dposv"=>
  ["DPOSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T* U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "sgebrd"=>
  ["SGEBRD reduces a general real M-by-N matrix A to upper or lower",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "dsytrf"=>
  ["DSYTRF computes the factorization of a real symmetric matrix A using",
   "the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "slarrr"=>
  ["Perform tests to decide whether the symmetric tridiagonal matrix T",
   "warrants expensive computations which guarantee high relative accuracy",
   "in the eigenvalues."],
 "zgebal"=>
  ["ZGEBAL balances a general complex matrix A.  This involves, first,",
   "permuting A by a similarity transformation to isolate eigenvalues",
   "in the first 1 to ILO-1 and last IHI+1 to N elements on the",
   "diagonal; and second, applying a diagonal similarity transformation",
   "to rows and columns ILO to IHI to make the rows and columns as",
   "close in norm as possible.  Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrix, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors."],
 "chpgst"=>
  ["CHPGST reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form, using packed storage.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.",
   "B must have been previously factorized as U**H*U or L*L**H by CPPTRF."],
 "dlahr2"=>
  ["DLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)",
   "matrix A so that elements below the k-th subdiagonal are zero. The",
   "reduction is performed by an orthogonal similarity transformation",
   "Q**T * A * Q. The routine returns the matrices V and T which determine",
   "Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.",
   "This is an auxiliary routine called by DGEHRD."],
 "zlasyf_aa"=>
  ["DLATRF_AA factorizes a panel of a complex symmetric matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "zlasyf_rk"=>
  ["ZLASYF_RK computes a partial factorization of a complex symmetric",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "ZLASYF_RK is an auxiliary routine called by ZSYTRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "ssytrs"=>
  ["SSYTRS solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by SSYTRF."],
 "sposvx"=>
  ["SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "cla_gercond_x"=>
  ["   CLA_GERCOND_X computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX vector."],
 "dlagts"=>
  ["DLAGTS may be used to solve one of the systems of equations",
   "   (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,",
   "where T is an n by n tridiagonal matrix, for x, following the",
   "factorization of (T - lambda*I) as",
   "   (T - lambda*I) = P*L*U ,",
   "by routine DLAGTF. The choice of equation to be solved is",
   "controlled by the argument JOB, and in each case there is an option",
   "to perturb zero or very small diagonal elements of U, this option",
   "being intended for use in applications such as inverse iteration."],
 "clahef"=>
  ["CLAHEF computes a partial factorization of a complex Hermitian",
   "matrix A using the Bunch-Kaufman diagonal pivoting method. The",
   "partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0      I     )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**H denotes the conjugate transpose of U.",
   "CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "sgeesx"=>
  ["SGEESX computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues, the real Schur form T, and, optionally, the matrix of",
   "Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "real Schur form so that selected eigenvalues are at the top left;",
   "computes a reciprocal condition number for the average of the",
   "selected eigenvalues (RCONDE); and computes a reciprocal condition",
   "number for the right invariant subspace corresponding to the",
   "selected eigenvalues (RCONDV).  The leading columns of Z form an",
   "orthonormal basis for this invariant subspace.",
   "For further explanation of the reciprocal condition numbers RCONDE",
   "and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where",
   "these quantities are called s and sep respectively).",
   "A real matrix is in real Schur form if it is upper quasi-triangular",
   "with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in",
   "the form",
   "          [  a  b  ]",
   "          [  c  a  ]",
   "where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc)."],
 "ctbcon"=>
  ["CTBCON estimates the reciprocal of the condition number of a",
   "triangular band matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dgeequb"=>
  ["DGEEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from DGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "cgghd3"=>
  ["CGGHD3 reduces a pair of complex matrices (A,B) to generalized upper",
   "Hessenberg form using unitary transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the unitary matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**H*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**H*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**H*x.",
   "The unitary matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H",
   "     Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H",
   "If Q1 is the unitary matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then CGGHD3 reduces the original",
   "problem to generalized Hessenberg form.",
   "This is a blocked variant of CGGHRD, using matrix-matrix",
   "multiplications for parts of the computation to enhance performance."],
 "dorcsd2by1"=>[],
 "ctpmqrt"=>
  ["CTPMQRT applies a complex orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" complex block reflector H to a general",
   "complex matrix C, which consists of two blocks A and B."],
 "sporfs"=>
  ["SPORFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite,",
   "and provides error bounds and backward error estimates for the",
   "solution."],
 "cuncsd"=>
  ["CUNCSD computes the CS decomposition of an M-by-M partitioned",
   "unitary matrix X:",
   "                                [  I  0  0 |  0  0  0 ]",
   "                                [  0  C  0 |  0 -S  0 ]",
   "    [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H",
   "X = [-----------] = [---------] [---------------------] [---------]   .",
   "    [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]",
   "                                [  0  S  0 |  0  C  0 ]",
   "                                [  0  0  I |  0  0  0 ]",
   "X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,",
   "(M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are",
   "R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in",
   "which R = MIN(P,M-P,Q,M-Q)."],
 "clags2"=>
  ["CLAGS2 computes 2-by-2 unitary matrices U, V and Q, such",
   "that if ( UPPER ) then",
   "          U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )",
   "                            ( 0  A3 )     ( x  x  )",
   "and",
   "          V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )",
   "                           ( 0  B3 )     ( x  x  )",
   "or if ( .NOT.UPPER ) then",
   "          U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )",
   "                            ( A2 A3 )     ( 0  x  )",
   "and",
   "          V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )",
   "                            ( B2 B3 )     ( 0  x  )",
   "where",
   "  U = (   CSU    SNU ), V = (  CSV    SNV ),",
   "      ( -SNU**H  CSU )      ( -SNV**H CSV )",
   "  Q = (   CSQ    SNQ )",
   "      ( -SNQ**H  CSQ )",
   "The rows of the transformed A and B are parallel. Moreover, if the",
   "input 2-by-2 matrix A is not zero, then the transformed (1,1) entry",
   "of A is not zero. If the input matrices A and B are both not zero,",
   "then the transformed (2,2) element of B is not zero, except when the",
   "first rows of input A and B are parallel and the second rows are",
   "zero."],
 "sgecon"=>
  ["SGECON estimates the reciprocal of the condition number of a general",
   "real matrix A, in either the 1-norm or the infinity-norm, using",
   "the LU factorization computed by SGETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dpotrs"=>
  ["DPOTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by DPOTRF."],
 "stplqt"=>
  ["DTPLQT computes a blocked LQ factorization of a real",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "zunmlq"=>
  ["ZUNMLQ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k)**H . . . H(2)**H H(1)**H",
   "as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "zptsv"=>
  ["ZPTSV computes the solution to a complex system of linear equations",
   "A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal",
   "matrix, and X and B are N-by-NRHS matrices.",
   "A is factored as A = L*D*L**H, and the factored form of A is then",
   "used to solve the system of equations."],
 "dsytri2"=>
  ["DSYTRI2 computes the inverse of a DOUBLE PRECISION symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "DSYTRF. DSYTRI2 sets the LEADING DIMENSION of the workspace",
   "before calling DSYTRI2X that actually computes the inverse."],
 "slaqge"=>
  ["SLAQGE equilibrates a general M by N matrix A using the row and",
   "column scaling factors in the vectors R and C."],
 "chptrf"=>
  ["CHPTRF computes the factorization of a complex Hermitian packed",
   "matrix A using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "slamswlq"=>
  ["   DLAMQRTS overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product of blocked",
   "   elementary reflectors computed by short wide LQ",
   "   factorization (DLASWLQ)"],
 "stfttp"=>
  ["STFTTP copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard packed format (TP)."],
 "clalsd"=>
  ["CLALSD uses the singular value decomposition of A to solve the least",
   "squares problem of finding X to minimize the Euclidean norm of each",
   "column of A*X-B, where A is N-by-N upper bidiagonal, and X and B",
   "are N-by-NRHS. The solution X overwrites B.",
   "The singular values of A smaller than RCOND times the largest",
   "singular value are treated as zero in solving the least squares",
   "problem; in this case a minimum norm solution is returned.",
   "The actual singular values are returned in D in ascending order.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slaqr5"=>
  ["   SLAQR5, called by SLAQR0, performs a",
   "   single small-bulge multi-shift QR sweep."],
 "dlasq6"=>
  ["DLASQ6 computes one dqd (shift equal to zero) transform in",
   "ping-pong form, with protection against underflow and overflow."],
 "claed0"=>
  ["Using the divide and conquer method, CLAED0 computes all eigenvalues",
   "of a symmetric tridiagonal matrix which is one diagonal block of",
   "those from reducing a dense or band Hermitian matrix and",
   "corresponding eigenvectors of the dense or band matrix."],
 "zhetrs2"=>
  ["ZHETRS2 solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHETRF and converted by ZSYCONV."],
 "zhbgv"=>
  ["ZHBGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite."],
 "sgelsd"=>
  ["SGELSD computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize 2-norm(| b - A*x |)",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The problem is solved in three steps:",
   "(1) Reduce the coefficient matrix A to bidiagonal form with",
   "    Householder transformations, reducing the original problem",
   "    into a \"bidiagonal least squares problem\" (BLS)",
   "(2) Solve the BLS using a divide and conquer approach.",
   "(3) Apply back all the Householder transformations to solve",
   "    the original least squares problem.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "sla_gbamv"=>
  ["SLA_GBAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "slasd4"=>
  ["This subroutine computes the square root of the I-th updated",
   "eigenvalue of a positive symmetric rank-one modification to",
   "a positive diagonal matrix whose entries are given as the squares",
   "of the corresponding entries in the array d, and that",
   "       0 <= D(i) < D(j)  for  i < j",
   "and that RHO > 0. This is arranged by the calling routine, and is",
   "no loss in generality.  The rank-one modified system is thus",
   "       diag( D ) * diag( D ) +  RHO * Z * Z_transpose.",
   "where we assume the Euclidean norm of Z is 1.",
   "The method consists of approximating the rational functions in the",
   "secular equation by simpler interpolating rational functions."],
 "dtptrs"=>
  ["DTPTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular matrix of order N stored in packed format,",
   "and B is an N-by-NRHS matrix.  A check is made to verify that A is",
   "nonsingular."],
 "sgglse"=>
  ["SGGLSE solves the linear equality-constrained least squares (LSE)",
   "problem:",
   "        minimize || c - A*x ||_2   subject to   B*x = d",
   "where A is an M-by-N matrix, B is a P-by-N matrix, c is a given",
   "M-vector, and d is a given P-vector. It is assumed that",
   "P <= N <= M+P, and",
   "         rank(B) = P and  rank( (A) ) = N.",
   "                              ( (B) )",
   "These conditions ensure that the LSE problem has a unique solution,",
   "which is obtained using a generalized RQ factorization of the",
   "matrices (B, A) given by",
   "   B = (0 R)*Q,   A = Z*T*Q."],
 "dla_gbrcond"=>
  ["   DLA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "slasd3"=>
  ["SLASD3 finds all the square roots of the roots of the secular",
   "equation, as defined by the values in D and Z.  It makes the",
   "appropriate calls to SLASD4 and then updates the singular",
   "vectors by matrix multiplication.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.",
   "SLASD3 is called from SLASD1."],
 "sorgbr"=>
  ["SORGBR generates one of the real orthogonal matrices Q or P**T",
   "determined by SGEBRD when reducing a real matrix A to bidiagonal",
   "form: A = Q * B * P**T.  Q and P**T are defined as products of",
   "elementary reflectors H(i) or G(i) respectively.",
   "If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q",
   "is of order M:",
   "if m >= k, Q = H(1) H(2) . . . H(k) and SORGBR returns the first n",
   "columns of Q, where m >= n >= k;",
   "if m < k, Q = H(1) H(2) . . . H(m-1) and SORGBR returns Q as an",
   "M-by-M matrix.",
   "If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T",
   "is of order N:",
   "if k < n, P**T = G(k) . . . G(2) G(1) and SORGBR returns the first m",
   "rows of P**T, where n >= m >= k;",
   "if k >= n, P**T = G(n-1) . . . G(2) G(1) and SORGBR returns P**T as",
   "an N-by-N matrix."],
 "dlaneg"=>
  ["DLANEG computes the Sturm count, the number of negative pivots",
   "encountered while factoring tridiagonal T - sigma I = L D L^T.",
   "This implementation works directly on the factors without forming",
   "the tridiagonal matrix T.  The Sturm count is also the number of",
   "eigenvalues of T less than sigma.",
   "This routine is called from DLARRB.",
   "The current routine does not use the PIVMIN parameter but rather",
   "requires IEEE-754 propagation of Infinities and NaNs.  This",
   "routine also has no input range restrictions but does require",
   "default exception handling such that x/0 produces Inf when x is",
   "non-zero, and Inf/Inf produces NaN.  For more information, see:",
   "  Marques, Riedy, and Voemel, \"Benefits of IEEE-754 Features in",
   "  Modern Symmetric Tridiagonal Eigensolvers,\" SIAM Journal on",
   "  Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624",
   "  (Tech report version in LAWN 172 with the same title.)"],
 "dlantb"=>
  ["DLANTB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n triangular band matrix A,  with ( k + 1 ) diagonals.",
   "   DLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zlasyf"=>
  ["ZLASYF computes a partial factorization of a complex symmetric matrix",
   "A using the Bunch-Kaufman diagonal pivoting method. The partial",
   "factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) ( 0   A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**T denotes the transpose of U.",
   "ZLASYF is an auxiliary routine called by ZSYTRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "dsycon"=>
  ["DSYCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by DSYTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "sgeequ"=>
  ["SGEEQU computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "zunmrq"=>
  ["ZUNMRQ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1)**H H(2)**H . . . H(k)**H",
   "as returned by ZGERQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "cspcon"=>
  ["CSPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric packed matrix A using the",
   "factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "ssytrf_rook"=>
  ["SSYTRF_ROOK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "clahef_aa"=>
  ["CLAHEF_AA factorizes a panel of a complex hermitian matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "strexc"=>
  ["STREXC reorders the real Schur factorization of a real matrix",
   "A = Q*T*Q**T, so that the diagonal block of T with row index IFST is",
   "moved to row ILST.",
   "The real Schur form T is reordered by an orthogonal similarity",
   "transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors",
   "is updated by postmultiplying it with Z.",
   "T must be in Schur canonical form (as returned by SHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "zgetri"=>
  ["ZGETRI computes the inverse of a matrix using the LU factorization",
   "computed by ZGETRF.",
   "This method inverts U and then computes inv(A) by solving the system",
   "inv(A)*L = inv(U) for inv(A)."],
 "dsysv_rook"=>
  ["DSYSV_ROOK computes the solution to a real system of linear",
   "equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "DSYTRF_ROOK is called to compute the factorization of a real",
   "symmetric matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling DSYTRS_ROOK."],
 "claset"=>
  ["CLASET initializes a 2-D array A to BETA on the diagonal and",
   "ALPHA on the offdiagonals."],
 "ieeeck"=>
  ["IEEECK is called from the ILAENV to verify that Infinity and",
   "possibly NaN arithmetic is safe (i.e. will not trap)."],
 "sgerfsx"=>
  ["   SGERFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "sgesdd"=>
  ["SGESDD computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, optionally computing the left and right singular",
   "vectors.  If singular vectors are desired, it uses a",
   "divide-and-conquer algorithm.",
   "The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   "V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns VT = V**T, not V.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zlaqr0"=>
  ["   ZLAQR0 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H."],
 "ssyev"=>
  ["SSYEV computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A."],
 "cla_gerpvgrw"=>
  ["CLA_GERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "dspevx"=>
  ["DSPEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A in packed storage.  Eigenvalues/vectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "zla_porcond_c"=>
  ["   ZLA_PORCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector"],
 "dsytri2x"=>
  ["DSYTRI2X computes the inverse of a real symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "DSYTRF."],
 "csptri"=>
  ["CSPTRI computes the inverse of a complex symmetric indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by CSPTRF."],
 "slarrc"=>
  ["Find the number of eigenvalues of the symmetric tridiagonal matrix T",
   "that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T",
   "if JOBT = 'L'."],
 "dlarrc"=>
  ["Find the number of eigenvalues of the symmetric tridiagonal matrix T",
   "that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T",
   "if JOBT = 'L'."],
 "dggev3"=>
  ["DGGEV3 computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j).",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B .",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "zpptrf"=>
  ["ZPPTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A stored in packed format.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "dla_syamv"=>
  ["DLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "clacpy"=>
  ["CLACPY copies all or part of a two-dimensional matrix A to another",
   "matrix B."],
 "chegv_2stage"=>
  ["CHEGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian and B is also",
   "positive definite.",
   "This routine use the 2stage technique for the reduction to tridiagonal",
   "which showed higher performance on recent architecture and for large"],
 "dlaed8"=>
  ["DLAED8 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny element in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "slarra"=>
  ["Compute the splitting points with threshold SPLTOL.",
   "SLARRA sets any \"small\" off-diagonal elements to zero."],
 "dtprfb"=>
  ["DTPRFB applies a real \"triangular-pentagonal\" block reflector H or its",
   "transpose H**T to a real matrix C, which is composed of two",
   "blocks A and B, either from the left or right."],
 "zgbcon"=>
  ["ZGBCON estimates the reciprocal of the condition number of a complex",
   "general band matrix A, in either the 1-norm or the infinity-norm,",
   "using the LU factorization computed by ZGBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dlaed2"=>
  ["DLAED2 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny entry in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "ssbevx"=>
  ["SSBEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric band matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "dla_syrfsx_extended"=>
  ["DLA_SYRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by DSYRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "ztrtrs"=>
  ["ZTRTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular matrix of order N, and B is an N-by-NRHS",
   "matrix.  A check is made to verify that A is nonsingular."],
 "dgerq2"=>
  ["DGERQ2 computes an RQ factorization of a real m by n matrix A:",
   "A = R * Q."],
 "dgges3"=>
  ["DGGES3 computes for a pair of N-by-N real nonsymmetric matrices (A,B),",
   "the generalized eigenvalues, the generalized real Schur form (S,T),",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR). This gives the generalized Schur factorization",
   "         (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T.The",
   "leading columns of VSL and VSR then form an orthonormal basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "DGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "dpptri"=>
  ["DPPTRI computes the inverse of a real symmetric positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by DPPTRF."],
 "chesvxx"=>
  ["   CHESVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a complex system of linear equations A * X = B, where",
   "   A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "   matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. CHESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   CHESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   CHESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what CHESVXX would itself produce."],
 "slasyf_rk"=>
  ["SLASYF_RK computes a partial factorization of a real symmetric",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "SLASYF_RK is an auxiliary routine called by SSYTRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "csytrs"=>
  ["CSYTRS solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by CSYTRF."],
 "cunmrz"=>
  ["CUNMRZ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by CTZRZF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "zpbstf"=>
  ["ZPBSTF computes a split Cholesky factorization of a complex",
   "Hermitian positive definite band matrix A.",
   "This routine is designed to be used in conjunction with ZHBGST.",
   "The factorization has the form  A = S**H*S  where S is a band matrix",
   "of the same bandwidth as A and the following structure:",
   "  S = ( U    )",
   "      ( M  L )",
   "where U is upper triangular of order m = (n+kd)/2, and L is lower",
   "triangular of order n-m."],
 "clansy"=>
  ["CLANSY  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex symmetric matrix A.",
   "   CLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zspsvx"=>
  ["ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or",
   "A = L*D*L**T to compute the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "ssyevx"=>
  ["SSYEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "claed8"=>
  ["CLAED8 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny element in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "cggqrf"=>
  ["CGGQRF computes a generalized QR factorization of an N-by-M matrix A",
   "and an N-by-P matrix B:",
   "            A = Q*R,        B = Q*T*Z,",
   "where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,",
   "and R and T assume one of the forms:",
   "if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,",
   "                (  0  ) N-M                         N   M-N",
   "                   M",
   "where R11 is upper triangular, and",
   "if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,",
   "                 P-N  N                           ( T21 ) P",
   "                                                     P",
   "where T12 or T21 is upper triangular.",
   "In particular, if B is square and nonsingular, the GQR factorization",
   "of A and B implicitly gives the QR factorization of inv(B)*A:",
   "             inv(B)*A = Z**H * (inv(T)*R)",
   "where inv(B) denotes the inverse of the matrix B, and Z' denotes the",
   "conjugate transpose of matrix Z."],
 "ssytrd_2stage"=>
  ["SSYTRD_2STAGE reduces a real symmetric matrix A to real symmetric",
   "tridiagonal form T by a orthogonal similarity transformation:",
   "Q1**T Q2**T* A * Q2 * Q1 = T."],
 "cgeevx"=>
  ["CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues",
   "(RCONDE), and reciprocal condition numbers for the right",
   "eigenvectors (RCONDV).",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real.",
   "Balancing a matrix means permuting the rows and columns to make it",
   "more nearly upper triangular, and applying a diagonal similarity",
   "transformation D * A * D**(-1), where D is a diagonal matrix, to",
   "make its rows and columns closer in norm and the condition numbers",
   "of its eigenvalues and eigenvectors smaller.  The computed",
   "reciprocal condition numbers correspond to the balanced matrix.",
   "Permuting rows and columns will not change the condition numbers",
   "(in exact arithmetic) but diagonal scaling will.  For further",
   "explanation of balancing, see section 4.10.2 of the LAPACK",
   "Users' Guide."],
 "zgemlqt"=>
  ["ZGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'C':   Q**C C            C Q**C",
   "where Q is a complex orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V C V**C",
   "generated using the compact WY representation as returned by ZGELQT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "dstegr"=>
  ["DSTEGR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "DSTEGR is a compatibility wrapper around the improved DSTEMR routine.",
   "See DSTEMR for further details.",
   "One important change is that the ABSTOL parameter no longer provides any",
   "benefit and hence is no longer used.",
   "Note : DSTEGR and DSTEMR work only on machines which follow",
   "IEEE-754 floating-point standard in their handling of infinities and",
   "NaNs.  Normal execution may create these exceptiona values and hence",
   "may abort due to a floating point exception in environments which",
   "do not conform to the IEEE-754 standard."],
 "ctrsen"=>
  ["CTRSEN reorders the Schur factorization of a complex matrix",
   "A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in",
   "the leading positions on the diagonal of the upper triangular matrix",
   "T, and the leading columns of Q form an orthonormal basis of the",
   "corresponding right invariant subspace.",
   "Optionally the routine computes the reciprocal condition numbers of",
   "the cluster of eigenvalues and/or the invariant subspace."],
 "dspsv"=>
  ["DSPSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is symmetric and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "dbbcsd"=>
  ["DBBCSD computes the CS decomposition of an orthogonal matrix in",
   "bidiagonal-block form,",
   "    [ B11 | B12 0  0 ]",
   "    [  0  |  0 -I  0 ]",
   "X = [----------------]",
   "    [ B21 | B22 0  0 ]",
   "    [  0  |  0  0  I ]",
   "                              [  C | -S  0  0 ]",
   "                  [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T",
   "                = [---------] [---------------] [---------]   .",
   "                  [    | U2 ] [  S |  C  0  0 ] [    | V2 ]",
   "                              [  0 |  0  0  I ]",
   "X is M-by-M, its top-left block is P-by-Q, and Q must be no larger",
   "than P, M-P, or M-Q. (If Q is not the smallest index, then X must be",
   "transposed and/or permuted. This can be done in constant time using",
   "the TRANS and SIGNS options. See DORCSD for details.)",
   "The bidiagonal matrices B11, B12, B21, and B22 are represented",
   "implicitly by angles THETA(1:Q) and PHI(1:Q-1).",
   "The orthogonal matrices U1, U2, V1T, and V2T are input/output.",
   "The input matrices are pre- or post-multiplied by the appropriate",
   "singular vector matrices."],
 "zla_gerpvgrw"=>
  ["ZLA_GERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "clantb"=>
  ["CLANTB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n triangular band matrix A,  with ( k + 1 ) diagonals.",
   "   CLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cgglse"=>
  ["CGGLSE solves the linear equality-constrained least squares (LSE)",
   "problem:",
   "        minimize || c - A*x ||_2   subject to   B*x = d",
   "where A is an M-by-N matrix, B is a P-by-N matrix, c is a given",
   "M-vector, and d is a given P-vector. It is assumed that",
   "P <= N <= M+P, and",
   "         rank(B) = P and  rank( (A) ) = N.",
   "                              ( (B) )",
   "These conditions ensure that the LSE problem has a unique solution,",
   "which is obtained using a generalized RQ factorization of the",
   "matrices (B, A) given by",
   "   B = (0 R)*Q,   A = Z*T*Q."],
 "zlacrm"=>
  ["ZLACRM performs a very simple matrix-matrix multiplication:",
   "         C := A * B,",
   "where A is M by N and complex; B is N by N and real;",
   "C is M by N and complex."],
 "slaqsy"=>
  ["SLAQSY equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "dtplqt"=>
  ["DTPLQT computes a blocked LQ factorization of a real",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "spttrf"=>
  ["SPTTRF computes the L*D*L**T factorization of a real symmetric",
   "positive definite tridiagonal matrix A.  The factorization may also",
   "be regarded as having the form A = U**T*D*U."],
 "slalsa"=>
  ["SLALSA is an itermediate step in solving the least squares problem",
   "by computing the SVD of the coefficient matrix in compact form (The",
   "singular vectors are computed as products of simple orthorgonal",
   "matrices.).",
   "If ICOMPQ = 0, SLALSA applies the inverse of the left singular vector",
   "matrix of an upper bidiagonal matrix to the right hand side; and if",
   "ICOMPQ = 1, SLALSA applies the right singular vector matrix to the",
   "right hand side. The singular vector matrices were generated in",
   "compact form by SLALSA."],
 "dgelqf"=>
  ["DGELQF computes an LQ factorization of a real M-by-N matrix A:",
   "A = L * Q."],
 "csysv_rook"=>
  ["CSYSV_ROOK computes the solution to a complex system of linear",
   "equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "CSYTRF_ROOK is called to compute the factorization of a complex",
   "symmetric matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling CSYTRS_ROOK."],
 "zsytri2"=>
  ["ZSYTRI2 computes the inverse of a COMPLEX*16 symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "ZSYTRF. ZSYTRI2 sets the LEADING DIMENSION of the workspace",
   "before calling ZSYTRI2X that actually computes the inverse."],
 "dhseqr"=>
  ["   DHSEQR computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "slaswp"=>
  ["SLASWP performs a series of row interchanges on the matrix A.",
   "One row interchange is initiated for each of rows K1 through K2 of A."],
 "sla_porpvgrw"=>
  ["SLA_PORPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "ssyevr"=>
  ["SSYEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "SSYEVR first reduces the matrix A to tridiagonal form T with a call",
   "to SSYTRD.  Then, whenever possible, SSYEVR calls SSTEMR to compute",
   "the eigenspectrum using Relatively Robust Representations.  SSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see SSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of SSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "sptsv"=>
  ["SPTSV computes the solution to a real system of linear equations",
   "A*X = B, where A is an N-by-N symmetric positive definite tridiagonal",
   "matrix, and X and B are N-by-NRHS matrices.",
   "A is factored as A = L*D*L**T, and the factored form of A is then",
   "used to solve the system of equations."],
 "cgeesx"=>
  ["CGEESX computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues, the Schur form T, and, optionally, the matrix of Schur",
   "vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "Schur form so that selected eigenvalues are at the top left;",
   "computes a reciprocal condition number for the average of the",
   "selected eigenvalues (RCONDE); and computes a reciprocal condition",
   "number for the right invariant subspace corresponding to the",
   "selected eigenvalues (RCONDV).  The leading columns of Z form an",
   "orthonormal basis for this invariant subspace.",
   "For further explanation of the reciprocal condition numbers RCONDE",
   "and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where",
   "these quantities are called s and sep respectively).",
   "A complex matrix is in Schur form if it is upper triangular."],
 "clargv"=>
  ["CLARGV generates a vector of complex plane rotations with real",
   "cosines, determined by elements of the complex vectors x and y.",
   "For i = 1,2,...,n",
   "   (        c(i)   s(i) ) ( x(i) ) = ( r(i) )",
   "   ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )",
   "   where c(i)**2 + ABS(s(i))**2 = 1",
   "The following conventions are used (these are the same as in CLARTG,",
   "but differ from the BLAS1 routine CROTG):",
   "   If y(i)=0, then c(i)=1 and s(i)=0.",
   "   If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real."],
 "zlaqhe"=>
  ["ZLAQHE equilibrates a Hermitian matrix A using the scaling factors",
   "in the vector S."],
 "dgehd2"=>
  ["DGEHD2 reduces a real general matrix A to upper Hessenberg form H by",
   "an orthogonal similarity transformation:  Q**T * A * Q = H ."],
 "cla_gercond_c"=>
  ["   CLA_GERCOND_C computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a REAL vector."],
 "zlarfx"=>
  ["ZLARFX applies a complex elementary reflector H to a complex m by n",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix",
   "This version uses inline code if H has order < 11."],
 "csyequb"=>
  ["CSYEQUB computes row and column scalings intended to equilibrate a",
   "symmetric matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "clapll"=>
  ["Given two column vectors X and Y, let",
   "                     A = ( X Y ).",
   "The subroutine first computes the QR factorization of A = Q*R,",
   "and then computes the SVD of the 2-by-2 upper triangular matrix R.",
   "The smaller singular value of R is returned in SSMIN, which is used",
   "as the measurement of the linear dependency of the vectors X and Y."],
 "cgetri"=>
  ["CGETRI computes the inverse of a matrix using the LU factorization",
   "computed by CGETRF.",
   "This method inverts U and then computes inv(A) by solving the system",
   "inv(A)*L = inv(U) for inv(A)."],
 "sla_porfsx_extended"=>
  ["SLA_PORFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by SPORFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "chetrd_2stage"=>
  ["CHETRD_2STAGE reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q1**H Q2**H* A * Q2 * Q1 = T."],
 "dlaed7"=>
  ["DLAED7 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix. This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and optionally eigenvectors of a dense symmetric matrix",
   "that has been reduced to tridiagonal form.  DLAED1 handles",
   "the case in which all eigenvalues and eigenvectors of a symmetric",
   "tridiagonal matrix are desired.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)",
   "   where Z = Q**Tu, u is a vector of length N with ones in the",
   "   CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine DLAED8.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine DLAED4 (as called by DLAED9).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "zsytf2"=>
  ["ZSYTF2 computes the factorization of a complex symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "sgesvxx"=>
  ["   SGESVXX uses the LU factorization to compute the solution to a",
   "   real system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. SGESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   SGESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   SGESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what SGESVXX would itself produce."],
 "cppsvx"=>
  ["CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "stpqrt"=>
  ["STPQRT computes a blocked QR factorization of a real",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "stprfb"=>
  ["STPRFB applies a real \"triangular-pentagonal\" block reflector H or its",
   "conjugate transpose H^H to a real matrix C, which is composed of two",
   "blocks A and B, either from the left or right."],
 "ssytrd_sy2sb"=>
  ["SSYTRD_SY2SB reduces a real symmetric matrix A to real symmetric",
   "band-diagonal form AB by a orthogonal similarity transformation:",
   "Q**T * A * Q = AB."],
 "zhpsv"=>
  ["ZHPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**H,  if UPLO = 'U', or",
   "   A = L * D * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is Hermitian and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "zhegvd"=>
  ["ZHEGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian and B is also positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zla_syrpvgrw"=>
  ["ZLA_SYRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "sspcon"=>
  ["SSPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric packed matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by SSPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zlartv"=>
  ["ZLARTV applies a vector of complex plane rotations with real cosines",
   "to elements of the complex vectors x and y. For i = 1,2,...,n",
   "   ( x(i) ) := (        c(i)   s(i) ) ( x(i) )",
   "   ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )"],
 "dlaqge"=>
  ["DLAQGE equilibrates a general M by N matrix A using the row and",
   "column scaling factors in the vectors R and C."],
 "cgelq2"=>
  ["CGELQ2 computes an LQ factorization of a complex m by n matrix A:",
   "A = L * Q."],
 "ssytrf_aa"=>
  ["SSYTRF_AA computes the factorization of a real symmetric matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**T  or  A = L*T*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a symmetric tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "csymv"=>
  ["CSYMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix."],
 "dormlq"=>
  ["DORMLQ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "dgbbrd"=>
  ["DGBBRD reduces a real general m-by-n band matrix A to upper",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "The routine computes B, and optionally forms Q or P**T, or computes",
   "Q**T*C for a given matrix C."],
 "clansp"=>
  ["CLANSP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex symmetric matrix A,  supplied in packed form.",
   "   CLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zlabrd"=>
  ["ZLABRD reduces the first NB rows and columns of a complex general",
   "m by n matrix A to upper or lower real bidiagonal form by a unitary",
   "transformation Q**H * A * P, and returns the matrices X and Y which",
   "are needed to apply the transformation to the unreduced part of A.",
   "If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower",
   "bidiagonal form.",
   "This is an auxiliary routine called by ZGEBRD"],
 "zhetrd_2stage"=>
  ["ZHETRD_2STAGE reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q1**H Q2**H* A * Q2 * Q1 = T."],
 "zstedc"=>
  ["ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method.",
   "The eigenvectors of a full or band complex Hermitian matrix can also",
   "be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this",
   "matrix to tridiagonal form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See DLAED3 for details."],
 "cgbtrs"=>
  ["CGBTRS solves a system of linear equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B",
   "with a general band matrix A using the LU factorization computed",
   "by CGBTRF."],
 "zrot"=>
  ["ZROT   applies a plane rotation, where the cos (C) is real and the",
   "sin (S) is complex, and the vectors CX and CY are complex."],
 "dspgv"=>
  ["DSPGV computes all the eigenvalues and, optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric, stored in packed format,",
   "and B is also positive definite."],
 "ssytri_3x"=>
  ["SSYTRI_3X computes the inverse of a real symmetric indefinite",
   "matrix A using the factorization computed by SSYTRF_RK or SSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "ztgsy2"=>
  ["ZTGSY2 solves the generalized Sylvester equation",
   "            A * R - L * B = scale * C               (1)",
   "            D * R - L * E = scale * F",
   "using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,",
   "(A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,",
   "N-by-N and M-by-N, respectively. A, B, D and E are upper triangular",
   "(i.e., (A,D) and (B,E) in generalized Schur form).",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output",
   "scaling factor chosen to avoid overflow.",
   "In matrix notation solving equation (1) corresponds to solve",
   "Zx = scale * b, where Z is defined as",
   "       Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)",
   "           [ kron(In, D)  -kron(E**H, Im) ],",
   "Ik is the identity matrix of size k and X**H is the conjuguate transpose of X.",
   "kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b",
   "is solved for, which is equivalent to solve for R and L in",
   "            A**H * R  + D**H * L   = scale * C           (3)",
   "            R  * B**H + L  * E**H  = scale * -F",
   "This case is used to compute an estimate of Dif[(A, D), (B, E)] =",
   "= sigma_min(Z) using reverse communicaton with ZLACON.",
   "ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL",
   "of an upper bound on the separation between to matrix pairs. Then",
   "the input (A, D), (B, E) are sub-pencils of two matrix pairs in",
   "ZTGSYL."],
 "zlaqr4"=>
  ["   ZLAQR4 implements one level of recursion for ZLAQR0.",
   "   It is a complete implementation of the small bulge multi-shift",
   "   QR algorithm.  It may be called by ZLAQR0 and, for large enough",
   "   deflation window size, it may be called by ZLAQR3.  This",
   "   subroutine is identical to ZLAQR0 except that it calls ZLAQR2",
   "   instead of ZLAQR3.",
   "   ZLAQR4 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H."],
 "classq"=>
  ["CLASSQ returns the values scl and ssq such that",
   "   ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,",
   "where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is",
   "assumed to be at least unity and the value of ssq will then satisfy",
   "   1.0 .le. ssq .le. ( sumsq + 2*n ).",
   "scale is assumed to be non-negative and scl returns the value",
   "   scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),",
   "          i",
   "scale and sumsq must be supplied in SCALE and SUMSQ respectively.",
   "SCALE and SUMSQ are overwritten by scl and ssq respectively.",
   "The routine makes only one pass through the vector X."],
 "ssptrs"=>
  ["SSPTRS solves a system of linear equations A*X = B with a real",
   "symmetric matrix A stored in packed format using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by SSPTRF."],
 "sgerq2"=>
  ["SGERQ2 computes an RQ factorization of a real m by n matrix A:",
   "A = R * Q."],
 "dgelqt"=>
  ["DGELQT computes a blocked LQ factorization of a real M-by-N matrix A",
   "using the compact WY representation of Q."],
 "chegvx"=>
  ["CHEGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian and B is also positive definite.",
   "Eigenvalues and eigenvectors can be selected by specifying either a",
   "range of values or a range of indices for the desired eigenvalues."],
 "sla_syrpvgrw"=>
  ["SLA_SYRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "cunbdb6"=>[],
 "ssyevr_2stage"=>
  ["SSYEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "SSYEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call",
   "to SSYTRD.  Then, whenever possible, SSYEVR_2STAGE calls SSTEMR to compute",
   "the eigenspectrum using Relatively Robust Representations.  SSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see SSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : SSYEVR_2STAGE calls SSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "SSYEVR_2STAGE calls SSTEBZ and SSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of SSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "ctbtrs"=>
  ["CTBTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular band matrix of order N, and B is an",
   "N-by-NRHS matrix.  A check is made to verify that A is nonsingular."],
 "zgbrfsx"=>
  ["   ZGBRFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dlagv2"=>
  ["DLAGV2 computes the Generalized Schur factorization of a real 2-by-2",
   "matrix pencil (A,B) where B is upper triangular. This routine",
   "computes orthogonal (rotation) matrices given by CSL, SNL and CSR,",
   "SNR such that",
   "1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0",
   "   types), then",
   "   [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]",
   "   [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]",
   "   [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]",
   "   [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],",
   "2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,",
   "   then",
   "   [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]",
   "   [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]",
   "   [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]",
   "   [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]",
   "   where b11 >= b22 > 0."],
 "csptrf"=>
  ["CSPTRF computes the factorization of a complex symmetric matrix A",
   "stored in packed format using the Bunch-Kaufman diagonal pivoting",
   "method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "dgetrf2"=>
  ["DGETRF2 computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = min(m,n)/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "                                      [ A11 ]",
   "The subroutine calls itself to factor [ --- ],",
   "                                      [ A12 ]",
   "                [ A12 ]",
   "do the swaps on [ --- ], solve A12, update A22,",
   "                [ A22 ]",
   "then calls itself to factor A22 and do the swaps on A21."],
 "sptcon"=>
  ["SPTCON computes the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite tridiagonal matrix",
   "using the factorization A = L*D*L**T or A = U**T*D*U computed by",
   "SPTTRF.",
   "Norm(inv(A)) is computed by a direct method, and the reciprocal of",
   "the condition number is computed as",
   "             RCOND = 1 / (ANORM * norm(inv(A)))."],
 "sgbsvx"=>
  ["SGBSVX uses the LU factorization to compute the solution to a real",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a band matrix of order N with KL subdiagonals and KU",
   "superdiagonals, and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dsygv_2stage"=>
  ["DSYGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric and B is also",
   "positive definite.",
   "This routine use the 2stage technique for the reduction to tridiagonal",
   "which showed higher performance on recent architecture and for large"],
 "ssptrd"=>
  ["SSPTRD reduces a real symmetric matrix A stored in packed form to",
   "symmetric tridiagonal form T by an orthogonal similarity",
   "transformation: Q**T * A * Q = T."],
 "dorm2r"=>
  ["DORM2R overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dsyconv"=>
  ["DSYCONV convert A given by TRF into L and D and vice-versa.",
   "Get Non-diag elements of D (returned in workspace) and",
   "apply or reverse permutation done in TRF."],
 "zhetri_3"=>
  ["ZHETRI_3 computes the inverse of a complex Hermitian indefinite",
   "matrix A using the factorization computed by ZHETRF_RK or ZHETRF_BK:",
   "    A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "ZHETRI_3 sets the leading dimension of the workspace  before calling",
   "ZHETRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "ztrsen"=>
  ["ZTRSEN reorders the Schur factorization of a complex matrix",
   "A = Q*T*Q**H, so that a selected cluster of eigenvalues appears in",
   "the leading positions on the diagonal of the upper triangular matrix",
   "T, and the leading columns of Q form an orthonormal basis of the",
   "corresponding right invariant subspace.",
   "Optionally the routine computes the reciprocal condition numbers of",
   "the cluster of eigenvalues and/or the invariant subspace."],
 "zgels"=>
  ["ZGELS solves overdetermined or underdetermined complex linear systems",
   "involving an M-by-N matrix A, or its conjugate-transpose, using a QR",
   "or LQ factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'C' and m >= n:  find the minimum norm solution of",
   "   an underdetermined system A**H * X = B.",
   "4. If TRANS = 'C' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**H * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "slarrj"=>
  ["Given the initial eigenvalue approximations of T, SLARRJ",
   "does  bisection to refine the eigenvalues of T,",
   "W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial",
   "guesses for these eigenvalues are input in W, the corresponding estimate",
   "of the error in these guesses in WERR. During bisection, intervals",
   "[left, right] are maintained by storing their mid-points and",
   "semi-widths in the arrays W and WERR respectively."],
 "cgghrd"=>
  ["CGGHRD reduces a pair of complex matrices (A,B) to generalized upper",
   "Hessenberg form using unitary transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the generalized",
   "eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the unitary matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**H*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**H*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**H*x.",
   "The unitary matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H",
   "     Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H",
   "If Q1 is the unitary matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then CGGHRD reduces the original",
   "problem to generalized Hessenberg form."],
 "ztplqt"=>
  ["DTPLQT computes a blocked LQ factorization of a complex",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "ssytrf_rk"=>
  ["SSYTRF_RK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "ssytf2"=>
  ["SSYTF2 computes the factorization of a real symmetric matrix A using",
   "the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "ctrevc3"=>
  ["CTREVC3 computes some or all of the right and/or left eigenvectors of",
   "a complex upper triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "             T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of the vector y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix. If Q is the unitary factor that reduces a matrix A to",
   "Schur form T, then Q*X and Q*Y are the matrices of right and left",
   "eigenvectors of A.",
   "This uses a Level 3 BLAS version of the back transformation."],
 "zgghrd"=>
  ["ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper",
   "Hessenberg form using unitary transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the unitary matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**H*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**H*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**H*x.",
   "The unitary matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H",
   "     Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H",
   "If Q1 is the unitary matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then ZGGHRD reduces the original",
   "problem to generalized Hessenberg form."],
 "zporfsx"=>
  ["   ZPORFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric positive",
   "   definite, and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dsgesv"=>
  ["DSGESV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "DSGESV first attempts to factorize the matrix in SINGLE PRECISION",
   "and use this factorization within an iterative refinement procedure",
   "to produce a solution with DOUBLE PRECISION normwise backward error",
   "quality (see below). If the approach fails the method switches to a",
   "DOUBLE PRECISION factorization and solve.",
   "The iterative refinement is not going to be a winning strategy if",
   "the ratio SINGLE PRECISION performance over DOUBLE PRECISION",
   "performance is too small. A reasonable strategy should take the",
   "number of right-hand sides and the size of the matrix into account.",
   "This might be done with a call to ILAENV in the future. Up to now, we",
   "always try iterative refinement.",
   "The iterative refinement process is stopped if",
   "    ITER > ITERMAX",
   "or for all the RHS we have:",
   "    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX",
   "where",
   "    o ITER is the number of the current iteration in the iterative",
   "      refinement process",
   "    o RNRM is the infinity-norm of the residual",
   "    o XNRM is the infinity-norm of the solution",
   "    o ANRM is the infinity-operator-norm of the matrix A",
   "    o EPS is the machine epsilon returned by DLAMCH('Epsilon')",
   "The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00",
   "respectively."],
 "dstein"=>
  ["DSTEIN computes the eigenvectors of a real symmetric tridiagonal",
   "matrix T corresponding to specified eigenvalues, using inverse",
   "iteration.",
   "The maximum number of iterations allowed for each eigenvector is",
   "specified by an internal parameter MAXITS (currently set to 5)."],
 "chbgst"=>
  ["CHBGST reduces a complex Hermitian-definite banded generalized",
   "eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,",
   "such that C has the same bandwidth as A.",
   "B must have been previously factorized as S**H*S by CPBSTF, using a",
   "split Cholesky factorization. A is overwritten by C = X**H*A*X, where",
   "X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the",
   "bandwidth of A."],
 "zlacp2"=>
  ["ZLACP2 copies all or part of a real two-dimensional matrix A to a",
   "complex matrix B."],
 "zheev"=>
  ["ZHEEV computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A."],
 "slabrd"=>
  ["SLABRD reduces the first NB rows and columns of a real general",
   "m by n matrix A to upper or lower bidiagonal form by an orthogonal",
   "transformation Q**T * A * P, and returns the matrices X and Y which",
   "are needed to apply the transformation to the unreduced part of A.",
   "If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower",
   "bidiagonal form.",
   "This is an auxiliary routine called by SGEBRD"],
 "ssbevd_2stage"=>
  ["SSBEVD_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal. If eigenvectors are desired, it uses",
   "a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cla_gbrpvgrw"=>
  ["CLA_GBRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "zsytrf_rk"=>
  ["ZSYTRF_RK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "zlanhs"=>
  ["ZLANHS  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "Hessenberg matrix A.",
   "   ZLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cgesdd"=>
  ["CGESDD computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors, by using divide-and-conquer method. The SVD is written",
   "     A = U * SIGMA * conjugate-transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   "V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns VT = V**H, not V.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "ctplqt"=>
  ["CTPLQT computes a blocked LQ factorization of a complex",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "cunglq"=>
  ["CUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,",
   "which is defined as the first M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(k)**H . . . H(2)**H H(1)**H",
   "as returned by CGELQF."],
 "zgemlq"=>
  ["    ZGEMLQ overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "     TRANS = 'N':      Q * C          C * Q",
   "     TRANS = 'C':      Q**H * C       C * Q**H",
   "     where Q is a complex unitary matrix defined as the product",
   "     of blocked elementary reflectors computed by short wide",
   "     LQ factorization (ZGELQ)"],
 "zsyrfs"=>
  ["ZSYRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "slantp"=>
  ["SLANTP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "triangular matrix A, supplied in packed form.",
   "   SLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dgges"=>
  ["DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),",
   "the generalized eigenvalues, the generalized real Schur form (S,T),",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR). This gives the generalized Schur factorization",
   "         (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T.The",
   "leading columns of VSL and VSR then form an orthonormal basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "DGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "zhpsvx"=>
  ["ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or",
   "A = L*D*L**H to compute the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N Hermitian matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "cgebak"=>
  ["CGEBAK forms the right or left eigenvectors of a complex general",
   "matrix by backward transformation on the computed eigenvectors of the",
   "balanced matrix output by CGEBAL."],
 "chbev"=>
  ["CHBEV computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A."],
 "zgerqf"=>
  ["ZGERQF computes an RQ factorization of a complex M-by-N matrix A:",
   "A = R * Q."],
 "chprfs"=>
  ["CHPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "ssyconvf_rook"=>
  ["If parameter WAY = 'C':",
   "SSYCONVF_ROOK converts the factorization output format used in",
   "SSYTRF_ROOK provided on entry in parameter A into the factorization",
   "output format used in SSYTRF_RK (or SSYTRF_BK) that is stored",
   "on exit in parameters A and E. IPIV format for SSYTRF_ROOK and",
   "SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.",
   "If parameter WAY = 'R':",
   "SSYCONVF_ROOK performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in SSYTRF_RK",
   "(or SSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in SSYTRF_ROOK that is stored",
   "on exit in parameter A. IPIV format for SSYTRF_ROOK and",
   "SSYTRF_RK (or SSYTRF_BK) is the same and is not converted."],
 "sppequ"=>
  ["SPPEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A in packed storage and reduce",
   "its condition number (with respect to the two-norm).  S contains the",
   "scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix",
   "B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.",
   "This choice of S puts the condition number of B within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "sorgl2"=>
  ["SORGL2 generates an m by n real matrix Q with orthonormal rows,",
   "which is defined as the first m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by SGELQF."],
 "ctpttr"=>
  ["CTPTTR copies a triangular matrix A from standard packed format (TP)",
   "to standard full format (TR)."],
 "chesvx"=>
  ["CHESVX uses the diagonal pivoting factorization to compute the",
   "solution to a complex system of linear equations A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "sgbcon"=>
  ["SGBCON estimates the reciprocal of the condition number of a real",
   "general band matrix A, in either the 1-norm or the infinity-norm,",
   "using the LU factorization computed by SGBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cla_herpvgrw"=>
  ["CLA_HERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "cpprfs"=>
  ["CPPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "dtgexc"=>
  ["DTGEXC reorders the generalized real Schur decomposition of a real",
   "matrix pair (A,B) using an orthogonal equivalence transformation",
   "               (A, B) = Q * (A, B) * Z**T,",
   "so that the diagonal block of (A, B) with row index IFST is moved",
   "to row ILST.",
   "(A, B) must be in generalized real Schur canonical form (as returned",
   "by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2",
   "diagonal blocks. B is upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T",
   "       Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T"],
 "ssytd2"=>
  ["SSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal",
   "form T by an orthogonal similarity transformation: Q**T * A * Q = T."],
 "dlaqr0"=>
  ["   DLAQR0 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "zsteqr"=>
  ["ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the implicit QL or QR method.",
   "The eigenvectors of a full or band complex Hermitian matrix can also",
   "be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this",
   "matrix to tridiagonal form."],
 "csyswapr"=>
  ["CSYSWAPR applies an elementary permutation on the rows and the columns of",
   "a symmetric matrix."],
 "sla_lin_berr"=>
  ["   SLA_LIN_BERR computes componentwise relative backward error from",
   "   the formula",
   "       max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )",
   "   where abs(Z) is the componentwise absolute value of the matrix",
   "   or vector Z."],
 "csytri_rook"=>
  ["CSYTRI_ROOK computes the inverse of a complex symmetric",
   "matrix A using the factorization A = U*D*U**T or A = L*D*L**T",
   "computed by CSYTRF_ROOK."],
 "zungbr"=>
  ["ZUNGBR generates one of the complex unitary matrices Q or P**H",
   "determined by ZGEBRD when reducing a complex matrix A to bidiagonal",
   "form: A = Q * B * P**H.  Q and P**H are defined as products of",
   "elementary reflectors H(i) or G(i) respectively.",
   "If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q",
   "is of order M:",
   "if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n",
   "columns of Q, where m >= n >= k;",
   "if m < k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an",
   "M-by-M matrix.",
   "If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H",
   "is of order N:",
   "if k < n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m",
   "rows of P**H, where n >= m >= k;",
   "if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as",
   "an N-by-N matrix."],
 "csysvxx"=>
  ["   CSYSVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a complex system of linear equations A * X = B, where",
   "   A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "   matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. CSYSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   CSYSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   CSYSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what CSYSVXX would itself produce."],
 "zungrq"=>
  ["ZUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,",
   "which is defined as the last M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(1)**H H(2)**H . . . H(k)**H",
   "as returned by ZGERQF."],
 "strcon"=>
  ["STRCON estimates the reciprocal of the condition number of a",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cgttrf"=>
  ["CGTTRF computes an LU factorization of a complex tridiagonal matrix A",
   "using elimination with partial pivoting and row interchanges.",
   "The factorization has the form",
   "   A = L * U",
   "where L is a product of permutation and unit lower bidiagonal",
   "matrices and U is upper triangular with nonzeros in only the main",
   "diagonal and first two superdiagonals."],
 "clarfy"=>
  ["CLARFY applies an elementary reflector, or Householder matrix, H,",
   "to an n x n Hermitian matrix C, from both the left and the right.",
   "H is represented in the form",
   "   H = I - tau * v * v'",
   "where  tau  is a scalar and  v  is a vector.",
   "If  tau  is  zero, then  H  is taken to be the unit matrix."],
 "zsyconvf"=>
  ["If parameter WAY = 'C':",
   "ZSYCONVF converts the factorization output format used in",
   "ZSYTRF provided on entry in parameter A into the factorization",
   "output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored",
   "on exit in parameters A and E. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in ZSYTRF into",
   "the format used in ZSYTRF_RK (or ZSYTRF_BK).",
   "If parameter WAY = 'R':",
   "ZSYCONVF performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in ZSYTRF_RK",
   "(or ZSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in ZSYTRF that is stored",
   "on exit in parameter A. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in ZSYTRF_RK",
   "(or ZSYTRF_BK) into the format used in ZSYTRF.",
   "ZSYCONVF can also convert in Hermitian matrix case, i.e. between",
   "formats used in ZHETRF and ZHETRF_RK (or ZHETRF_BK)."],
 "cgerfsx"=>
  ["   CGERFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "csytrs_3"=>
  ["CSYTRS_3 solves a system of linear equations A * X = B with a complex",
   "symmetric matrix A using the factorization computed",
   "by CSYTRF_RK or CSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "cgbequb"=>
  ["CGBEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from CGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "dtgevc"=>
  ["DTGEVC computes some or all of the right and/or left eigenvectors of",
   "a pair of real matrices (S,P), where S is a quasi-triangular matrix",
   "and P is upper triangular.  Matrix pairs of this type are produced by",
   "the generalized Schur factorization of a matrix pair (A,B):",
   "   A = Q*S*Z**T,  B = Q*P*Z**T",
   "as computed by DGGHRD + DHGEQZ.",
   "The right eigenvector x and the left eigenvector y of (S,P)",
   "corresponding to an eigenvalue w are defined by:",
   "   S*x = w*P*x,  (y**H)*S = w*(y**H)*P,",
   "where y**H denotes the conjugate tranpose of y.",
   "The eigenvalues are not input to this routine, but are computed",
   "directly from the diagonal blocks of S and P.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of (S,P), or the products Z*X and/or Q*Y,",
   "where Z and Q are input matrices.",
   "If Q and Z are the orthogonal factors from the generalized Schur",
   "factorization of a matrix pair (A,B), then Z*X and Q*Y",
   "are the matrices of right and left eigenvectors of (A,B)."],
 "clansb"=>
  ["CLANSB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n symmetric band matrix A,  with k super-diagonals.",
   "   CLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dgejsv"=>
  ["DGEJSV computes the singular value decomposition (SVD) of a real M-by-N",
   "matrix [A], where M >= N. The SVD of [A] is written as",
   "             [A] = [U] * [SIGMA] * [V]^t,",
   "where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N",
   "diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and",
   "[V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are",
   "the singular values of [A]. The columns of [U] and [V] are the left and",
   "the right singular vectors of [A], respectively. The matrices [U] and [V]",
   "are computed and stored in the arrays U and V, respectively. The diagonal",
   "of [SIGMA] is computed and stored in the array SVA.",
   "DGEJSV can sometimes compute tiny singular values and their singular vectors much",
   "more accurately than other SVD routines, see below under Further Details."],
 "sggglm"=>
  ["SGGGLM solves a general Gauss-Markov linear model (GLM) problem:",
   "        minimize || y ||_2   subject to   d = A*x + B*y",
   "            x",
   "where A is an N-by-M matrix, B is an N-by-P matrix, and d is a",
   "given N-vector. It is assumed that M <= N <= M+P, and",
   "           rank(A) = M    and    rank( A B ) = N.",
   "Under these assumptions, the constrained equation is always",
   "consistent, and there is a unique solution x and a minimal 2-norm",
   "solution y, which is obtained using a generalized QR factorization",
   "of the matrices (A, B) given by",
   "   A = Q*(R),   B = Q*T*Z.",
   "         (0)",
   "In particular, if matrix B is square nonsingular, then the problem",
   "GLM is equivalent to the following weighted linear least squares",
   "problem",
   "             minimize || inv(B)*(d-A*x) ||_2",
   "                 x",
   "where inv(B) denotes the inverse of B."],
 "dsytf2"=>
  ["DSYTF2 computes the factorization of a real symmetric matrix A using",
   "the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "dgeqr"=>["DGEQR computes a QR factorization of an M-by-N matrix A."],
 "zhesv_rk"=>
  ["ZHESV_RK computes the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N Hermitian matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "ZHETRF_RK is called to compute the factorization of a complex",
   "Hermitian matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine ZHETRS_3."],
 "dsptrf"=>
  ["DSPTRF computes the factorization of a real symmetric matrix A stored",
   "in packed format using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "ssysvx"=>
  ["SSYSVX uses the diagonal pivoting factorization to compute the",
   "solution to a real system of linear equations A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zgesc2"=>
  ["ZGESC2 solves a system of linear equations",
   "          A * X = scale* RHS",
   "with a general N-by-N matrix A using the LU factorization with",
   "complete pivoting computed by ZGETC2."],
 "stpttr"=>
  ["STPTTR copies a triangular matrix A from standard packed format (TP)",
   "to standard full format (TR)."],
 "sorgql"=>
  ["SORGQL generates an M-by-N real matrix Q with orthonormal columns,",
   "which is defined as the last N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by SGEQLF."],
 "cung2l"=>
  ["CUNG2L generates an m by n complex matrix Q with orthonormal columns,",
   "which is defined as the last n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by CGEQLF."],
 "dorglq"=>
  ["DORGLQ generates an M-by-N real matrix Q with orthonormal rows,",
   "which is defined as the first M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by DGELQF."],
 "zgtrfs"=>
  ["ZGTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is tridiagonal, and provides",
   "error bounds and backward error estimates for the solution."],
 "csytrs2"=>
  ["CSYTRS2 solves a system of linear equations A*X = B with a COMPLEX",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by CSYTRF and converted by CSYCONV."],
 "sgtrfs"=>
  ["SGTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is tridiagonal, and provides",
   "error bounds and backward error estimates for the solution."],
 "slasr"=>
  ["SLASR applies a sequence of plane rotations to a real matrix A,",
   "from either the left or the right.",
   "When SIDE = 'L', the transformation takes the form",
   "   A := P*A",
   "and when SIDE = 'R', the transformation takes the form",
   "   A := A*P**T",
   "where P is an orthogonal matrix consisting of a sequence of z plane",
   "rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',",
   "and P**T is the transpose of P.",
   "When DIRECT = 'F' (Forward sequence), then",
   "   P = P(z-1) * ... * P(2) * P(1)",
   "and when DIRECT = 'B' (Backward sequence), then",
   "   P = P(1) * P(2) * ... * P(z-1)",
   "where P(k) is a plane rotation matrix defined by the 2-by-2 rotation",
   "   R(k) = (  c(k)  s(k) )",
   "        = ( -s(k)  c(k) ).",
   "When PIVOT = 'V' (Variable pivot), the rotation is performed",
   "for the plane (k,k+1), i.e., P(k) has the form",
   "   P(k) = (  1                                            )",
   "          (       ...                                     )",
   "          (              1                                )",
   "          (                   c(k)  s(k)                  )",
   "          (                  -s(k)  c(k)                  )",
   "          (                                1              )",
   "          (                                     ...       )",
   "          (                                            1  )",
   "where R(k) appears as a rank-2 modification to the identity matrix in",
   "rows and columns k and k+1.",
   "When PIVOT = 'T' (Top pivot), the rotation is performed for the",
   "plane (1,k+1), so P(k) has the form",
   "   P(k) = (  c(k)                    s(k)                 )",
   "          (         1                                     )",
   "          (              ...                              )",
   "          (                     1                         )",
   "          ( -s(k)                    c(k)                 )",
   "          (                                 1             )",
   "          (                                      ...      )",
   "          (                                             1 )",
   "where R(k) appears in rows and columns 1 and k+1.",
   "Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is",
   "performed for the plane (k,z), giving P(k) the form",
   "   P(k) = ( 1                                             )",
   "          (      ...                                      )",
   "          (             1                                 )",
   "          (                  c(k)                    s(k) )",
   "          (                         1                     )",
   "          (                              ...              )",
   "          (                                     1         )",
   "          (                 -s(k)                    c(k) )",
   "where R(k) appears in rows and columns k and z.  The rotations are",
   "performed without ever forming P(k) explicitly."],
 "zunbdb5"=>[],
 "zlagtm"=>
  ["ZLAGTM performs a matrix-vector product of the form",
   "   B := alpha * A * X + beta * B",
   "where A is a tridiagonal matrix of order N, B and X are N by NRHS",
   "matrices, and alpha and beta are real scalars, each of which may be",
   "0., 1., or -1."],
 "sormbr"=>
  ["If VECT = 'Q', SORMBR overwrites the general real M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "If VECT = 'P', SORMBR overwrites the general real M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      P * C          C * P",
   "TRANS = 'T':      P**T * C       C * P**T",
   "Here Q and P**T are the orthogonal matrices determined by SGEBRD when",
   "reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and",
   "P**T are defined as products of elementary reflectors H(i) and G(i)",
   "respectively.",
   "Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the",
   "order of the orthogonal matrix Q or P**T that is applied.",
   "If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:",
   "if nq >= k, Q = H(1) H(2) . . . H(k);",
   "if nq < k, Q = H(1) H(2) . . . H(nq-1).",
   "If VECT = 'P', A is assumed to have been a K-by-NQ matrix:",
   "if k < nq, P = G(1) G(2) . . . G(k);",
   "if k >= nq, P = G(1) G(2) . . . G(nq-1)."],
 "zposv"=>
  ["ZPOSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H* U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and  L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "dtrevc3"=>
  ["DTREVC3 computes some or all of the right and/or left eigenvectors of",
   "a real upper quasi-triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "   T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal blocks of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix. If Q is the orthogonal factor that reduces a matrix",
   "A to Schur form T, then Q*X and Q*Y are the matrices of right and",
   "left eigenvectors of A.",
   "This uses a Level 3 BLAS version of the back transformation."],
 "slas2"=>
  ["SLAS2  computes the singular values of the 2-by-2 matrix",
   "   [  F   G  ]",
   "   [  0   H  ].",
   "On return, SSMIN is the smaller singular value and SSMAX is the",
   "larger singular value."],
 "zpbsvx"=>
  ["ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zpotrf2"=>
  ["ZPOTRF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A using the recursive algorithm.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = n/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "The subroutine calls itself to factor A11. Update and scale A21",
   "or A12, update A22 then call itself to factor A22."],
 "chpev"=>
  ["CHPEV computes all the eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix in packed storage."],
 "ctprfb"=>
  ["CTPRFB applies a complex \"triangular-pentagonal\" block reflector H or its",
   "conjugate transpose H**H to a complex matrix C, which is composed of two",
   "blocks A and B, either from the left or right."],
 "cgetrs"=>
  ["CGETRS solves a system of linear equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B",
   "with a general N-by-N matrix A using the LU factorization computed",
   "by CGETRF."],
 "clatdf"=>
  ["CLATDF computes the contribution to the reciprocal Dif-estimate",
   "by solving for x in Z * x = b, where b is chosen such that the norm",
   "of x is as large as possible. It is assumed that LU decomposition",
   "of Z has been computed by CGETC2. On entry RHS = f holds the",
   "contribution from earlier solved sub-systems, and on return RHS = x.",
   "The factorization of Z returned by CGETC2 has the form",
   "Z = P * L * U * Q, where P and Q are permutation matrices. L is lower",
   "triangular with unit diagonal elements and U is upper triangular."],
 "dtrcon"=>
  ["DTRCON estimates the reciprocal of the condition number of a",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cgbtrf"=>
  ["CGBTRF computes an LU factorization of a complex m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "stgsy2"=>
  ["STGSY2 solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C                (1)",
   "            D * R - L * E = scale * F,",
   "using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,",
   "(A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,",
   "N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)",
   "must be in generalized Schur canonical form, i.e. A, B are upper",
   "quasi triangular and D, E are upper triangular. The solution (R, L)",
   "overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor",
   "chosen to avoid overflow.",
   "In matrix notation solving equation (1) corresponds to solve",
   "Z*x = scale*b, where Z is defined as",
   "       Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)",
   "           [ kron(In, D)  -kron(E**T, Im) ],",
   "Ik is the identity matrix of size k and X**T is the transpose of X.",
   "kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "In the process of solving (1), we solve a number of such systems",
   "where Dim(In), Dim(In) = 1 or 2.",
   "If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,",
   "which is equivalent to solve for R and L in",
   "            A**T * R  + D**T * L   = scale * C           (3)",
   "            R  * B**T + L  * E**T  = scale * -F",
   "This case is used to compute an estimate of Dif[(A, D), (B, E)] =",
   "sigma_min(Z) using reverse communicaton with SLACON.",
   "STGSY2 also (IJOB >= 1) contributes to the computation in STGSYL",
   "of an upper bound on the separation between to matrix pairs. Then",
   "the input (A, D), (B, E) are sub-pencils of the matrix pair in",
   "STGSYL. See STGSYL for details."],
 "zgeqr2"=>
  ["ZGEQR2 computes a QR factorization of a complex m by n matrix A:",
   "A = Q * R."],
 "zla_porpvgrw"=>
  ["ZLA_PORPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "ztplqt2"=>
  ["ZTPLQT2 computes a LQ a factorization of a complex \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "slasdq"=>
  ["SLASDQ computes the singular value decomposition (SVD) of a real",
   "(upper or lower) bidiagonal matrix with diagonal D and offdiagonal",
   "E, accumulating the transformations if desired. Letting B denote",
   "the input bidiagonal matrix, the algorithm computes orthogonal",
   "matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose",
   "of P). The singular values S are overwritten on D.",
   "The input matrix U  is changed to U  * Q  if desired.",
   "The input matrix VT is changed to P**T * VT if desired.",
   "The input matrix C  is changed to Q**T * C  if desired.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3, for a detailed description of the algorithm."],
 "claqr2"=>
  ["   CLAQR2 is identical to CLAQR3 except that it avoids",
   "   recursion by calling CLAHQR instead of CLAQR4.",
   "   Aggressive early deflation:",
   "   This subroutine accepts as input an upper Hessenberg matrix",
   "   H and performs an unitary similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an unitary similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "ssyev_2stage"=>
  ["SSYEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "sgbsv"=>
  ["SGBSV computes the solution to a real system of linear equations",
   "A * X = B, where A is a band matrix of order N with KL subdiagonals",
   "and KU superdiagonals, and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as A = L * U, where L is a product of permutation",
   "and unit lower triangular matrices with KL subdiagonals, and U is",
   "upper triangular with KL+KU superdiagonals.  The factored form of A",
   "is then used to solve the system of equations A * X = B."],
 "ctzrzf"=>
  ["CTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A",
   "to upper triangular form by means of unitary transformations.",
   "The upper trapezoidal matrix A is factored as",
   "   A = ( R  0 ) * Z,",
   "where Z is an N-by-N unitary matrix and R is an M-by-M upper",
   "triangular matrix."],
 "stgsen"=>
  ["STGSEN reorders the generalized real Schur decomposition of a real",
   "matrix pair (A, B) (in terms of an orthonormal equivalence trans-",
   "formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues",
   "appears in the leading diagonal blocks of the upper quasi-triangular",
   "matrix A and the upper triangular B. The leading columns of Q and",
   "Z form orthonormal bases of the corresponding left and right eigen-",
   "spaces (deflating subspaces). (A, B) must be in generalized real",
   "Schur canonical form (as returned by SGGES), i.e. A is block upper",
   "triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper",
   "triangular.",
   "STGSEN also computes the generalized eigenvalues",
   "            w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)",
   "of the reordered matrix pair (A, B).",
   "Optionally, STGSEN computes the estimates of reciprocal condition",
   "numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),",
   "(A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)",
   "between the matrix pairs (A11, B11) and (A22,B22) that correspond to",
   "the selected cluster and the eigenvalues outside the cluster, resp.,",
   "and norms of \"projections\" onto left and right eigenspaces w.r.t.",
   "the selected cluster in the (1,1)-block."],
 "zlatrs"=>
  ["ZLATRS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow.  Here A is an upper or lower",
   "triangular matrix, A**T denotes the transpose of A, A**H denotes the",
   "conjugate transpose of A, x and b are n-element vectors, and s is a",
   "scaling factor, usually less than or equal to 1, chosen so that the",
   "components of x will be less than the overflow threshold.  If the",
   "unscaled problem will not cause overflow, the Level 2 BLAS routine",
   "ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),",
   "then s is set to 0 and a non-trivial solution to A*x = 0 is returned."],
 "dpotrf"=>
  ["DPOTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "zhb2st_kernels"=>
  ["ZHB2ST_KERNELS is an internal routine used by the ZHETRD_HB2ST",
   "subroutine."],
 "zlatps"=>
  ["ZLATPS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular matrix stored in packed form.  Here A**T denotes the",
   "transpose of A, A**H denotes the conjugate transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine ZTPSV is called. If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "cpotrf2"=>
  ["CPOTRF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A using the recursive algorithm.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = n/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "The subroutine calls itself to factor A11. Update and scale A21",
   "or A12, update A22 then calls itself to factor A22."],
 "zlahef_rook"=>
  ["ZLAHEF_ROOK computes a partial factorization of a complex Hermitian",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting",
   "method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0      I     )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**H denotes the conjugate transpose of U.",
   "ZLAHEF_ROOK is an auxiliary routine called by ZHETRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "dlaexc"=>
  ["DLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in",
   "an upper quasi-triangular matrix T by an orthogonal similarity",
   "transformation.",
   "T must be in Schur canonical form, that is, block upper triangular",
   "with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block",
   "has its diagonal elemnts equal and its off-diagonal elements of",
   "opposite sign."],
 "zunmqr"=>
  ["ZUNMQR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "dlasq3"=>
  ["DLASQ3 checks for deflation, computes a shift (TAU) and calls dqds.",
   "In case of failure it changes shifts, and tries again until output",
   "is positive."],
 "zla_gercond_c"=>
  ["   ZLA_GERCOND_C computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector."],
 "ztgsyl"=>
  ["ZTGSYL solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C            (1)",
   "            D * R - L * E = scale * F",
   "where R and L are unknown m-by-n matrices, (A, D), (B, E) and",
   "(C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,",
   "respectively, with complex entries. A, B, D and E are upper",
   "triangular (i.e., (A,D) and (B,E) in generalized Schur form).",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1",
   "is an output scaling factor chosen to avoid overflow.",
   "In matrix notation (1) is equivalent to solve Zx = scale*b, where Z",
   "is defined as",
   "       Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)",
   "           [ kron(In, D)  -kron(E**H, Im) ],",
   "Here Ix is the identity matrix of size x and X**H is the conjugate",
   "transpose of X. Kron(X, Y) is the Kronecker product between the",
   "matrices X and Y.",
   "If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b",
   "is solved for, which is equivalent to solve for R and L in",
   "            A**H * R + D**H * L = scale * C           (3)",
   "            R * B**H + L * E**H = scale * -F",
   "This case (TRANS = 'C') is used to compute an one-norm-based estimate",
   "of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)",
   "and (B,E), using ZLACON.",
   "If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of",
   "Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the",
   "reciprocal of the smallest singular value of Z.",
   "This is a level-3 BLAS algorithm."],
 "zsytrs"=>
  ["ZSYTRS solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by ZSYTRF."],
 "sstevd"=>
  ["SSTEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric tridiagonal matrix. If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlaruv"=>
  ["DLARUV returns a vector of n random real numbers from a uniform (0,1)",
   "distribution (n <= 128).",
   "This is an auxiliary routine called by DLARNV and ZLARNV."],
 "dgelq2"=>
  ["DGELQ2 computes an LQ factorization of a real m by n matrix A:",
   "A = L * Q."],
 "slapy2"=>
  ["SLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary",
   "overflow."],
 "ssbevx_2stage"=>
  ["SSBEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal. Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "dtrttf"=>
  ["DTRTTF copies a triangular matrix A from standard full format (TR)",
   "to rectangular full packed format (TF) ."],
 "sisnan"=>
  ["SISNAN returns .TRUE. if its argument is NaN, and .FALSE.",
   "otherwise.  To be replaced by the Fortran 2003 intrinsic in the",
   "future."],
 "dla_gercond"=>
  ["   DLA_GERCOND estimates the Skeel condition number of op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "sorghr"=>
  ["SORGHR generates a real orthogonal matrix Q which is defined as the",
   "product of IHI-ILO elementary reflectors of order N, as returned by",
   "SGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "cgelq"=>["CGELQ computes a LQ factorization of an M-by-N matrix A."],
 "stftri"=>
  ["STFTRI computes the inverse of a triangular matrix A stored in RFP",
   "format.",
   "This is a Level 3 BLAS version of the algorithm."],
 "dlarrb"=>
  ["Given the relatively robust representation(RRR) L D L^T, DLARRB",
   "does \"limited\" bisection to refine the eigenvalues of L D L^T,",
   "W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial",
   "guesses for these eigenvalues are input in W, the corresponding estimate",
   "of the error in these guesses and their gaps are input in WERR",
   "and WGAP, respectively. During bisection, intervals",
   "[left, right] are maintained by storing their mid-points and",
   "semi-widths in the arrays W and WERR respectively."],
 "ztptrs"=>
  ["ZTPTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular matrix of order N stored in packed format,",
   "and B is an N-by-NRHS matrix.  A check is made to verify that A is",
   "nonsingular."],
 "dlatsqr"=>
  ["DLATSQR computes a blocked Tall-Skinny QR factorization of",
   "an M-by-N matrix A, where M >= N:",
   "A = Q * R ."],
 "sstein"=>
  ["SSTEIN computes the eigenvectors of a real symmetric tridiagonal",
   "matrix T corresponding to specified eigenvalues, using inverse",
   "iteration.",
   "The maximum number of iterations allowed for each eigenvector is",
   "specified by an internal parameter MAXITS (currently set to 5)."],
 "sormqr"=>
  ["SORMQR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by SGEQRF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "zhprfs"=>
  ["ZHPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "sgeqrf"=>
  ["SGEQRF computes a QR factorization of a real M-by-N matrix A:",
   "A = Q * R."],
 "zhbgst"=>
  ["ZHBGST reduces a complex Hermitian-definite banded generalized",
   "eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,",
   "such that C has the same bandwidth as A.",
   "B must have been previously factorized as S**H*S by ZPBSTF, using a",
   "split Cholesky factorization. A is overwritten by C = X**H*A*X, where",
   "X = S**(-1)*Q and Q is a unitary matrix chosen to preserve the",
   "bandwidth of A."],
 "zgeqrf"=>
  ["ZGEQRF computes a QR factorization of a complex M-by-N matrix A:",
   "A = Q * R."],
 "ctgexc"=>
  ["CTGEXC reorders the generalized Schur decomposition of a complex",
   "matrix pair (A,B), using an unitary equivalence transformation",
   "(A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with",
   "row index IFST is moved to row ILST.",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H",
   "       Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H"],
 "dsycon_rook"=>
  ["DSYCON_ROOK estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by DSYTRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "clarft"=>
  ["CLARFT forms the triangular factor T of a complex block reflector H",
   "of order n, which is defined as a product of k elementary reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**H",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**H * T * V"],
 "ssycon_rook"=>
  ["SSYCON_ROOK estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cppcon"=>
  ["CPPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite packed matrix using",
   "the Cholesky factorization A = U**H*U or A = L*L**H computed by",
   "CPPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zunbdb6"=>[],
 "cposvxx"=>
  ["   CPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T",
   "   to compute the solution to a complex system of linear equations",
   "   A * X = B, where A is an N-by-N symmetric positive definite matrix",
   "   and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. CPOSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   CPOSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   CPOSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what CPOSVXX would itself produce."],
 "sgetrf"=>
  ["SGETRF computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 3 BLAS version of the algorithm."],
 "strsyl"=>
  ["STRSYL solves the real Sylvester matrix equation:",
   "   op(A)*X + X*op(B) = scale*C or",
   "   op(A)*X - X*op(B) = scale*C,",
   "where op(A) = A or A**T, and  A and B are both upper quasi-",
   "triangular. A is M-by-M and B is N-by-N; the right hand side C and",
   "the solution X are M-by-N; and scale is an output scale factor, set",
   "<= 1 to avoid overflow in X.",
   "A and B must be in Schur canonical form (as returned by SHSEQR), that",
   "is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;",
   "each 2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "zpftrs"=>
  ["ZPFTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**H*U or A = L*L**H computed by ZPFTRF."],
 "sgeql2"=>
  ["SGEQL2 computes a QL factorization of a real m by n matrix A:",
   "A = Q * L."],
 "zhetri_3x"=>
  ["ZHETRI_3X computes the inverse of a complex Hermitian indefinite",
   "matrix A using the factorization computed by ZHETRF_RK or ZHETRF_BK:",
   "    A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dgetri"=>
  ["DGETRI computes the inverse of a matrix using the LU factorization",
   "computed by DGETRF.",
   "This method inverts U and then computes inv(A) by solving the system",
   "inv(A)*L = inv(U) for inv(A)."],
 "clangt"=>
  ["CLANGT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex tridiagonal matrix A.",
   "   CLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "chpgvx"=>
  ["CHPGVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian, stored in packed format, and B is also",
   "positive definite.  Eigenvalues and eigenvectors can be selected by",
   "specifying either a range of values or a range of indices for the",
   "desired eigenvalues."],
 "cpttrs"=>
  ["CPTTRS solves a tridiagonal system of the form",
   "   A * X = B",
   "using the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.",
   "D is a diagonal matrix specified in the vector D, U (or L) is a unit",
   "bidiagonal matrix whose superdiagonal (subdiagonal) is specified in",
   "the vector E, and X and B are N by NRHS matrices."],
 "cpbstf"=>
  ["CPBSTF computes a split Cholesky factorization of a complex",
   "Hermitian positive definite band matrix A.",
   "This routine is designed to be used in conjunction with CHBGST.",
   "The factorization has the form  A = S**H*S  where S is a band matrix",
   "of the same bandwidth as A and the following structure:",
   "  S = ( U    )",
   "      ( M  L )",
   "where U is upper triangular of order m = (n+kd)/2, and L is lower",
   "triangular of order n-m."],
 "cgehrd"=>
  ["CGEHRD reduces a complex general matrix A to upper Hessenberg form H by",
   "an unitary similarity transformation:  Q**H * A * Q = H ."],
 "zhbgvd"=>
  ["ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zhesv_rook"=>
  ["ZHESV_ROOK computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "The bounded Bunch-Kaufman (\"rook\") diagonal pivoting method is used",
   "to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "ZHETRF_ROOK is called to compute the factorization of a complex",
   "Hermition matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling ZHETRS_ROOK (uses BLAS 2)."],
 "zhesvx"=>
  ["ZHESVX uses the diagonal pivoting factorization to compute the",
   "solution to a complex system of linear equations A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zsytri_3"=>
  ["ZSYTRI_3 computes the inverse of a complex symmetric indefinite",
   "matrix A using the factorization computed by ZSYTRF_RK or ZSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "ZSYTRI_3 sets the leading dimension of the workspace  before calling",
   "ZSYTRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "ztpcon"=>
  ["ZTPCON estimates the reciprocal of the condition number of a packed",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dlar2v"=>
  ["DLAR2V applies a vector of real plane rotations from both sides to",
   "a sequence of 2-by-2 real symmetric matrices, defined by the elements",
   "of the vectors x, y and z. For i = 1,2,...,n",
   "   ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )",
   "   ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )"],
 "zptrfs"=>
  ["ZPTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and tridiagonal, and provides error bounds and backward error",
   "estimates for the solution."],
 "dpteqr"=>
  ["DPTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric positive definite tridiagonal matrix by first factoring the",
   "matrix using DPTTRF, and then calling DBDSQR to compute the singular",
   "values of the bidiagonal factor.",
   "This routine computes the eigenvalues of the positive definite",
   "tridiagonal matrix to high relative accuracy.  This means that if the",
   "eigenvalues range over many orders of magnitude in size, then the",
   "small eigenvalues and corresponding eigenvectors will be computed",
   "more accurately than, for example, with the standard QR method.",
   "The eigenvectors of a full or band symmetric positive definite matrix",
   "can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to",
   "reduce this matrix to tridiagonal form. (The reduction to tridiagonal",
   "form, however, may preclude the possibility of obtaining high",
   "relative accuracy in the small eigenvalues of the original matrix, if",
   "these eigenvalues range over many orders of magnitude.)"],
 "zhetrs_rook"=>
  ["ZHETRS_ROOK solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHETRF_ROOK."],
 "csytf2_rk"=>
  ["CSYTF2_RK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "zlatbs"=>
  ["ZLATBS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular band matrix.  Here A**T denotes the transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine ZTBSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "zstegr"=>
  ["ZSTEGR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "ZSTEGR is a compatibility wrapper around the improved ZSTEMR routine.",
   "See DSTEMR for further details.",
   "One important change is that the ABSTOL parameter no longer provides any",
   "benefit and hence is no longer used.",
   "Note : ZSTEGR and ZSTEMR work only on machines which follow",
   "IEEE-754 floating-point standard in their handling of infinities and",
   "NaNs.  Normal execution may create these exceptiona values and hence",
   "may abort due to a floating point exception in environments which",
   "do not conform to the IEEE-754 standard."],
 "spftrs"=>
  ["SPFTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by SPFTRF."],
 "cpotrf"=>
  ["CPOTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "cspr"=>
  ["CSPR    performs the symmetric rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a complex scalar, x is an n element vector and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "ztprfb"=>
  ["ZTPRFB applies a complex \"triangular-pentagonal\" block reflector H or its",
   "conjugate transpose H**H to a complex matrix C, which is composed of two",
   "blocks A and B, either from the left or right."],
 "zsytri2x"=>
  ["ZSYTRI2X computes the inverse of a complex symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "ZSYTRF."],
 "cppsv"=>
  ["CPPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "cgbrfs"=>
  ["CGBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is banded, and provides",
   "error bounds and backward error estimates for the solution."],
 "zsyswapr"=>
  ["ZSYSWAPR applies an elementary permutation on the rows and the columns of",
   "a symmetric matrix."],
 "dlalsa"=>
  ["DLALSA is an itermediate step in solving the least squares problem",
   "by computing the SVD of the coefficient matrix in compact form (The",
   "singular vectors are computed as products of simple orthorgonal",
   "matrices.).",
   "If ICOMPQ = 0, DLALSA applies the inverse of the left singular vector",
   "matrix of an upper bidiagonal matrix to the right hand side; and if",
   "ICOMPQ = 1, DLALSA applies the right singular vector matrix to the",
   "right hand side. The singular vector matrices were generated in",
   "compact form by DLALSA."],
 "dgeqp3"=>
  ["DGEQP3 computes a QR factorization with column pivoting of a",
   "matrix A:  A*P = Q*R  using Level 3 BLAS."],
 "zptcon"=>
  ["ZPTCON computes the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite tridiagonal matrix",
   "using the factorization A = L*D*L**H or A = U**H*D*U computed by",
   "ZPTTRF.",
   "Norm(inv(A)) is computed by a direct method, and the reciprocal of",
   "the condition number is computed as",
   "                 RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dporfsx"=>
  ["   DPORFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric positive",
   "   definite, and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dtrexc"=>
  ["DTREXC reorders the real Schur factorization of a real matrix",
   "A = Q*T*Q**T, so that the diagonal block of T with row index IFST is",
   "moved to row ILST.",
   "The real Schur form T is reordered by an orthogonal similarity",
   "transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors",
   "is updated by postmultiplying it with Z.",
   "T must be in Schur canonical form (as returned by DHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "slarrk"=>
  ["SLARRK computes one eigenvalue of a symmetric tridiagonal",
   "matrix T to suitable accuracy. This is an auxiliary code to be",
   "called from SSTEMR.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "dtgex2"=>
  ["DTGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)",
   "of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair",
   "(A, B) by an orthogonal equivalence transformation.",
   "(A, B) must be in generalized real Schur canonical form (as returned",
   "by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2",
   "diagonal blocks. B is upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T",
   "       Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T"],
 "zlaqsy"=>
  ["ZLAQSY equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "slargv"=>
  ["SLARGV generates a vector of real plane rotations, determined by",
   "elements of the real vectors x and y. For i = 1,2,...,n",
   "   (  c(i)  s(i) ) ( x(i) ) = ( a(i) )",
   "   ( -s(i)  c(i) ) ( y(i) ) = (   0  )"],
 "stgexc"=>
  ["STGEXC reorders the generalized real Schur decomposition of a real",
   "matrix pair (A,B) using an orthogonal equivalence transformation",
   "               (A, B) = Q * (A, B) * Z**T,",
   "so that the diagonal block of (A, B) with row index IFST is moved",
   "to row ILST.",
   "(A, B) must be in generalized real Schur canonical form (as returned",
   "by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2",
   "diagonal blocks. B is upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T",
   "       Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T"],
 "zgtts2"=>
  ["ZGTTS2 solves one of the systems of equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by ZGTTRF."],
 "zheev_2stage"=>
  ["ZHEEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "slacon"=>
  ["SLACON estimates the 1-norm of a square, real matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "zheevr_2stage"=>
  ["ZHEEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "ZHEEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call",
   "to ZHETRD.  Then, whenever possible, ZHEEVR_2STAGE calls ZSTEMR to compute",
   "eigenspectrum using Relatively Robust Representations.  ZSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : ZHEEVR_2STAGE calls ZSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "ZHEEVR_2STAGE calls DSTEBZ and ZSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of ZSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "dlantp"=>
  ["DLANTP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "triangular matrix A, supplied in packed form.",
   "   DLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "sggev3"=>
  ["SGGEV3 computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j).",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B .",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "cheevr_2stage"=>
  ["CHEEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "CHEEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call",
   "to CHETRD.  Then, whenever possible, CHEEVR_2STAGE calls CSTEMR to compute",
   "eigenspectrum using Relatively Robust Representations.  CSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : CHEEVR_2STAGE calls CSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "CHEEVR_2STAGE calls SSTEBZ and CSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of CSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "clag2z"=>
  ["CLAG2Z converts a COMPLEX matrix, SA, to a COMPLEX*16 matrix, A.",
   "Note that while it is possible to overflow while converting",
   "from double to single, it is not possible to overflow when",
   "converting from single to double.",
   "This is an auxiliary routine so there is no argument checking."],
 "dlags2"=>
  ["DLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such",
   "that if ( UPPER ) then",
   "          U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )",
   "                            ( 0  A3 )     ( x  x  )",
   "and",
   "          V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )",
   "                           ( 0  B3 )     ( x  x  )",
   "or if ( .NOT.UPPER ) then",
   "          U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )",
   "                            ( A2 A3 )     ( 0  x  )",
   "and",
   "          V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )",
   "                          ( B2 B3 )     ( 0  x  )",
   "The rows of the transformed A and B are parallel, where",
   "  U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )",
   "      ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )",
   "Z**T denotes the transpose of Z."],
 "zla_gbamv"=>
  ["ZLA_GBAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "sgttrf"=>
  ["SGTTRF computes an LU factorization of a real tridiagonal matrix A",
   "using elimination with partial pivoting and row interchanges.",
   "The factorization has the form",
   "   A = L * U",
   "where L is a product of permutation and unit lower bidiagonal",
   "matrices and U is upper triangular with nonzeros in only the main",
   "diagonal and first two superdiagonals."],
 "sorgqr"=>
  ["SORGQR generates an M-by-N real matrix Q with orthonormal columns,",
   "which is defined as the first N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by SGEQRF."],
 "dtrti2"=>
  ["DTRTI2 computes the inverse of a real upper or lower triangular",
   "matrix.",
   "This is the Level 2 BLAS version of the algorithm."],
 "cgees"=>
  ["CGEES computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues, the Schur form T, and, optionally, the matrix of Schur",
   "vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "Schur form so that selected eigenvalues are at the top left.",
   "The leading columns of Z then form an orthonormal basis for the",
   "invariant subspace corresponding to the selected eigenvalues.",
   "A complex matrix is in Schur form if it is upper triangular."],
 "cla_syrcond_x"=>
  ["   CLA_SYRCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX vector."],
 "chptri"=>
  ["CHPTRI computes the inverse of a complex Hermitian indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHPTRF."],
 "zlapmt"=>
  ["ZLAPMT rearranges the columns of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N."],
 "zlarzb"=>
  ["ZLARZB applies a complex block reflector H or its transpose H**H",
   "to a complex distributed M-by-N  C from the left or the right.",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "dgsvj0"=>
  ["DGSVJ0 is called from DGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as DGESVJ does, but",
   "it does not check convergence (stopping criterion). Few tuning",
   "parameters (marked by [TP]) are available for the implementer."],
 "zhetrd"=>
  ["ZHETRD reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "sgetrs"=>
  ["SGETRS solves a system of linear equations",
   "   A * X = B  or  A**T * X = B",
   "with a general N-by-N matrix A using the LU factorization computed",
   "by SGETRF."],
 "zlaqp2"=>
  ["ZLAQP2 computes a QR factorization with column pivoting of",
   "the block A(OFFSET+1:M,1:N).",
   "The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "dbdsvdx"=>
  [" DBDSVDX computes the singular value decomposition (SVD) of a real",
   " N-by-N (upper or lower) bidiagonal matrix B, B = U * S * VT,",
   " where S is a diagonal matrix with non-negative diagonal elements",
   " (the singular values of B), and U and VT are orthogonal matrices",
   " of left and right singular vectors, respectively.",
   " Given an upper bidiagonal B with diagonal D = [ d_1 d_2 ... d_N ]",
   " and superdiagonal E = [ e_1 e_2 ... e_N-1 ], DBDSVDX computes the",
   " singular value decompositon of B through the eigenvalues and",
   " eigenvectors of the N*2-by-N*2 tridiagonal matrix",
   "       |  0  d_1                |",
   "       | d_1  0  e_1            |",
   " TGK = |     e_1  0  d_2        |",
   "       |         d_2  .   .     |",
   "       |              .   .   . |",
   " If (s,u,v) is a singular triplet of B with ||u|| = ||v|| = 1, then",
   " (+/-s,q), ||q|| = 1, are eigenpairs of TGK, with q = P * ( u' +/-v' ) /",
   " sqrt(2) = ( v_1 u_1 v_2 u_2 ... v_n u_n ) / sqrt(2), and",
   " P = [ e_{n+1} e_{1} e_{n+2} e_{2} ... ].",
   " Given a TGK matrix, one can either a) compute -s,-v and change signs",
   " so that the singular values (and corresponding vectors) are already in",
   " descending order (as in DGESVD/DGESDD) or b) compute s,v and reorder",
   " the values (and corresponding vectors). DBDSVDX implements a) by",
   " calling DSTEVX (bisection plus inverse iteration, to be replaced",
   " with a version of the Multiple Relative Robust Representation",
   " algorithm. (See P. Willems and B. Lang, A framework for the MR^3",
   " algorithm: theory and implementation, SIAM J. Sci. Comput.,",
   " 35:740-766, 2013.)"],
 "cgemqrt"=>
  ["CGEMQRT overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'C':    Q**H C            C Q**H",
   "where Q is a complex orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**H",
   "generated using the compact WY representation as returned by CGEQRT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "sstev"=>
  ["SSTEV computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric tridiagonal matrix A."],
 "zlange"=>
  ["ZLANGE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex matrix A.",
   "   ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "sorbdb3"=>[],
 "sbdsqr"=>
  ["SBDSQR computes the singular values and, optionally, the right and/or",
   "left singular vectors from the singular value decomposition (SVD) of",
   "a real N-by-N (upper or lower) bidiagonal matrix B using the implicit",
   "zero-shift QR algorithm.  The SVD of B has the form",
   "   B = Q * S * P**T",
   "where S is the diagonal matrix of singular values, Q is an orthogonal",
   "matrix of left singular vectors, and P is an orthogonal matrix of",
   "right singular vectors.  If left singular vectors are requested, this",
   "subroutine actually returns U*Q instead of Q, and, if right singular",
   "vectors are requested, this subroutine returns P**T*VT instead of",
   "P**T, for given real input matrices U and VT.  When U and VT are the",
   "orthogonal matrices that reduce a general matrix A to bidiagonal",
   "form:  A = U*B*VT, as computed by SGEBRD, then",
   "   A = (U*Q) * S * (P**T*VT)",
   "is the SVD of A.  Optionally, the subroutine may also compute Q**T*C",
   "for a given real input matrix C.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,",
   "no. 5, pp. 873-912, Sept 1990) and",
   "\"Accurate singular values and differential qd algorithms,\" by",
   "B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics",
   "Department, University of California at Berkeley, July 1992",
   "for a detailed description of the algorithm."],
 "csytf2_rook"=>
  ["CSYTF2_ROOK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "sstegr"=>
  ["SSTEGR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "SSTEGR is a compatibility wrapper around the improved SSTEMR routine.",
   "See SSTEMR for further details.",
   "One important change is that the ABSTOL parameter no longer provides any",
   "benefit and hence is no longer used.",
   "Note : SSTEGR and SSTEMR work only on machines which follow",
   "IEEE-754 floating-point standard in their handling of infinities and",
   "NaNs.  Normal execution may create these exceptiona values and hence",
   "may abort due to a floating point exception in environments which",
   "do not conform to the IEEE-754 standard."],
 "dgbsvx"=>
  ["DGBSVX uses the LU factorization to compute the solution to a real",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a band matrix of order N with KL subdiagonals and KU",
   "superdiagonals, and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dsygs2"=>
  ["DSYGS2 reduces a real symmetric-definite generalized eigenproblem",
   "to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T *A*L.",
   "B must have been previously factorized as U**T *U or L*L**T by DPOTRF."],
 "xerbla_array"=>
  ["XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK",
   "and BLAS error handler.  Rather than taking a Fortran string argument",
   "as the function's name, XERBLA_ARRAY takes an array of single",
   "characters along with the array's length.  XERBLA_ARRAY then copies",
   "up to 32 characters of that array into a Fortran string and passes",
   "that to XERBLA.  If called with a non-positive SRNAME_LEN,",
   "XERBLA_ARRAY will call XERBLA with a string of all blank characters.",
   "Say some macro or other device makes XERBLA_ARRAY available to C99",
   "by a name lapack_xerbla and with a common Fortran calling convention.",
   "Then a C99 program could invoke XERBLA via:",
   "   {",
   "     int flen = strlen(__func__);",
   "     lapack_xerbla(__func__, &flen, &info);",
   "   }",
   "Providing XERBLA_ARRAY is not necessary for intercepting LAPACK",
   "errors.  XERBLA_ARRAY calls XERBLA."],
 "sgehd2"=>
  ["SGEHD2 reduces a real general matrix A to upper Hessenberg form H by",
   "an orthogonal similarity transformation:  Q**T * A * Q = H ."],
 "zungqr"=>
  ["ZUNGQR generates an M-by-N complex matrix Q with orthonormal columns,",
   "which is defined as the first N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by ZGEQRF."],
 "slaswlq"=>
  ["         SLASWLQ computes a blocked Short-Wide LQ factorization of a",
   "         M-by-N matrix A, where N >= M:",
   "         A = L * Q"],
 "zlacon"=>
  ["ZLACON estimates the 1-norm of a square, complex matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "zung2r"=>
  ["ZUNG2R generates an m by n complex matrix Q with orthonormal columns,",
   "which is defined as the first n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by ZGEQRF."],
 "zunbdb4"=>[],
 "dsbevx_2stage"=>
  ["DSBEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal. Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "zpotrs"=>
  ["ZPOTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**H * U or A = L * L**H computed by ZPOTRF."],
 "zsyconvf_rook"=>
  ["If parameter WAY = 'C':",
   "ZSYCONVF_ROOK converts the factorization output format used in",
   "ZSYTRF_ROOK provided on entry in parameter A into the factorization",
   "output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored",
   "on exit in parameters A and E. IPIV format for ZSYTRF_ROOK and",
   "ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.",
   "If parameter WAY = 'R':",
   "ZSYCONVF_ROOK performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in ZSYTRF_RK",
   "(or ZSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in ZSYTRF_ROOK that is stored",
   "on exit in parameter A. IPIV format for ZSYTRF_ROOK and",
   "ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.",
   "ZSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between",
   "formats used in ZHETRF_ROOK and ZHETRF_RK (or ZHETRF_BK)."],
 "sorbdb5"=>[],
 "clapmr"=>
  ["CLAPMR rearranges the rows of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(K(I),*) is moved X(I,*) for I = 1,2,...,M.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(I,*) is moved to X(K(I),*) for I = 1,2,...,M."],
 "dgtts2"=>
  ["DGTTS2 solves one of the systems of equations",
   "   A*X = B  or  A**T*X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by DGTTRF."],
 "ztgexc"=>
  ["ZTGEXC reorders the generalized Schur decomposition of a complex",
   "matrix pair (A,B), using an unitary equivalence transformation",
   "(A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with",
   "row index IFST is moved to row ILST.",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H",
   "       Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H"],
 "dlanv2"=>
  ["DLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric",
   "matrix in standard form:",
   "     [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]",
   "     [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]",
   "where either",
   "1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or",
   "2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex",
   "conjugate eigenvalues."],
 "ssbevd"=>
  ["SSBEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A. If eigenvectors are desired, it uses",
   "a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlagtf"=>
  ["DLAGTF factorizes the matrix (T - lambda*I), where T is an n by n",
   "tridiagonal matrix and lambda is a scalar, as",
   "   T - lambda*I = PLU,",
   "where P is a permutation matrix, L is a unit lower tridiagonal matrix",
   "with at most one non-zero sub-diagonal elements per column and U is",
   "an upper triangular matrix with at most two non-zero super-diagonal",
   "elements per column.",
   "The factorization is obtained by Gaussian elimination with partial",
   "pivoting and implicit row scaling.",
   "The parameter LAMBDA is included in the routine so that DLAGTF may",
   "be used, in conjunction with DLAGTS, to obtain eigenvectors of T by",
   "inverse iteration."],
 "sla_wwaddw"=>
  ["   SLA_WWADDW adds a vector W into a doubled-single vector (X, Y).",
   "   This works for all extant IBM's hex and binary floating point",
   "   arithmetics, but not for decimal."],
 "sgemqrt"=>
  ["SGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'T':   Q**T C            C Q**T",
   "where Q is a real orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**T",
   "generated using the compact WY representation as returned by SGEQRT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "dgttrs"=>
  ["DGTTRS solves one of the systems of equations",
   "   A*X = B  or  A**T*X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by DGTTRF."],
 "clagtm"=>
  ["CLAGTM performs a matrix-vector product of the form",
   "   B := alpha * A * X + beta * B",
   "where A is a tridiagonal matrix of order N, B and X are N by NRHS",
   "matrices, and alpha and beta are real scalars, each of which may be",
   "0., 1., or -1."],
 "dpftrs"=>
  ["DPFTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by DPFTRF."],
 "dlaed0"=>
  ["DLAED0 computes all eigenvalues and corresponding eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method."],
 "cunmlq"=>
  ["CUNMLQ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k)**H . . . H(2)**H H(1)**H",
   "as returned by CGELQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "spotrs"=>
  ["SPOTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by SPOTRF."],
 "cspmv"=>
  ["CSPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix, supplied in packed form."],
 "sspgv"=>
  ["SSPGV computes all the eigenvalues and, optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric, stored in packed format,",
   "and B is also positive definite."],
 "zlaein"=>
  ["ZLAEIN uses inverse iteration to find a right or left eigenvector",
   "corresponding to the eigenvalue W of a complex upper Hessenberg",
   "matrix H."],
 "ctrsyl"=>
  ["CTRSYL solves the complex Sylvester matrix equation:",
   "   op(A)*X + X*op(B) = scale*C or",
   "   op(A)*X - X*op(B) = scale*C,",
   "where op(A) = A or A**H, and A and B are both upper triangular. A is",
   "M-by-M and B is N-by-N; the right hand side C and the solution X are",
   "M-by-N; and scale is an output scale factor, set <= 1 to avoid",
   "overflow in X."],
 "slasd2"=>
  ["SLASD2 merges the two sets of singular values together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "singular values are close together or if there is a tiny entry in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one.",
   "SLASD2 is called from SLASD1."],
 "stfttr"=>
  ["STFTTR copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard full format (TR)."],
 "zgeqr2p"=>
  ["ZGEQR2P computes a QR factorization of a complex m by n matrix A:",
   "A = Q * R. The diagonal entries of R are real and nonnegative."],
 "slarnv"=>
  ["SLARNV returns a vector of n random real numbers from a uniform or",
   "normal distribution."],
 "dpbcon"=>
  ["DPBCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite band matrix using the",
   "Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zsysv_rk"=>
  ["ZSYSV_RK computes the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "ZSYTRF_RK is called to compute the factorization of a complex",
   "symmetric matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine ZSYTRS_3."],
 "dsygvd"=>
  ["DSYGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be symmetric and B is also positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slasq1"=>
  ["SLASQ1 computes the singular values of a real N-by-N bidiagonal",
   "matrix with diagonal D and off-diagonal E. The singular values",
   "are computed to high relative accuracy, in the absence of",
   "denormalization, underflow and overflow. The algorithm was first",
   "presented in",
   "\"Accurate singular values and differential qd algorithms\" by K. V.",
   "Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,",
   "1994,",
   "and the present implementation is described in \"An implementation of",
   "the dqds Algorithm (Positive Case)\", LAPACK Working Note."],
 "dsysvx"=>
  ["DSYSVX uses the diagonal pivoting factorization to compute the",
   "solution to a real system of linear equations A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "cgbrfsx"=>
  ["   CGBRFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "zsyr"=>
  ["ZSYR   performs the symmetric rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a complex scalar, x is an n element vector and A is an",
   "n by n symmetric matrix."],
 "sgesv"=>
  ["SGESV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as",
   "   A = P * L * U,",
   "where P is a permutation matrix, L is unit lower triangular, and U is",
   "upper triangular.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "xerbla"=>
  ["XERBLA  is an error handler for the LAPACK routines.",
   "It is called by an LAPACK routine if an input parameter has an",
   "invalid value.  A message is printed and execution stops.",
   "Installers may consider modifying the STOP statement in order to",
   "call system-specific exception-handling facilities."],
 "sggsvp3"=>
  ["SGGSVP3 computes orthogonal matrices U, V and Q such that",
   "                   N-K-L  K    L",
   " U**T*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;",
   "                L ( 0     0   A23 )",
   "            M-K-L ( 0     0    0  )",
   "                 N-K-L  K    L",
   "        =     K ( 0    A12  A13 )  if M-K-L < 0;",
   "            M-K ( 0     0   A23 )",
   "                 N-K-L  K    L",
   " V**T*B*Q =   L ( 0     0   B13 )",
   "            P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective",
   "numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.",
   "This decomposition is the preprocessing step for computing the",
   "Generalized Singular Value Decomposition (GSVD), see subroutine",
   "SGGSVD3."],
 "cgtts2"=>
  ["CGTTS2 solves one of the systems of equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by CGTTRF."],
 "dlarscl2"=>
  ["DLARSCL2 performs a reciprocal diagonal scaling on an vector:",
   "  x <-- inv(D) * x",
   "where the diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_dge_diag_scale in the new BLAS",
   "standard."],
 "zhecon"=>
  ["ZHECON estimates the reciprocal of the condition number of a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zhetrf"=>
  ["ZHETRF computes the factorization of a complex Hermitian matrix A",
   "using the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dlarz"=>
  ["DLARZ applies a real elementary reflector H to a real M-by-N",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "H is a product of k elementary reflectors as returned by DTZRZF."],
 "stbrfs"=>
  ["STBRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular band",
   "coefficient matrix.",
   "The solution matrix X must be computed by STBTRS or some other",
   "means before entering this routine.  STBRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "cla_porfsx_extended"=>
  ["CLA_PORFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by CPORFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "zlacgv"=>["ZLACGV conjugates a complex vector of length N."],
 "chetri2x"=>
  ["CHETRI2X computes the inverse of a complex Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "CHETRF."],
 "sgelqf"=>
  ["SGELQF computes an LQ factorization of a real M-by-N matrix A:",
   "A = L * Q."],
 "dporfs"=>
  ["DPORFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite,",
   "and provides error bounds and backward error estimates for the",
   "solution."],
 "chpcon"=>
  ["CHPCON estimates the reciprocal of the condition number of a complex",
   "Hermitian packed matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "drscl"=>
  ["DRSCL multiplies an n-element real vector x by the real scalar 1/a.",
   "This is done without overflow or underflow as long as",
   "the final result x/a does not overflow or underflow."],
 "csysvx"=>
  ["CSYSVX uses the diagonal pivoting factorization to compute the",
   "solution to a complex system of linear equations A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "csrscl"=>
  ["CSRSCL multiplies an n-element complex vector x by the real scalar",
   "1/a.  This is done without overflow or underflow as long as",
   "the final result x/a does not overflow or underflow."],
 "dsprfs"=>
  ["DSPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "cunml2"=>
  ["CUNML2 overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k)**H . . . H(2)**H H(1)**H",
   "as returned by CGELQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dlasd7"=>
  ["DLASD7 merges the two sets of singular values together into a single",
   "sorted set. Then it tries to deflate the size of the problem. There",
   "are two ways in which deflation can occur:  when two or more singular",
   "values are close together or if there is a tiny entry in the Z",
   "vector. For each such occurrence the order of the related",
   "secular equation problem is reduced by one.",
   "DLASD7 is called from DLASD6."],
 "sggsvd3"=>
  ["SGGSVD3 computes the generalized singular value decomposition (GSVD)",
   "of an M-by-N real matrix A and P-by-N real matrix B:",
   "      U**T*A*Q = D1*( 0 R ),    V**T*B*Q = D2*( 0 R )",
   "where U, V and Q are orthogonal matrices.",
   "Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,",
   "then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and",
   "D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\" matrices and of the",
   "following structures, respectively:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 =   L ( 0  S )",
   "            P-L ( 0  0 )",
   "                N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 )",
   "            L (  0    0   R22 )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "                  K M-K K+L-M",
   "       D1 =   K ( I  0    0   )",
   "            M-K ( 0  C    0   )",
   "                    K M-K K+L-M",
   "       D2 =   M-K ( 0  S    0  )",
   "            K+L-M ( 0  0    I  )",
   "              P-L ( 0  0    0  )",
   "                   N-K-L  K   M-K  K+L-M",
   "  ( 0 R ) =     K ( 0    R11  R12  R13  )",
   "              M-K ( 0     0   R22  R23  )",
   "            K+L-M ( 0     0    0   R33  )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "  S = diag( BETA(K+1),  ... , BETA(M) ),",
   "  C**2 + S**2 = I.",
   "  (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored",
   "  ( 0  R22 R23 )",
   "  in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The routine computes C, S, R, and optionally the orthogonal",
   "transformation matrices U, V and Q.",
   "In particular, if B is an N-by-N nonsingular matrix, then the GSVD of",
   "A and B implicitly gives the SVD of A*inv(B):",
   "                     A*inv(B) = U*(D1*inv(D2))*V**T.",
   "If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is",
   "also equal to the CS decomposition of A and B. Furthermore, the GSVD",
   "can be used to derive the solution of the eigenvalue problem:",
   "                     A**T*A x = lambda* B**T*B x.",
   "In some literature, the GSVD of A and B is presented in the form",
   "                 U**T*A*X = ( 0 D1 ),   V**T*B*X = ( 0 D2 )",
   "where U and V are orthogonal and X is nonsingular, D1 and D2 are",
   "``diagonal''.  The former GSVD form can be converted to the latter",
   "form by taking the nonsingular matrix X as",
   "                     X = Q*( I   0    )",
   "                           ( 0 inv(R) )."],
 "cstein"=>
  ["CSTEIN computes the eigenvectors of a real symmetric tridiagonal",
   "matrix T corresponding to specified eigenvalues, using inverse",
   "iteration.",
   "The maximum number of iterations allowed for each eigenvector is",
   "specified by an internal parameter MAXITS (currently set to 5).",
   "Although the eigenvectors are real, they are stored in a complex",
   "array, which may be passed to CUNMTR or CUPMTR for back",
   "transformation to the eigenvectors of a complex Hermitian matrix",
   "which was reduced to tridiagonal form."],
 "sorgr2"=>
  ["SORGR2 generates an m by n real matrix Q with orthonormal rows,",
   "which is defined as the last m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by SGERQF."],
 "zla_herpvgrw"=>
  ["ZLA_HERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "ssprfs"=>
  ["SSPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "dlaed9"=>
  ["DLAED9 finds the roots of the secular equation, as defined by the",
   "values in D, Z, and RHO, between KSTART and KSTOP.  It makes the",
   "appropriate calls to DLAED4 and then stores the new matrix of",
   "eigenvectors for use in calculating the next level of Z vectors."],
 "slaebz"=>
  ["SLAEBZ contains the iteration loops which compute and use the",
   "function N(w), which is the count of eigenvalues of a symmetric",
   "tridiagonal matrix T less than or equal to its argument  w.  It",
   "performs a choice of two types of loops:",
   "IJOB=1, followed by",
   "IJOB=2: It takes as input a list of intervals and returns a list of",
   "        sufficiently small intervals whose union contains the same",
   "        eigenvalues as the union of the original intervals.",
   "        The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.",
   "        The output interval (AB(j,1),AB(j,2)] will contain",
   "        eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.",
   "IJOB=3: It performs a binary search in each input interval",
   "        (AB(j,1),AB(j,2)] for a point  w(j)  such that",
   "        N(w(j))=NVAL(j), and uses  C(j)  as the starting point of",
   "        the search.  If such a w(j) is found, then on output",
   "        AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output",
   "        (AB(j,1),AB(j,2)] will be a small interval containing the",
   "        point where N(w) jumps through NVAL(j), unless that point",
   "        lies outside the initial interval.",
   "Note that the intervals are in all cases half-open intervals,",
   "i.e., of the form  (a,b] , which includes  b  but not  a .",
   "To avoid underflow, the matrix should be scaled so that its largest",
   "element is no greater than  overflow**(1/2) * underflow**(1/4)",
   "in absolute value.  To assure the most accurate computation",
   "of small eigenvalues, the matrix should be scaled to be",
   "not much smaller than that, either.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966",
   "Note: the arguments are, in general, *not* checked for unreasonable",
   "values."],
 "dlapll"=>
  ["Given two column vectors X and Y, let",
   "                     A = ( X Y ).",
   "The subroutine first computes the QR factorization of A = Q*R,",
   "and then computes the SVD of the 2-by-2 upper triangular matrix R.",
   "The smaller singular value of R is returned in SSMIN, which is used",
   "as the measurement of the linear dependency of the vectors X and Y."],
 "checon_3"=>
  ["CHECON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian matrix A using the factorization",
   "computed by CHETRF_RK or CHETRF_BK:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver CHETRS_3."],
 "dgehrd"=>
  ["DGEHRD reduces a real general matrix A to upper Hessenberg form H by",
   "an orthogonal similarity transformation:  Q**T * A * Q = H ."],
 "stplqt2"=>
  ["STPLQT2 computes a LQ a factorization of a real \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "dsbevd"=>
  ["DSBEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A. If eigenvectors are desired, it uses",
   "a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zlantb"=>
  ["ZLANTB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n triangular band matrix A,  with ( k + 1 ) diagonals.",
   "   ZLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cpbrfs"=>
  ["CPBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and banded, and provides error bounds and backward error estimates",
   "for the solution."],
 "chesv_aa"=>
  ["CHESV_AA computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**H,  if UPLO = 'U', or",
   "   A = L * T * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is Hermitian and tridiagonal. The factored form",
   "of A is then used to solve the system of equations A * X = B."],
 "sgtts2"=>
  ["SGTTS2 solves one of the systems of equations",
   "   A*X = B  or  A**T*X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by SGTTRF."],
 "zpbrfs"=>
  ["ZPBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and banded, and provides error bounds and backward error estimates",
   "for the solution."],
 "cpbtrs"=>
  ["CPBTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite band matrix A using the Cholesky factorization",
   "A = U**H*U or A = L*L**H computed by CPBTRF."],
 "zggsvd3"=>
  ["ZGGSVD3 computes the generalized singular value decomposition (GSVD)",
   "of an M-by-N complex matrix A and P-by-N complex matrix B:",
   "      U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )",
   "where U, V and Q are unitary matrices.",
   "Let K+L = the effective numerical rank of the",
   "matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper",
   "triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\"",
   "matrices and of the following structures, respectively:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 =   L ( 0  S )",
   "            P-L ( 0  0 )",
   "                N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 )",
   "            L (  0    0   R22 )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "                  K M-K K+L-M",
   "       D1 =   K ( I  0    0   )",
   "            M-K ( 0  C    0   )",
   "                    K M-K K+L-M",
   "       D2 =   M-K ( 0  S    0  )",
   "            K+L-M ( 0  0    I  )",
   "              P-L ( 0  0    0  )",
   "                   N-K-L  K   M-K  K+L-M",
   "  ( 0 R ) =     K ( 0    R11  R12  R13  )",
   "              M-K ( 0     0   R22  R23  )",
   "            K+L-M ( 0     0    0   R33  )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "  S = diag( BETA(K+1),  ... , BETA(M) ),",
   "  C**2 + S**2 = I.",
   "  (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored",
   "  ( 0  R22 R23 )",
   "  in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The routine computes C, S, R, and optionally the unitary",
   "transformation matrices U, V and Q.",
   "In particular, if B is an N-by-N nonsingular matrix, then the GSVD of",
   "A and B implicitly gives the SVD of A*inv(B):",
   "                     A*inv(B) = U*(D1*inv(D2))*V**H.",
   "If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also",
   "equal to the CS decomposition of A and B. Furthermore, the GSVD can",
   "be used to derive the solution of the eigenvalue problem:",
   "                     A**H*A x = lambda* B**H*B x.",
   "In some literature, the GSVD of A and B is presented in the form",
   "                 U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )",
   "where U and V are orthogonal and X is nonsingular, and D1 and D2 are",
   "``diagonal''.  The former GSVD form can be converted to the latter",
   "form by taking the nonsingular matrix X as",
   "                      X = Q*(  I   0    )",
   "                            (  0 inv(R) )"],
 "cgeequb"=>
  ["CGEEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from CGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "dormtr"=>
  ["DORMTR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by DSYTRD:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "dlagtm"=>
  ["DLAGTM performs a matrix-vector product of the form",
   "   B := alpha * A * X + beta * B",
   "where A is a tridiagonal matrix of order N, B and X are N by NRHS",
   "matrices, and alpha and beta are real scalars, each of which may be",
   "0., 1., or -1."],
 "cgerq2"=>
  ["CGERQ2 computes an RQ factorization of a complex m by n matrix A:",
   "A = R * Q."],
 "dsbgvx"=>
  ["DSBGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric",
   "and banded, and B is also positive definite.  Eigenvalues and",
   "eigenvectors can be selected by specifying either all eigenvalues,",
   "a range of values or a range of indices for the desired eigenvalues."],
 "dpbtrf"=>
  ["DPBTRF computes the Cholesky factorization of a real symmetric",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "dsytrf_aa"=>
  ["DSYTRF_AA computes the factorization of a real symmetric matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**T  or  A = L*T*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a symmetric tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "chesv_rook"=>
  ["CHESV_ROOK computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "The bounded Bunch-Kaufman (\"rook\") diagonal pivoting method is used",
   "to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "CHETRF_ROOK is called to compute the factorization of a complex",
   "Hermition matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2)."],
 "ctgsyl"=>
  ["CTGSYL solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C            (1)",
   "            D * R - L * E = scale * F",
   "where R and L are unknown m-by-n matrices, (A, D), (B, E) and",
   "(C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,",
   "respectively, with complex entries. A, B, D and E are upper",
   "triangular (i.e., (A,D) and (B,E) in generalized Schur form).",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1",
   "is an output scaling factor chosen to avoid overflow.",
   "In matrix notation (1) is equivalent to solve Zx = scale*b, where Z",
   "is defined as",
   "       Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)",
   "           [ kron(In, D)  -kron(E**H, Im) ],",
   "Here Ix is the identity matrix of size x and X**H is the conjugate",
   "transpose of X. Kron(X, Y) is the Kronecker product between the",
   "matrices X and Y.",
   "If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b",
   "is solved for, which is equivalent to solve for R and L in",
   "            A**H * R + D**H * L = scale * C           (3)",
   "            R * B**H + L * E**H = scale * -F",
   "This case (TRANS = 'C') is used to compute an one-norm-based estimate",
   "of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)",
   "and (B,E), using CLACON.",
   "If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of",
   "Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the",
   "reciprocal of the smallest singular value of Z.",
   "This is a level-3 BLAS algorithm."],
 "ztgex2"=>
  ["ZTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)",
   "in an upper triangular matrix pair (A, B) by an unitary equivalence",
   "transformation.",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H",
   "       Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H"],
 "clangb"=>
  ["CLANGB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.",
   "   CLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "ctgsna"=>
  ["CTGSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or eigenvectors of a matrix pair (A, B).",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular."],
 "zla_hercond_c"=>
  ["   ZLA_HERCOND_C computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector."],
 "zlaqge"=>
  ["ZLAQGE equilibrates a general M by N matrix A using the row and",
   "column scaling factors in the vectors R and C."],
 "slarzt"=>
  ["SLARZT forms the triangular factor T of a real block reflector",
   "H of order > n, which is defined as a product of k elementary",
   "reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**T",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**T * T * V",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "dlarft"=>
  ["DLARFT forms the triangular factor T of a real block reflector H",
   "of order n, which is defined as a product of k elementary reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**T",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**T * T * V"],
 "sgelq"=>["SGELQ computes a LQ factorization of an M-by-N matrix A."],
 "zhegst"=>
  ["ZHEGST reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.",
   "B must have been previously factorized as U**H*U or L*L**H by ZPOTRF."],
 "sla_gbrpvgrw"=>
  ["SLA_GBRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "chetri_rook"=>
  ["CHETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "CHETRF_ROOK."],
 "ztrttp"=>
  ["ZTRTTP copies a triangular matrix A from full format (TR) to standard",
   "packed format (TP)."],
 "sgesvx"=>
  ["SGESVX uses the LU factorization to compute the solution to a real",
   "system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dtbtrs"=>
  ["DTBTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular band matrix of order N, and B is an",
   "N-by NRHS matrix.  A check is made to verify that A is nonsingular."],
 "zlaic1"=>
  ["ZLAIC1 applies one step of incremental condition estimation in",
   "its simplest version:",
   "Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j",
   "lower triangular matrix L, such that",
   "         twonorm(L*x) = sest",
   "Then ZLAIC1 computes sestpr, s, c such that",
   "the vector",
   "                [ s*x ]",
   "         xhat = [  c  ]",
   "is an approximate singular vector of",
   "                [ L       0  ]",
   "         Lhat = [ w**H gamma ]",
   "in the sense that",
   "         twonorm(Lhat*xhat) = sestpr.",
   "Depending on JOB, an estimate for the largest or smallest singular",
   "value is computed.",
   "Note that [s c]**H and sestpr**2 is an eigenpair of the system",
   "    diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]",
   "                                          [ conjg(gamma) ]",
   "where  alpha =  x**H * w."],
 "strttf"=>
  ["STRTTF copies a triangular matrix A from standard full format (TR)",
   "to rectangular full packed format (TF) ."],
 "zupmtr"=>
  ["ZUPMTR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by ZHPTRD using packed",
   "storage:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "zhpev"=>
  ["ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix in packed storage."],
 "dlarrf"=>
  ["Given the initial representation L D L^T and its cluster of close",
   "eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...",
   "W( CLEND ), DLARRF finds a new relatively robust representation",
   "L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the",
   "eigenvalues of L(+) D(+) L(+)^T is relatively isolated."],
 "ctgsen"=>
  ["CTGSEN reorders the generalized Schur decomposition of a complex",
   "matrix pair (A, B) (in terms of an unitary equivalence trans-",
   "formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues",
   "appears in the leading diagonal blocks of the pair (A,B). The leading",
   "columns of Q and Z form unitary bases of the corresponding left and",
   "right eigenspaces (deflating subspaces). (A, B) must be in",
   "generalized Schur canonical form, that is, A and B are both upper",
   "triangular.",
   "CTGSEN also computes the generalized eigenvalues",
   "         w(j)= ALPHA(j) / BETA(j)",
   "of the reordered matrix pair (A, B).",
   "Optionally, the routine computes estimates of reciprocal condition",
   "numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),",
   "(A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)",
   "between the matrix pairs (A11, B11) and (A22,B22) that correspond to",
   "the selected cluster and the eigenvalues outside the cluster, resp.,",
   "and norms of \"projections\" onto left and right eigenspaces w.r.t.",
   "the selected cluster in the (1,1)-block."],
 "zgerq2"=>
  ["ZGERQ2 computes an RQ factorization of a complex m by n matrix A:",
   "A = R * Q."],
 "ssfrk"=>
  ["Level 3 BLAS like routine for C in RFP Format.",
   "SSFRK performs one of the symmetric rank--k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where alpha and beta are real scalars, C is an n--by--n symmetric",
   "matrix and A is an n--by--k matrix in the first case and a k--by--n",
   "matrix in the second case."],
 "zpprfs"=>
  ["ZPPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "sspgst"=>
  ["SSPGST reduces a real symmetric-definite generalized eigenproblem",
   "to standard form, using packed storage.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.",
   "B must have been previously factorized as U**T*U or L*L**T by SPPTRF."],
 "cggev"=>
  ["CGGEV computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right generalized eigenvector v(j) corresponding to the",
   "generalized eigenvalue lambda(j) of (A,B) satisfies",
   "             A * v(j) = lambda(j) * B * v(j).",
   "The left generalized eigenvector u(j) corresponding to the",
   "generalized eigenvalues lambda(j) of (A,B) satisfies",
   "             u(j)**H * A = lambda(j) * u(j)**H * B",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "ilaclc"=>["ILACLC scans A for its last non-zero column."],
 "sgtsv"=>
  ["SGTSV  solves the equation",
   "   A*X = B,",
   "where A is an n by n tridiagonal matrix, by Gaussian elimination with",
   "partial pivoting.",
   "Note that the equation  A**T*X = B  may be solved by interchanging the",
   "order of the arguments DU and DL."],
 "sgesvdx"=>
  [" SGESVDX computes the singular value decomposition (SVD) of a real",
   " M-by-N matrix A, optionally computing the left and/or right singular",
   " vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   " where SIGMA is an M-by-N matrix which is zero except for its",
   " min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   " V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   " are the singular values of A; they are real and non-negative, and",
   " are returned in descending order.  The first min(m,n) columns of",
   " U and V are the left and right singular vectors of A.",
   " SGESVDX uses an eigenvalue problem for obtaining the SVD, which",
   " allows for the computation of a subset of singular values and",
   " vectors. See SBDSVDX for details.",
   " Note that the routine returns V**T, not V."],
 "sla_gbrcond"=>
  ["   SLA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "sgeqr2p"=>
  ["SGEQR2P computes a QR factorization of a real m by n matrix A:",
   "A = Q * R. The diagonal entries of R are nonnegative."],
 "dsyevr"=>
  ["DSYEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "DSYEVR first reduces the matrix A to tridiagonal form T with a call",
   "to DSYTRD.  Then, whenever possible, DSYEVR calls DSTEMR to compute",
   "the eigenspectrum using Relatively Robust Representations.  DSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of DSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "ssyconv"=>
  ["SSYCONV convert A given by TRF into L and D and vice-versa.",
   "Get Non-diag elements of D (returned in workspace) and",
   "apply or reverse permutation done in TRF."],
 "dgeql2"=>
  ["DGEQL2 computes a QL factorization of a real m by n matrix A:",
   "A = Q * L."],
 "ctplqt2"=>
  ["CTPLQT2 computes a LQ a factorization of a complex \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "dgghd3"=>
  ["DGGHD3 reduces a pair of real matrices (A,B) to generalized upper",
   "Hessenberg form using orthogonal transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the orthogonal matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**T*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**T*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**T*x.",
   "The orthogonal matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T",
   "     Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T",
   "If Q1 is the orthogonal matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then DGGHD3 reduces the original",
   "problem to generalized Hessenberg form.",
   "This is a blocked variant of DGGHRD, using matrix-matrix",
   "multiplications for parts of the computation to enhance performance."],
 "slaed7"=>
  ["SLAED7 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix. This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and optionally eigenvectors of a dense symmetric matrix",
   "that has been reduced to tridiagonal form.  SLAED1 handles",
   "the case in which all eigenvalues and eigenvectors of a symmetric",
   "tridiagonal matrix are desired.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)",
   "   where Z = Q**Tu, u is a vector of length N with ones in the",
   "   CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine SLAED8.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine SLAED4 (as called by SLAED9).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "dsytrf_rk"=>
  ["DSYTRF_RK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "zsytrs2"=>
  ["ZSYTRS2 solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV."],
 "cggbal"=>
  ["CGGBAL balances a pair of general complex matrices (A,B).  This",
   "involves, first, permuting A and B by similarity transformations to",
   "isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N",
   "elements on the diagonal; and second, applying a diagonal similarity",
   "transformation to rows and columns ILO to IHI to make the rows",
   "and columns as close in norm as possible. Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrices, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors in the",
   "generalized eigenvalue problem A*x = lambda*B*x."],
 "dpocon"=>
  ["DPOCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite matrix using the",
   "Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "clascl"=>
  ["CLASCL multiplies the M by N complex matrix A by the real scalar",
   "CTO/CFROM.  This is done without over/underflow as long as the final",
   "result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that",
   "A may be full, upper triangular, lower triangular, upper Hessenberg,",
   "or banded."],
 "chetf2_rook"=>
  ["CHETF2_ROOK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**H is the conjugate transpose of U, and D is",
   "Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "csteqr"=>
  ["CSTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the implicit QL or QR method.",
   "The eigenvectors of a full or band complex Hermitian matrix can also",
   "be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this",
   "matrix to tridiagonal form."],
 "zlangt"=>
  ["ZLANGT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex tridiagonal matrix A.",
   "   ZLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "slansp"=>
  ["SLANSP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric matrix A,  supplied in packed form.",
   "   SLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zhpgvx"=>
  ["ZHPGVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian, stored in packed format, and B is also",
   "positive definite.  Eigenvalues and eigenvectors can be selected by",
   "specifying either a range of values or a range of indices for the",
   "desired eigenvalues."],
 "dpoequb"=>
  ["DPOEQUB computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings.",
   "This routine differs from DPOEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled diagonal entries are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "ssytrs_aa"=>
  ["SSYTRS_AA solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*T*U**T or",
   "A = L*T*L**T computed by SSYTRF_AA."],
 "clartg"=>
  ["CLARTG generates a plane rotation so that",
   "   [  CS  SN  ]     [ F ]     [ R ]",
   "   [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a faster version of the BLAS1 routine CROTG, except for",
   "the following differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=1 and SN=0.",
   "   If F=0, then CS=0 and SN is chosen so that R is real."],
 "dorm2l"=>
  ["DORM2L overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T * C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "zhbev_2stage"=>
  ["ZHBEV_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "dlaswlq"=>
  ["         DLASWLQ computes a blocked Short-Wide LQ factorization of a",
   "         M-by-N matrix A, where N >= M:",
   "         A = L * Q"],
 "zla_herfsx_extended"=>
  ["ZLA_HERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by ZHERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "dlaqsp"=>
  ["DLAQSP equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "cgeqr2"=>
  ["CGEQR2 computes a QR factorization of a complex m by n matrix A:",
   "A = Q * R."],
 "ztrevc"=>
  ["ZTREVC computes some or all of the right and/or left eigenvectors of",
   "a complex upper triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "             T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of the vector y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix.  If Q is the unitary factor that reduces a matrix A to",
   "Schur form T, then Q*X and Q*Y are the matrices of right and left",
   "eigenvectors of A."],
 "dtptri"=>
  ["DTPTRI computes the inverse of a real upper or lower triangular",
   "matrix A stored in packed format."],
 "cgemlq"=>
  ["    CGEMLQ overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "     TRANS = 'N':      Q * C          C * Q",
   "     TRANS = 'C':      Q**H * C       C * Q**H",
   "     where Q is a complex unitary matrix defined as the product",
   "     of blocked elementary reflectors computed by short wide",
   "     LQ factorization (CGELQ)"],
 "ctbrfs"=>
  ["CTBRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular band",
   "coefficient matrix.",
   "The solution matrix X must be computed by CTBTRS or some other",
   "means before entering this routine.  CTBRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "zpotf2"=>
  ["ZPOTF2 computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U ,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "dlasd8"=>
  ["DLASD8 finds the square roots of the roots of the secular equation,",
   "as defined by the values in DSIGMA and Z. It makes the appropriate",
   "calls to DLASD4, and stores, for each  element in D, the distance",
   "to its two nearest poles (elements in DSIGMA). It also updates",
   "the arrays VF and VL, the first and last components of all the",
   "right singular vectors of the original bidiagonal matrix.",
   "DLASD8 is called from DLASD6."],
 "zhegvx"=>
  ["ZHEGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian and B is also positive definite.",
   "Eigenvalues and eigenvectors can be selected by specifying either a",
   "range of values or a range of indices for the desired eigenvalues."],
 "zlalsd"=>
  ["ZLALSD uses the singular value decomposition of A to solve the least",
   "squares problem of finding X to minimize the Euclidean norm of each",
   "column of A*X-B, where A is N-by-N upper bidiagonal, and X and B",
   "are N-by-NRHS. The solution X overwrites B.",
   "The singular values of A smaller than RCOND times the largest",
   "singular value are treated as zero in solving the least squares",
   "problem; in this case a minimum norm solution is returned.",
   "The actual singular values are returned in D in ascending order.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zhbev"=>
  ["ZHBEV computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A."],
 "dgerfs"=>
  ["DGERFS improves the computed solution to a system of linear",
   "equations and provides error bounds and backward error estimates for",
   "the solution."],
 "zlag2c"=>
  ["ZLAG2C converts a COMPLEX*16 matrix, SA, to a COMPLEX matrix, A.",
   "RMAX is the overflow for the SINGLE PRECISION arithmetic",
   "ZLAG2C checks that all the entries of A are between -RMAX and",
   "RMAX. If not the conversion is aborted and a flag is raised.",
   "This is an auxiliary routine so there is no argument checking."],
 "ctfttr"=>
  ["CTFTTR copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard full format (TR)."],
 "dormr2"=>
  ["DORMR2 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "cgtsvx"=>
  ["CGTSVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a tridiagonal matrix of order N and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dlaeda"=>
  ["DLAEDA computes the Z vector corresponding to the merge step in the",
   "CURLVLth step of the merge process with TLVLS steps for the CURPBMth",
   "problem."],
 "claic1"=>
  ["CLAIC1 applies one step of incremental condition estimation in",
   "its simplest version:",
   "Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j",
   "lower triangular matrix L, such that",
   "         twonorm(L*x) = sest",
   "Then CLAIC1 computes sestpr, s, c such that",
   "the vector",
   "                [ s*x ]",
   "         xhat = [  c  ]",
   "is an approximate singular vector of",
   "                [ L      0  ]",
   "         Lhat = [ w**H gamma ]",
   "in the sense that",
   "         twonorm(Lhat*xhat) = sestpr.",
   "Depending on JOB, an estimate for the largest or smallest singular",
   "value is computed.",
   "Note that [s c]**H and sestpr**2 is an eigenpair of the system",
   "    diag(sest*sest, 0) + [alpha  gamma] * [ conjg(alpha) ]",
   "                                          [ conjg(gamma) ]",
   "where  alpha =  x**H*w."],
 "zlar1v"=>
  ["ZLAR1V computes the (scaled) r-th column of the inverse of",
   "the sumbmatrix in rows B1 through BN of the tridiagonal matrix",
   "L D L**T - sigma I. When sigma is close to an eigenvalue, the",
   "computed vector is an accurate eigenvector. Usually, r corresponds",
   "to the index where the eigenvector is largest in magnitude.",
   "The following steps accomplish this computation :",
   "(a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,",
   "(b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,",
   "(c) Computation of the diagonal elements of the inverse of",
   "    L D L**T - sigma I by combining the above transforms, and choosing",
   "    r as the index where the diagonal of the inverse is (one of the)",
   "    largest in magnitude.",
   "(d) Computation of the (scaled) r-th column of the inverse using the",
   "    twisted factorization obtained by combining the top part of the",
   "    the stationary and the bottom part of the progressive transform."],
 "ssyswapr"=>
  ["SSYSWAPR applies an elementary permutation on the rows and the columns of",
   "a symmetric matrix."],
 "dtplqt2"=>
  ["DTPLQT2 computes a LQ a factorization of a real \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "cheswapr"=>
  ["CHESWAPR applies an elementary permutation on the rows and the columns of",
   "a hermitian matrix."],
 "cgesv"=>
  ["CGESV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as",
   "   A = P * L * U,",
   "where P is a permutation matrix, L is unit lower triangular, and U is",
   "upper triangular.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "dlasd1"=>
  ["DLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,",
   "where N = NL + NR + 1 and M = N + SQRE. DLASD1 is called from DLASD0.",
   "A related subroutine DLASD7 handles the case in which the singular",
   "values (and the singular vectors in factored form) are desired.",
   "DLASD1 computes the SVD as follows:",
   "              ( D1(in)    0    0       0 )",
   "  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)",
   "              (   0       0   D2(in)   0 )",
   "    = U(out) * ( D(out) 0) * VT(out)",
   "where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M",
   "with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros",
   "elsewhere; and the entry b is empty if SQRE = 0.",
   "The left singular vectors of the original matrix are stored in U, and",
   "the transpose of the right singular vectors are stored in VT, and the",
   "singular values are in D.  The algorithm consists of three stages:",
   "   The first stage consists of deflating the size of the problem",
   "   when there are multiple singular values or when there are zeros in",
   "   the Z vector.  For each such occurrence the dimension of the",
   "   secular equation problem is reduced by one.  This stage is",
   "   performed by the routine DLASD2.",
   "   The second stage consists of calculating the updated",
   "   singular values. This is done by finding the square roots of the",
   "   roots of the secular equation via the routine DLASD4 (as called",
   "   by DLASD3). This routine also calculates the singular vectors of",
   "   the current problem.",
   "   The final stage consists of computing the updated singular vectors",
   "   directly using the updated singular values.  The singular vectors",
   "   for the current problem are multiplied with the singular vectors",
   "   from the overall problem."],
 "dla_syrpvgrw"=>
  ["DLA_SYRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "cgesc2"=>
  ["CGESC2 solves a system of linear equations",
   "          A * X = scale* RHS",
   "with a general N-by-N matrix A using the LU factorization with",
   "complete pivoting computed by CGETC2."],
 "chseqr"=>
  ["   CHSEQR computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H."],
 "sgbbrd"=>
  ["SGBBRD reduces a real general m-by-n band matrix A to upper",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "The routine computes B, and optionally forms Q or P**T, or computes",
   "Q**T*C for a given matrix C."],
 "ctrexc"=>
  ["CTREXC reorders the Schur factorization of a complex matrix",
   "A = Q*T*Q**H, so that the diagonal element of T with row index IFST",
   "is moved to row ILST.",
   "The Schur form T is reordered by a unitary similarity transformation",
   "Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by",
   "postmultplying it with Z."],
 "zhetrs"=>
  ["ZHETRS solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHETRF."],
 "slasyf_rook"=>
  ["SLASYF_ROOK computes a partial factorization of a real symmetric",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "SLASYF_ROOK is an auxiliary routine called by SSYTRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "sgeqrfp"=>
  ["SGEQRFP computes a QR factorization of a real M-by-N matrix A:",
   "A = Q * R. The diagonal entries of R are nonnegative."],
 "chpevd"=>
  ["CHPEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian matrix A in packed storage.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dtpttf"=>
  ["DTPTTF copies a triangular matrix A from standard packed format (TP)",
   "to rectangular full packed format (TF)."],
 "zgglse"=>
  ["ZGGLSE solves the linear equality-constrained least squares (LSE)",
   "problem:",
   "        minimize || c - A*x ||_2   subject to   B*x = d",
   "where A is an M-by-N matrix, B is a P-by-N matrix, c is a given",
   "M-vector, and d is a given P-vector. It is assumed that",
   "P <= N <= M+P, and",
   "         rank(B) = P and  rank( (A) ) = N.",
   "                              ( (B) )",
   "These conditions ensure that the LSE problem has a unique solution,",
   "which is obtained using a generalized RQ factorization of the",
   "matrices (B, A) given by",
   "   B = (0 R)*Q,   A = Z*T*Q."],
 "sggbak"=>
  ["SGGBAK forms the right or left eigenvectors of a real generalized",
   "eigenvalue problem A*x = lambda*B*x, by backward transformation on",
   "the computed eigenvectors of the balanced pair of matrices output by",
   "SGGBAL."],
 "zptsvx"=>
  ["ZPTSVX uses the factorization A = L*D*L**H to compute the solution",
   "to a complex system of linear equations A*X = B, where A is an",
   "N-by-N Hermitian positive definite tridiagonal matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "sgbtrf"=>
  ["SGBTRF computes an LU factorization of a real m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "zgttrs"=>
  ["ZGTTRS solves one of the systems of equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by ZGTTRF."],
 "dorgqr"=>
  ["DORGQR generates an M-by-N real matrix Q with orthonormal columns,",
   "which is defined as the first N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by DGEQRF."],
 "dsytrd"=>
  ["DSYTRD reduces a real symmetric matrix A to real symmetric",
   "tridiagonal form T by an orthogonal similarity transformation:",
   "Q**T * A * Q = T."],
 "cunbdb4"=>[],
 "zung2l"=>
  ["ZUNG2L generates an m by n complex matrix Q with orthonormal columns,",
   "which is defined as the last n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by ZGEQLF."],
 "zpotrf"=>
  ["ZPOTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "dlauum"=>
  ["DLAUUM computes the product U * U**T or L**T * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the blocked form of the algorithm, calling Level 3 BLAS."],
 "ctrsna"=>
  ["CTRSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or right eigenvectors of a complex upper triangular",
   "matrix T (or of any matrix Q*T*Q**H with Q unitary)."],
 "cgelsy"=>
  ["CGELSY computes the minimum-norm solution to a complex linear least",
   "squares problem:",
   "    minimize || A * X - B ||",
   "using a complete orthogonal factorization of A.  A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The routine first computes a QR factorization with column pivoting:",
   "    A * P = Q * [ R11 R12 ]",
   "                [  0  R22 ]",
   "with R11 defined as the largest leading submatrix whose estimated",
   "condition number is less than 1/RCOND.  The order of R11, RANK,",
   "is the effective rank of A.",
   "Then, R22 is considered to be negligible, and R12 is annihilated",
   "by unitary transformations from the right, arriving at the",
   "complete orthogonal factorization:",
   "   A * P = Q * [ T11 0 ] * Z",
   "               [  0  0 ]",
   "The minimum-norm solution is then",
   "   X = P * Z**H [ inv(T11)*Q1**H*B ]",
   "                [        0         ]",
   "where Q1 consists of the first RANK columns of Q.",
   "This routine is basically identical to the original xGELSX except",
   "three differences:",
   "  o The permutation of matrix B (the right hand side) is faster and",
   "    more simple.",
   "  o The call to the subroutine xGEQPF has been substituted by the",
   "    the call to the subroutine xGEQP3. This subroutine is a Blas-3",
   "    version of the QR factorization with column pivoting.",
   "  o Matrix B (the right hand side) is updated with Blas-3."],
 "chetf2"=>
  ["CHETF2 computes the factorization of a complex Hermitian matrix A",
   "using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**H is the conjugate transpose of U, and D is",
   "Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "stptri"=>
  ["STPTRI computes the inverse of a real upper or lower triangular",
   "matrix A stored in packed format."],
 "zgeqrt3"=>
  ["ZGEQRT3 recursively computes a QR factorization of a complex M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "zgesvdx"=>
  [" ZGESVDX computes the singular value decomposition (SVD) of a complex",
   " M-by-N matrix A, optionally computing the left and/or right singular",
   " vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   " where SIGMA is an M-by-N matrix which is zero except for its",
   " min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   " V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   " are the singular values of A; they are real and non-negative, and",
   " are returned in descending order.  The first min(m,n) columns of",
   " U and V are the left and right singular vectors of A.",
   " ZGESVDX uses an eigenvalue problem for obtaining the SVD, which",
   " allows for the computation of a subset of singular values and",
   " vectors. See DBDSVDX for details.",
   " Note that the routine returns V**T, not V."],
 "dgbcon"=>
  ["DGBCON estimates the reciprocal of the condition number of a real",
   "general band matrix A, in either the 1-norm or the infinity-norm,",
   "using the LU factorization computed by DGBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "zhpevx"=>
  ["ZHPEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A in packed storage.",
   "Eigenvalues/vectors can be selected by specifying either a range of",
   "values or a range of indices for the desired eigenvalues."],
 "slasyf"=>
  ["SLASYF computes a partial factorization of a real symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method. The partial",
   "factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "dtrrfs"=>
  ["DTRRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular",
   "coefficient matrix.",
   "The solution matrix X must be computed by DTRTRS or some other",
   "means before entering this routine.  DTRRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "ctrtri"=>
  ["CTRTRI computes the inverse of a complex upper or lower triangular",
   "matrix A.",
   "This is the Level 3 BLAS version of the algorithm."],
 "zlarzt"=>
  ["ZLARZT forms the triangular factor T of a complex block reflector",
   "H of order > n, which is defined as a product of k elementary",
   "reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**H",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**H * T * V",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "csytri2"=>
  ["CSYTRI2 computes the inverse of a COMPLEX symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "CSYTRF. CSYTRI2 sets the LEADING DIMENSION of the workspace",
   "before calling CSYTRI2X that actually computes the inverse."],
 "zgbbrd"=>
  ["ZGBBRD reduces a complex general m-by-n band matrix A to real upper",
   "bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "The routine computes B, and optionally forms Q or P**H, or computes",
   "Q**H*C for a given matrix C."],
 "zhbevx_2stage"=>
  ["ZHBEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "slasd1"=>
  ["SLASD1 computes the SVD of an upper bidiagonal N-by-M matrix B,",
   "where N = NL + NR + 1 and M = N + SQRE. SLASD1 is called from SLASD0.",
   "A related subroutine SLASD7 handles the case in which the singular",
   "values (and the singular vectors in factored form) are desired.",
   "SLASD1 computes the SVD as follows:",
   "              ( D1(in)    0    0       0 )",
   "  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)",
   "              (   0       0   D2(in)   0 )",
   "    = U(out) * ( D(out) 0) * VT(out)",
   "where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M",
   "with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros",
   "elsewhere; and the entry b is empty if SQRE = 0.",
   "The left singular vectors of the original matrix are stored in U, and",
   "the transpose of the right singular vectors are stored in VT, and the",
   "singular values are in D.  The algorithm consists of three stages:",
   "   The first stage consists of deflating the size of the problem",
   "   when there are multiple singular values or when there are zeros in",
   "   the Z vector.  For each such occurrence the dimension of the",
   "   secular equation problem is reduced by one.  This stage is",
   "   performed by the routine SLASD2.",
   "   The second stage consists of calculating the updated",
   "   singular values. This is done by finding the square roots of the",
   "   roots of the secular equation via the routine SLASD4 (as called",
   "   by SLASD3). This routine also calculates the singular vectors of",
   "   the current problem.",
   "   The final stage consists of computing the updated singular vectors",
   "   directly using the updated singular values.  The singular vectors",
   "   for the current problem are multiplied with the singular vectors",
   "   from the overall problem."],
 "ssyrfsx"=>
  ["   SSYRFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "zpteqr"=>
  ["ZPTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric positive definite tridiagonal matrix by first factoring the",
   "matrix using DPTTRF and then calling ZBDSQR to compute the singular",
   "values of the bidiagonal factor.",
   "This routine computes the eigenvalues of the positive definite",
   "tridiagonal matrix to high relative accuracy.  This means that if the",
   "eigenvalues range over many orders of magnitude in size, then the",
   "small eigenvalues and corresponding eigenvectors will be computed",
   "more accurately than, for example, with the standard QR method.",
   "The eigenvectors of a full or band positive definite Hermitian matrix",
   "can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to",
   "reduce this matrix to tridiagonal form.  (The reduction to",
   "tridiagonal form, however, may preclude the possibility of obtaining",
   "high relative accuracy in the small eigenvalues of the original",
   "matrix, if these eigenvalues range over many orders of magnitude.)"],
 "clatrs"=>
  ["CLATRS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow.  Here A is an upper or lower",
   "triangular matrix, A**T denotes the transpose of A, A**H denotes the",
   "conjugate transpose of A, x and b are n-element vectors, and s is a",
   "scaling factor, usually less than or equal to 1, chosen so that the",
   "components of x will be less than the overflow threshold.  If the",
   "unscaled problem will not cause overflow, the Level 2 BLAS routine",
   "CTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),",
   "then s is set to 0 and a non-trivial solution to A*x = 0 is returned."],
 "dla_porcond"=>
  ["   DLA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "sla_gercond"=>
  ["   SLA_GERCOND estimates the Skeel condition number of op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "claqr1"=>
  ["     Given a 2-by-2 or 3-by-3 matrix H, CLAQR1 sets v to a",
   "     scalar multiple of the first column of the product",
   "     (*)  K = (H - s1*I)*(H - s2*I)",
   "     scaling to avoid overflows and most underflows.",
   "     This is useful for starting double implicit shift bulges",
   "     in the QR algorithm."],
 "ctgex2"=>
  ["CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)",
   "in an upper triangular matrix pair (A, B) by an unitary equivalence",
   "transformation.",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H",
   "       Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H"],
 "zuncsd"=>
  ["ZUNCSD computes the CS decomposition of an M-by-M partitioned",
   "unitary matrix X:",
   "                                [  I  0  0 |  0  0  0 ]",
   "                                [  0  C  0 |  0 -S  0 ]",
   "    [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**H",
   "X = [-----------] = [---------] [---------------------] [---------]   .",
   "    [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]",
   "                                [  0  S  0 |  0  C  0 ]",
   "                                [  0  0  I |  0  0  0 ]",
   "X11 is P-by-Q. The unitary matrices U1, U2, V1, and V2 are P-by-P,",
   "(M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are",
   "R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in",
   "which R = MIN(P,M-P,Q,M-Q)."],
 "zherfsx"=>
  ["   ZHERFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is Hermitian indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "ctgevc"=>
  ["CTGEVC computes some or all of the right and/or left eigenvectors of",
   "a pair of complex matrices (S,P), where S and P are upper triangular.",
   "Matrix pairs of this type are produced by the generalized Schur",
   "factorization of a complex matrix pair (A,B):",
   "   A = Q*S*Z**H,  B = Q*P*Z**H",
   "as computed by CGGHRD + CHGEQZ.",
   "The right eigenvector x and the left eigenvector y of (S,P)",
   "corresponding to an eigenvalue w are defined by:",
   "   S*x = w*P*x,  (y**H)*S = w*(y**H)*P,",
   "where y**H denotes the conjugate tranpose of y.",
   "The eigenvalues are not input to this routine, but are computed",
   "directly from the diagonal elements of S and P.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of (S,P), or the products Z*X and/or Q*Y,",
   "where Z and Q are input matrices.",
   "If Q and Z are the unitary factors from the generalized Schur",
   "factorization of a matrix pair (A,B), then Z*X and Q*Y",
   "are the matrices of right and left eigenvectors of (A,B)."],
 "chetrf_rk"=>
  ["CHETRF_RK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "cupmtr"=>
  ["CUPMTR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by CHPTRD using packed",
   "storage:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "zhpevd"=>
  ["ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian matrix A in packed storage.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zgesvd"=>
  ["ZGESVD computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors. The SVD is written",
   "     A = U * SIGMA * conjugate-transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   "V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns V**H, not V."],
 "dsyconvf_rook"=>
  ["If parameter WAY = 'C':",
   "DSYCONVF_ROOK converts the factorization output format used in",
   "DSYTRF_ROOK provided on entry in parameter A into the factorization",
   "output format used in DSYTRF_RK (or DSYTRF_BK) that is stored",
   "on exit in parameters A and E. IPIV format for DSYTRF_ROOK and",
   "DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.",
   "If parameter WAY = 'R':",
   "DSYCONVF_ROOK performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in DSYTRF_RK",
   "(or DSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in DSYTRF_ROOK that is stored",
   "on exit in parameter A. IPIV format for DSYTRF_ROOK and",
   "DSYTRF_RK (or DSYTRF_BK) is the same and is not converted."],
 "sspsv"=>
  ["SSPSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is symmetric and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "spotrf"=>
  ["SPOTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "dlaqr5"=>
  ["   DLAQR5, called by DLAQR0, performs a",
   "   single small-bulge multi-shift QR sweep."],
 "zpbequ"=>
  ["ZPBEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite band matrix A and reduce its condition",
   "number (with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "zlaqgb"=>
  ["ZLAQGB equilibrates a general M by N band matrix A with KL",
   "subdiagonals and KU superdiagonals using the row and scaling factors",
   "in the vectors R and C."],
 "sbdsvdx"=>
  [" SBDSVDX computes the singular value decomposition (SVD) of a real",
   " N-by-N (upper or lower) bidiagonal matrix B, B = U * S * VT,",
   " where S is a diagonal matrix with non-negative diagonal elements",
   " (the singular values of B), and U and VT are orthogonal matrices",
   " of left and right singular vectors, respectively.",
   " Given an upper bidiagonal B with diagonal D = [ d_1 d_2 ... d_N ]",
   " and superdiagonal E = [ e_1 e_2 ... e_N-1 ], SBDSVDX computes the",
   " singular value decompositon of B through the eigenvalues and",
   " eigenvectors of the N*2-by-N*2 tridiagonal matrix",
   "       |  0  d_1                |",
   "       | d_1  0  e_1            |",
   " TGK = |     e_1  0  d_2        |",
   "       |         d_2  .   .     |",
   "       |              .   .   . |",
   " If (s,u,v) is a singular triplet of B with ||u|| = ||v|| = 1, then",
   " (+/-s,q), ||q|| = 1, are eigenpairs of TGK, with q = P * ( u' +/-v' ) /",
   " sqrt(2) = ( v_1 u_1 v_2 u_2 ... v_n u_n ) / sqrt(2), and",
   " P = [ e_{n+1} e_{1} e_{n+2} e_{2} ... ].",
   " Given a TGK matrix, one can either a) compute -s,-v and change signs",
   " so that the singular values (and corresponding vectors) are already in",
   " descending order (as in SGESVD/SGESDD) or b) compute s,v and reorder",
   " the values (and corresponding vectors). SBDSVDX implements a) by",
   " calling SSTEVX (bisection plus inverse iteration, to be replaced",
   " with a version of the Multiple Relative Robust Representation",
   " algorithm. (See P. Willems and B. Lang, A framework for the MR^3",
   " algorithm: theory and implementation, SIAM J. Sci. Comput.,",
   " 35:740-766, 2013.)"],
 "strtrs"=>
  ["STRTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular matrix of order N, and B is an N-by-NRHS",
   "matrix.  A check is made to verify that A is nonsingular."],
 "dla_lin_berr"=>
  ["   DLA_LIN_BERR computes component-wise relative backward error from",
   "   the formula",
   "       max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )",
   "   where abs(Z) is the component-wise absolute value of the matrix",
   "   or vector Z."],
 "slar2v"=>
  ["SLAR2V applies a vector of real plane rotations from both sides to",
   "a sequence of 2-by-2 real symmetric matrices, defined by the elements",
   "of the vectors x, y and z. For i = 1,2,...,n",
   "   ( x(i)  z(i) ) := (  c(i)  s(i) ) ( x(i)  z(i) ) ( c(i) -s(i) )",
   "   ( z(i)  y(i) )    ( -s(i)  c(i) ) ( z(i)  y(i) ) ( s(i)  c(i) )"],
 "dorbdb2"=>[],
 "chegvd"=>
  ["CHEGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian and B is also positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zgelqt3"=>
  ["DGELQT3 recursively computes a LQ factorization of a complex M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "slags2"=>
  ["SLAGS2 computes 2-by-2 orthogonal matrices U, V and Q, such",
   "that if ( UPPER ) then",
   "          U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )",
   "                            ( 0  A3 )     ( x  x  )",
   "and",
   "          V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )",
   "                           ( 0  B3 )     ( x  x  )",
   "or if ( .NOT.UPPER ) then",
   "          U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )",
   "                            ( A2 A3 )     ( 0  x  )",
   "and",
   "          V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )",
   "                          ( B2 B3 )     ( 0  x  )",
   "The rows of the transformed A and B are parallel, where",
   "  U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )",
   "      ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )",
   "Z**T denotes the transpose of Z."],
 "zlanhe"=>
  ["ZLANHE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex hermitian matrix A.",
   "   ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "sormr3"=>
  ["SORMR3 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'C',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by STZRZF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dsyevx_2stage"=>
  ["DSYEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "ctpqrt2"=>
  ["CTPQRT2 computes a QR factorization of a complex \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "clartv"=>
  ["CLARTV applies a vector of complex plane rotations with real cosines",
   "to elements of the complex vectors x and y. For i = 1,2,...,n",
   "   ( x(i) ) := (        c(i)   s(i) ) ( x(i) )",
   "   ( y(i) )    ( -conjg(s(i))  c(i) ) ( y(i) )"],
 "sla_syrcond"=>
  ["   SLA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "slapmr"=>
  ["SLAPMR rearranges the rows of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(K(I),*) is moved X(I,*) for I = 1,2,...,M.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(I,*) is moved to X(K(I),*) for I = 1,2,...,M."],
 "ctrcon"=>
  ["CTRCON estimates the reciprocal of the condition number of a",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "clabrd"=>
  ["CLABRD reduces the first NB rows and columns of a complex general",
   "m by n matrix A to upper or lower real bidiagonal form by a unitary",
   "transformation Q**H * A * P, and returns the matrices X and Y which",
   "are needed to apply the transformation to the unreduced part of A.",
   "If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower",
   "bidiagonal form.",
   "This is an auxiliary routine called by CGEBRD"],
 "cherfs"=>
  ["CHERFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "sptts2"=>
  ["SPTTS2 solves a tridiagonal system of the form",
   "   A * X = B",
   "using the L*D*L**T factorization of A computed by SPTTRF.  D is a",
   "diagonal matrix specified in the vector D, L is a unit bidiagonal",
   "matrix whose subdiagonal is specified in the vector E, and X and B",
   "are N by NRHS matrices."],
 "dsytf2_rk"=>
  ["DSYTF2_RK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "zgerfsx"=>
  ["   ZGERFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "sstevr"=>
  ["SSTEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T.  Eigenvalues and",
   "eigenvectors can be selected by specifying either a range of values",
   "or a range of indices for the desired eigenvalues.",
   "Whenever possible, SSTEVR calls SSTEMR to compute the",
   "eigenspectrum using Relatively Robust Representations.  SSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows. For the i-th",
   "unreduced block of T,",
   "   (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T",
   "        is a relatively robust representation,",
   "   (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high",
   "       relative accuracy by the dqds algorithm,",
   "   (c) If there is a cluster of close eigenvalues, \"choose\" sigma_i",
   "       close to the cluster, and go to step (a),",
   "   (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,",
   "       compute the corresponding eigenvector by forming a",
   "       rank-revealing twisted factorization.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see \"A new O(n^2) algorithm for the symmetric",
   "tridiagonal eigenvalue/eigenvector problem\", by Inderjit Dhillon,",
   "Computer Science Division Technical Report No. UCB//CSD-97-971,",
   "UC Berkeley, May 1997.",
   "Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of SSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "dlasq5"=>
  ["DLASQ5 computes one dqds transform in ping-pong form, one",
   "version for IEEE machines another for non IEEE machines."],
 "dlamswlq"=>
  ["   DLAMQRTS overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product of blocked",
   "   elementary reflectors computed by short wide LQ",
   "   factorization (DLASWLQ)"],
 "sorcsd2by1"=>[],
 "zunbdb2"=>[],
 "slarz"=>
  ["SLARZ applies a real elementary reflector H to a real M-by-N",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "H is a product of k elementary reflectors as returned by STZRZF."],
 "checon"=>
  ["CHECON estimates the reciprocal of the condition number of a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "slaed1"=>
  ["SLAED1 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix.  This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles",
   "the case in which eigenvalues only or eigenvalues and eigenvectors",
   "of a full symmetric matrix (which was reduced to tridiagonal form)",
   "are desired.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)",
   "   where Z = Q**T*u, u is a vector of length N with ones in the",
   "   CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine SLAED2.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine SLAED4 (as called by SLAED3).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "chetri_3x"=>
  ["CHETRI_3X computes the inverse of a complex Hermitian indefinite",
   "matrix A using the factorization computed by CHETRF_RK or CHETRF_BK:",
   "    A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "slasyf_aa"=>
  ["DLATRF_AA factorizes a panel of a real symmetric matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "clanhb"=>
  ["CLANHB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n hermitian band matrix A,  with k super-diagonals.",
   "   CLANHB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zlatsqr"=>
  ["SLATSQR computes a blocked Tall-Skinny QR factorization of",
   "an M-by-N matrix A, where M >= N:",
   "A = Q * R ."],
 "ssytrs_3"=>
  ["SSYTRS_3 solves a system of linear equations A * X = B with a real",
   "symmetric matrix A using the factorization computed",
   "by SSYTRF_RK or SSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "zgetrf"=>
  ["ZGETRF computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 3 BLAS version of the algorithm."],
 "dlaqr1"=>
  ["     Given a 2-by-2 or 3-by-3 matrix H, DLAQR1 sets v to a",
   "     scalar multiple of the first column of the product",
   "     (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)",
   "     scaling to avoid overflows and most underflows. It",
   "     is assumed that either",
   "             1) sr1 = sr2 and si1 = -si2",
   "         or",
   "             2) si1 = si2 = 0.",
   "     This is useful for starting double implicit shift bulges",
   "     in the QR algorithm."],
 "zppsv"=>
  ["ZPPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "disnan"=>
  ["DISNAN returns .TRUE. if its argument is NaN, and .FALSE.",
   "otherwise.  To be replaced by the Fortran 2003 intrinsic in the",
   "future."],
 "dppcon"=>
  ["DPPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite packed matrix using",
   "the Cholesky factorization A = U**T*U or A = L*L**T computed by",
   "DPPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zheevx"=>
  ["ZHEEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "zlaqr2"=>
  ["   ZLAQR2 is identical to ZLAQR3 except that it avoids",
   "   recursion by calling ZLAHQR instead of ZLAQR4.",
   "   Aggressive early deflation:",
   "   ZLAQR2 accepts as input an upper Hessenberg matrix",
   "   H and performs an unitary similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an unitary similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "clascl2"=>
  ["CLASCL2 performs a diagonal scaling on a vector:",
   "  x <-- D * x",
   "where the diagonal REAL matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_cge_diag_scale in the new BLAS",
   "standard."],
 "dla_porpvgrw"=>
  ["DLA_PORPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "zgeev"=>
  ["ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real."],
 "claqgb"=>
  ["CLAQGB equilibrates a general M by N band matrix A with KL",
   "subdiagonals and KU superdiagonals using the row and scaling factors",
   "in the vectors R and C."],
 "ztfsm"=>
  ["Level 3 BLAS like routine for A in RFP Format.",
   "ZTFSM  solves the matrix equation",
   "   op( A )*X = alpha*B  or  X*op( A ) = alpha*B",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**H.",
   "A is in Rectangular Full Packed (RFP) Format.",
   "The matrix X is overwritten on B."],
 "dlasv2"=>
  ["DLASV2 computes the singular value decomposition of a 2-by-2",
   "triangular matrix",
   "   [  F   G  ]",
   "   [  0   H  ].",
   "On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the",
   "smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and",
   "right singular vectors for abs(SSMAX), giving the decomposition",
   "   [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]",
   "   [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ]."],
 "slasq6"=>
  ["SLASQ6 computes one dqd (shift equal to zero) transform in",
   "ping-pong form, with protection against underflow and overflow."],
 "sgghrd"=>
  ["SGGHRD reduces a pair of real matrices (A,B) to generalized upper",
   "Hessenberg form using orthogonal transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the orthogonal matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**T*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**T*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**T*x.",
   "The orthogonal matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T",
   "     Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T",
   "If Q1 is the orthogonal matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then SGGHRD reduces the original",
   "problem to generalized Hessenberg form."],
 "slag2d"=>
  ["SLAG2D converts a SINGLE PRECISION matrix, SA, to a DOUBLE",
   "PRECISION matrix, A.",
   "Note that while it is possible to overflow while converting",
   "from double to single, it is not possible to overflow when",
   "converting from single to double.",
   "This is an auxiliary routine so there is no argument checking."],
 "dlarra"=>
  ["Compute the splitting points with threshold SPLTOL.",
   "DLARRA sets any \"small\" off-diagonal elements to zero."],
 "dlamtsqr"=>
  ["     DLAMTSQR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "     where Q is a real orthogonal matrix defined as the product",
   "     of blocked elementary reflectors computed by tall skinny",
   "     QR factorization (DLATSQR)"],
 "dstevx"=>
  ["DSTEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix A.  Eigenvalues and",
   "eigenvectors can be selected by specifying either a range of values",
   "or a range of indices for the desired eigenvalues."],
 "ssbgvd"=>
  ["SSBGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of the",
   "form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and",
   "banded, and B is also positive definite.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlascl2"=>
  ["DLASCL2 performs a diagonal scaling on a vector:",
   "  x <-- D * x",
   "where the diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_dge_diag_scale in the new BLAS",
   "standard."],
 "slarfg"=>
  ["SLARFG generates a real elementary reflector H of order n, such",
   "that",
   "      H * ( alpha ) = ( beta ),   H**T * H = I.",
   "          (   x   )   (   0  )",
   "where alpha and beta are scalars, and x is an (n-1)-element real",
   "vector. H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**T ) ,",
   "                    ( v )",
   "where tau is a real scalar and v is a real (n-1)-element",
   "vector.",
   "If the elements of x are all zero, then tau = 0 and H is taken to be",
   "the unit matrix.",
   "Otherwise  1 <= tau <= 2."],
 "dsysv_aa"=>
  ["DSYSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**T,  if UPLO = 'U', or",
   "   A = L * T * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is symmetric tridiagonal. The factored",
   "form of A is then used to solve the system of equations A * X = B."],
 "slae2"=>
  ["SLAE2  computes the eigenvalues of a 2-by-2 symmetric matrix",
   "   [  A   B  ]",
   "   [  B   C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, and RT2",
   "is the eigenvalue of smaller absolute value."],
 "sorbdb4"=>[],
 "dlarrv"=>
  ["DLARRV computes the eigenvectors of the tridiagonal matrix",
   "T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.",
   "The input eigenvalues should have been computed by DLARRE."],
 "cptrfs"=>
  ["CPTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite",
   "and tridiagonal, and provides error bounds and backward error",
   "estimates for the solution."],
 "csyconvf_rook"=>
  ["If parameter WAY = 'C':",
   "CSYCONVF_ROOK converts the factorization output format used in",
   "CSYTRF_ROOK provided on entry in parameter A into the factorization",
   "output format used in CSYTRF_RK (or CSYTRF_BK) that is stored",
   "on exit in parameters A and E. IPIV format for CSYTRF_ROOK and",
   "CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.",
   "If parameter WAY = 'R':",
   "CSYCONVF_ROOK performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in CSYTRF_RK",
   "(or CSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in CSYTRF_ROOK that is stored",
   "on exit in parameter A. IPIV format for CSYTRF_ROOK and",
   "CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.",
   "CSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between",
   "formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK)."],
 "zlacn2"=>
  ["ZLACN2 estimates the 1-norm of a square, complex matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "cheevx_2stage"=>
  ["CHEEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "dgelq"=>["DGELQ computes a LQ factorization of an M-by-N matrix A."],
 "zdrscl"=>
  ["ZDRSCL multiplies an n-element complex vector x by the real scalar",
   "1/a.  This is done without overflow or underflow as long as",
   "the final result x/a does not overflow or underflow."],
 "dpotf2"=>
  ["DPOTF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U ,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "dlasy2"=>
  ["DLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in",
   "       op(TL)*X + ISGN*X*op(TR) = SCALE*B,",
   "where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or",
   "-1.  op(T) = T or T**T, where T**T denotes the transpose of T."],
 "zhbtrd"=>
  ["ZHBTRD reduces a complex Hermitian band matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "dladiv"=>
  ["DLADIV performs complex division in  real arithmetic",
   "                      a + i*b",
   "           p + i*q = ---------",
   "                      c + i*d",
   "The algorithm is due to Michael Baudin and Robert L. Smith",
   "and can be found in the paper",
   "\"A Robust Complex Division in Scilab\""],
 "clapmt"=>
  ["CLAPMT rearranges the columns of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N."],
 "sgeqlf"=>
  ["SGEQLF computes a QL factorization of a real M-by-N matrix A:",
   "A = Q * L."],
 "dptrfs"=>
  ["DPTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and tridiagonal, and provides error bounds and backward error",
   "estimates for the solution."],
 "zgemqr"=>
  ["ZGEMQR overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "     TRANS = 'N':      Q * C          C * Q",
   "     TRANS = 'T':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product",
   "of blocked elementary reflectors computed by tall skinny",
   "QR factorization (ZGEQR)"],
 "zsycon"=>
  ["ZSYCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cpbsv"=>
  ["CPBSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular band matrix, and L is a lower",
   "triangular band matrix, with the same number of superdiagonals or",
   "subdiagonals as A.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "ctprfs"=>
  ["CTPRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular packed",
   "coefficient matrix.",
   "The solution matrix X must be computed by CTPTRS or some other",
   "means before entering this routine.  CTPRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "cherfsx"=>
  ["   CHERFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is Hermitian indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dsyevx"=>
  ["DSYEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "dla_geamv"=>
  ["DLA_GEAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dorml2"=>
  ["DORML2 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "slagtf"=>
  ["SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n",
   "tridiagonal matrix and lambda is a scalar, as",
   "   T - lambda*I = PLU,",
   "where P is a permutation matrix, L is a unit lower tridiagonal matrix",
   "with at most one non-zero sub-diagonal elements per column and U is",
   "an upper triangular matrix with at most two non-zero super-diagonal",
   "elements per column.",
   "The factorization is obtained by Gaussian elimination with partial",
   "pivoting and implicit row scaling.",
   "The parameter LAMBDA is included in the routine so that SLAGTF may",
   "be used, in conjunction with SLAGTS, to obtain eigenvectors of T by",
   "inverse iteration."],
 "zgtcon"=>
  ["ZGTCON estimates the reciprocal of the condition number of a complex",
   "tridiagonal matrix A using the LU factorization as computed by",
   "ZGTTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "spftri"=>
  ["SPFTRI computes the inverse of a real (symmetric) positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by SPFTRF."],
 "ztpmqrt"=>
  ["ZTPMQRT applies a complex orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" complex block reflector H to a general",
   "complex matrix C, which consists of two blocks A and B."],
 "cgejsv"=>
  ["CGEJSV computes the singular value decomposition (SVD) of a complex M-by-N",
   "matrix [A], where M >= N. The SVD of [A] is written as",
   "             [A] = [U] * [SIGMA] * [V]^*,",
   "where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N",
   "diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and",
   "[V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are",
   "the singular values of [A]. The columns of [U] and [V] are the left and",
   "the right singular vectors of [A], respectively. The matrices [U] and [V]",
   "are computed and stored in the arrays U and V, respectively. The diagonal",
   "of [SIGMA] is computed and stored in the array SVA."],
 "stgevc"=>
  ["STGEVC computes some or all of the right and/or left eigenvectors of",
   "a pair of real matrices (S,P), where S is a quasi-triangular matrix",
   "and P is upper triangular.  Matrix pairs of this type are produced by",
   "the generalized Schur factorization of a matrix pair (A,B):",
   "   A = Q*S*Z**T,  B = Q*P*Z**T",
   "as computed by SGGHRD + SHGEQZ.",
   "The right eigenvector x and the left eigenvector y of (S,P)",
   "corresponding to an eigenvalue w are defined by:",
   "   S*x = w*P*x,  (y**H)*S = w*(y**H)*P,",
   "where y**H denotes the conjugate tranpose of y.",
   "The eigenvalues are not input to this routine, but are computed",
   "directly from the diagonal blocks of S and P.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of (S,P), or the products Z*X and/or Q*Y,",
   "where Z and Q are input matrices.",
   "If Q and Z are the orthogonal factors from the generalized Schur",
   "factorization of a matrix pair (A,B), then Z*X and Q*Y",
   "are the matrices of right and left eigenvectors of (A,B)."],
 "slaqsp"=>
  ["SLAQSP equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "zggbal"=>
  ["ZGGBAL balances a pair of general complex matrices (A,B).  This",
   "involves, first, permuting A and B by similarity transformations to",
   "isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N",
   "elements on the diagonal; and second, applying a diagonal similarity",
   "transformation to rows and columns ILO to IHI to make the rows",
   "and columns as close in norm as possible. Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrices, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors in the",
   "generalized eigenvalue problem A*x = lambda*B*x."],
 "dlahqr"=>
  ["   DLAHQR is an auxiliary routine called by DHSEQR to update the",
   "   eigenvalues and Schur decomposition already computed by DHSEQR, by",
   "   dealing with the Hessenberg submatrix in rows and columns ILO to",
   "   IHI."],
 "dpbequ"=>
  ["DPBEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite band matrix A and reduce its condition",
   "number (with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "dlaln2"=>
  ["DLALN2 solves a system of the form  (ca A - w D ) X = s B",
   "or (ca A**T - w D) X = s B   with possible scaling (\"s\") and",
   "perturbation of A.  (A**T means A-transpose.)",
   "A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA",
   "real diagonal matrix, w is a real or complex value, and X and B are",
   "NA x 1 matrices -- real if w is real, complex if w is complex.  NA",
   "may be 1 or 2.",
   "If w is complex, X and B are represented as NA x 2 matrices,",
   "the first column of each being the real part and the second",
   "being the imaginary part.",
   "\"s\" is a scaling factor (.LE. 1), computed by DLALN2, which is",
   "so chosen that X can be computed without overflow.  X is further",
   "scaled if necessary to assure that norm(ca A - w D)*norm(X) is less",
   "than overflow.",
   "If both singular values of (ca A - w D) are less than SMIN,",
   "SMIN*identity will be used instead of (ca A - w D).  If only one",
   "singular value is less than SMIN, one element of (ca A - w D) will be",
   "perturbed enough to make the smallest singular value roughly SMIN.",
   "If both singular values are at least SMIN, (ca A - w D) will not be",
   "perturbed.  In any case, the perturbation will be at most some small",
   "multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values",
   "are computed by infinity-norm approximations, and thus will only be",
   "correct to a factor of 2 or so.",
   "Note: all input quantities are assumed to be smaller than overflow",
   "by a reasonable factor.  (See BIGNUM.)"],
 "dgelqt3"=>
  ["DGELQT3 recursively computes a LQ factorization of a real M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "dggqrf"=>
  ["DGGQRF computes a generalized QR factorization of an N-by-M matrix A",
   "and an N-by-P matrix B:",
   "            A = Q*R,        B = Q*T*Z,",
   "where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal",
   "matrix, and R and T assume one of the forms:",
   "if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,",
   "                (  0  ) N-M                         N   M-N",
   "                   M",
   "where R11 is upper triangular, and",
   "if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,",
   "                 P-N  N                           ( T21 ) P",
   "                                                     P",
   "where T12 or T21 is upper triangular.",
   "In particular, if B is square and nonsingular, the GQR factorization",
   "of A and B implicitly gives the QR factorization of inv(B)*A:",
   "             inv(B)*A = Z**T*(inv(T)*R)",
   "where inv(B) denotes the inverse of the matrix B, and Z**T denotes the",
   "transpose of the matrix Z."],
 "sgemlqt"=>
  ["DGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'T':   Q**T C            C Q**T",
   "where Q is a real orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**T",
   "generated using the compact WY representation as returned by DGELQT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "ztpmlqt"=>
  ["ZTPMQRT applies a complex orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "chbevd_2stage"=>
  ["CHBEVD_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dhgeqz"=>
  ["DHGEQZ computes the eigenvalues of a real matrix pair (H,T),",
   "where H is an upper Hessenberg matrix and T is upper triangular,",
   "using the double-shift QZ method.",
   "Matrix pairs of this type are produced by the reduction to",
   "generalized upper Hessenberg form of a real matrix pair (A,B):",
   "   A = Q1*H*Z1**T,  B = Q1*T*Z1**T,",
   "as computed by DGGHRD.",
   "If JOB='S', then the Hessenberg-triangular pair (H,T) is",
   "also reduced to generalized Schur form,",
   "   H = Q*S*Z**T,  T = Q*P*Z**T,",
   "where Q and Z are orthogonal matrices, P is an upper triangular",
   "matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2",
   "diagonal blocks.",
   "The 1-by-1 blocks correspond to real eigenvalues of the matrix pair",
   "(H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of",
   "eigenvalues.",
   "Additionally, the 2-by-2 upper triangular diagonal blocks of P",
   "corresponding to 2-by-2 blocks of S are reduced to positive diagonal",
   "form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,",
   "P(j,j) > 0, and P(j+1,j+1) > 0.",
   "Optionally, the orthogonal matrix Q from the generalized Schur",
   "factorization may be postmultiplied into an input matrix Q1, and the",
   "orthogonal matrix Z may be postmultiplied into an input matrix Z1.",
   "If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced",
   "the matrix pair (A,B) to generalized upper Hessenberg form, then the",
   "output matrices Q1*Q and Z1*Z are the orthogonal factors from the",
   "generalized Schur factorization of (A,B):",
   "   A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.",
   "To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,",
   "of (A,B)) are computed as a pair of values (alpha,beta), where alpha is",
   "complex and beta real.",
   "If beta is nonzero, lambda = alpha / beta is an eigenvalue of the",
   "generalized nonsymmetric eigenvalue problem (GNEP)",
   "   A*x = lambda*B*x",
   "and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the",
   "alternate form of the GNEP",
   "   mu*A*y = B*y.",
   "Real eigenvalues can be read directly from the generalized Schur",
   "form:",
   "  alpha = S(i,i), beta = P(i,i).",
   "Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix",
   "     Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),",
   "     pp. 241--256."],
 "sgeev"=>
  ["SGEEV computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate-transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real."],
 "zpbtf2"=>
  ["ZPBTF2 computes the Cholesky factorization of a complex Hermitian",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**H * U ,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix, U**H is the conjugate transpose",
   "of U, and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "chetrf_rook"=>
  ["CHETRF_ROOK computes the factorization of a comlex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "ssbgst"=>
  ["SSBGST reduces a real symmetric-definite banded generalized",
   "eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,",
   "such that C has the same bandwidth as A.",
   "B must have been previously factorized as S**T*S by SPBSTF, using a",
   "split Cholesky factorization. A is overwritten by C = X**T*A*X, where",
   "X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the",
   "bandwidth of A."],
 "cgerqf"=>
  ["CGERQF computes an RQ factorization of a complex M-by-N matrix A:",
   "A = R * Q."],
 "zhbgvx"=>
  ["ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite.  Eigenvalues and",
   "eigenvectors can be selected by specifying either all eigenvalues,",
   "a range of values or a range of indices for the desired eigenvalues."],
 "zhegs2"=>
  ["ZHEGS2 reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H *A*L.",
   "B must have been previously factorized as U**H *U or L*L**H by ZPOTRF."],
 "zgetf2"=>
  ["ZGETF2 computes an LU factorization of a general m-by-n matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 2 BLAS version of the algorithm."],
 "zgbequb"=>
  ["ZGBEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from ZGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "zhetrs_3"=>
  ["ZHETRS_3 solves a system of linear equations A * X = B with a complex",
   "Hermitian matrix A using the factorization computed",
   "by ZHETRF_RK or ZHETRF_BK:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "slagv2"=>
  ["SLAGV2 computes the Generalized Schur factorization of a real 2-by-2",
   "matrix pencil (A,B) where B is upper triangular. This routine",
   "computes orthogonal (rotation) matrices given by CSL, SNL and CSR,",
   "SNR such that",
   "1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0",
   "   types), then",
   "   [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]",
   "   [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]",
   "   [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]",
   "   [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],",
   "2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,",
   "   then",
   "   [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]",
   "   [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]",
   "   [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]",
   "   [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]",
   "   where b11 >= b22 > 0."],
 "zla_syamv"=>
  ["ZLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dopmtr"=>
  ["DOPMTR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by DSPTRD using packed",
   "storage:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "dsygvx"=>
  ["DSYGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A",
   "and B are assumed to be symmetric and B is also positive definite.",
   "Eigenvalues and eigenvectors can be selected by specifying either a",
   "range of values or a range of indices for the desired eigenvalues."],
 "cpotf2"=>
  ["CPOTF2 computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U ,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "claesy"=>
  ["CLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix",
   "   ( ( A, B );( B, C ) )",
   "provided the norm of the matrix of eigenvectors is larger than",
   "some threshold value.",
   "RT1 is the eigenvalue of larger absolute value, and RT2 of",
   "smaller absolute value.  If the eigenvectors are computed, then",
   "on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence",
   "[  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]",
   "[ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]"],
 "slaed2"=>
  ["SLAED2 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny entry in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "dlat2s"=>
  ["DLAT2S converts a DOUBLE PRECISION triangular matrix, SA, to a SINGLE",
   "PRECISION triangular matrix, A.",
   "RMAX is the overflow for the SINGLE PRECISION arithmetic",
   "DLAS2S checks that all the entries of A are between -RMAX and",
   "RMAX. If not the conversion is aborted and a flag is raised.",
   "This is an auxiliary routine so there is no argument checking."],
 "cpbsvx"=>
  ["CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "ztgsna"=>
  ["ZTGSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or eigenvectors of a matrix pair (A, B).",
   "(A, B) must be in generalized Schur canonical form, that is, A and",
   "B are both upper triangular."],
 "dgerqf"=>
  ["DGERQF computes an RQ factorization of a real M-by-N matrix A:",
   "A = R * Q."],
 "dlanhs"=>
  ["DLANHS  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "Hessenberg matrix A.",
   "   DLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zgecon"=>
  ["ZGECON estimates the reciprocal of the condition number of a general",
   "complex matrix A, in either the 1-norm or the infinity-norm, using",
   "the LU factorization computed by ZGETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "csytri_3x"=>
  ["CSYTRI_3X computes the inverse of a complex symmetric indefinite",
   "matrix A using the factorization computed by CSYTRF_RK or CSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dpbstf"=>
  ["DPBSTF computes a split Cholesky factorization of a real",
   "symmetric positive definite band matrix A.",
   "This routine is designed to be used in conjunction with DSBGST.",
   "The factorization has the form  A = S**T*S  where S is a band matrix",
   "of the same bandwidth as A and the following structure:",
   "  S = ( U    )",
   "      ( M  L )",
   "where U is upper triangular of order m = (n+kd)/2, and L is lower",
   "triangular of order n-m."],
 "slascl2"=>
  ["SLASCL2 performs a diagonal scaling on a vector:",
   "  x <-- D * x",
   "where the diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_sge_diag_scale in the new BLAS",
   "standard."],
 "sgeqrt3"=>
  ["SGEQRT3 recursively computes a QR factorization of a real M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "sorbdb2"=>[],
 "zpptri"=>
  ["ZPPTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by ZPPTRF."],
 "dsyev"=>
  ["DSYEV computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A."],
 "sgbtf2"=>
  ["SGBTF2 computes an LU factorization of a real m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zla_wwaddw"=>
  ["   ZLA_WWADDW adds a vector W into a doubled-single vector (X, Y).",
   "   This works for all extant IBM's hex and binary floating point",
   "   arithmetics, but not for decimal."],
 "zlanhf"=>
  ["ZLANHF  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex Hermitian matrix A in RFP format.",
   "   ZLANHF = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm."],
 "zsycon_rook"=>
  ["ZSYCON_ROOK estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by ZSYTRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "slasd8"=>
  ["SLASD8 finds the square roots of the roots of the secular equation,",
   "as defined by the values in DSIGMA and Z. It makes the appropriate",
   "calls to SLASD4, and stores, for each  element in D, the distance",
   "to its two nearest poles (elements in DSIGMA). It also updates",
   "the arrays VF and VL, the first and last components of all the",
   "right singular vectors of the original bidiagonal matrix.",
   "SLASD8 is called from SLASD6."],
 "slartg"=>
  ["SLARTG generate a plane rotation so that",
   "   [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a slower, more accurate version of the BLAS1 routine SROTG,",
   "with the following other differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=1 and SN=0.",
   "   If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any",
   "      floating point operations (saves work in SBDSQR when",
   "      there are zeros on the diagonal).",
   "If F exceeds G in magnitude, CS will be positive."],
 "spptrf"=>
  ["SPPTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A stored in packed format.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "sstemr"=>
  ["SSTEMR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "Depending on the number of desired eigenvalues, these are computed either",
   "by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are",
   "computed by the use of various suitable L D L^T factorizations near clusters",
   "of close eigenvalues (referred to as RRRs, Relatively Robust",
   "Representations). An informal sketch of the algorithm follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "For more details, see:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Further Details",
   "1.SSTEMR works only on machines which follow IEEE-754",
   "floating-point standard in their handling of infinities and NaNs.",
   "This permits the use of efficient inner loops avoiding a check for",
   "zero divisors."],
 "zgejsv"=>
  ["ZGEJSV computes the singular value decomposition (SVD) of a complex M-by-N",
   "matrix [A], where M >= N. The SVD of [A] is written as",
   "             [A] = [U] * [SIGMA] * [V]^*,",
   "where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N",
   "diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and",
   "[V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are",
   "the singular values of [A]. The columns of [U] and [V] are the left and",
   "the right singular vectors of [A], respectively. The matrices [U] and [V]",
   "are computed and stored in the arrays U and V, respectively. The diagonal",
   "of [SIGMA] is computed and stored in the array SVA."],
 "dorgrq"=>
  ["DORGRQ generates an M-by-N real matrix Q with orthonormal rows,",
   "which is defined as the last M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by DGERQF."],
 "ctrevc"=>
  ["CTREVC computes some or all of the right and/or left eigenvectors of",
   "a complex upper triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a complex general matrix:  A = Q*T*Q**H, as computed by CHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "             T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of the vector y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix.  If Q is the unitary factor that reduces a matrix A to",
   "Schur form T, then Q*X and Q*Y are the matrices of right and left",
   "eigenvectors of A."],
 "dgttrf"=>
  ["DGTTRF computes an LU factorization of a real tridiagonal matrix A",
   "using elimination with partial pivoting and row interchanges.",
   "The factorization has the form",
   "   A = L * U",
   "where L is a product of permutation and unit lower bidiagonal",
   "matrices and U is upper triangular with nonzeros in only the main",
   "diagonal and first two superdiagonals."],
 "ssytri2"=>
  ["SSYTRI2 computes the inverse of a REAL symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "SSYTRF. SSYTRI2 sets the LEADING DIMENSION of the workspace",
   "before calling SSYTRI2X that actually computes the inverse."],
 "sormql"=>
  ["SORMQL overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by SGEQLF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "slarscl2"=>
  ["SLARSCL2 performs a reciprocal diagonal scaling on an vector:",
   "  x <-- inv(D) * x",
   "where the diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_sge_diag_scale in the new BLAS",
   "standard."],
 "chegs2"=>
  ["CHEGS2 reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H *A*L.",
   "B must have been previously factorized as U**H *U or L*L**H by ZPOTRF."],
 "claed7"=>
  ["CLAED7 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix. This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and optionally eigenvectors of a dense or banded",
   "Hermitian matrix that has been reduced to tridiagonal form.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)",
   "  where Z = Q**Hu, u is a vector of length N with ones in the",
   "  CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine SLAED2.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine SLAED4 (as called by SLAED3).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "chsein"=>
  ["CHSEIN uses inverse iteration to find specified right and/or left",
   "eigenvectors of a complex upper Hessenberg matrix H.",
   "The right eigenvector x and the left eigenvector y of the matrix H",
   "corresponding to an eigenvalue w are defined by:",
   "             H * x = w * x,     y**h * H = w * y**h",
   "where y**h denotes the conjugate transpose of the vector y."],
 "dgbequ"=>
  ["DGBEQU computes row and column scalings intended to equilibrate an",
   "M-by-N band matrix A and reduce its condition number.  R returns the",
   "row scale factors and C the column scale factors, chosen to try to",
   "make the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "cunbdb3"=>[],
 "dggesx"=>
  ["DGGESX computes for a pair of N-by-N real nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the real Schur form (S,T), and,",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR).  This gives the generalized Schur factorization",
   "     (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T; computes",
   "a reciprocal condition number for the average of the selected",
   "eigenvalues (RCONDE); and computes a reciprocal condition number for",
   "the right and left deflating subspaces corresponding to the selected",
   "eigenvalues (RCONDV). The leading columns of VSL and VSR then form",
   "an orthonormal basis for the corresponding left and right eigenspaces",
   "(deflating subspaces).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or for both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "sopmtr"=>
  ["SOPMTR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by SSPTRD using packed",
   "storage:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "slasd0"=>
  ["Using a divide and conquer approach, SLASD0 computes the singular",
   "value decomposition (SVD) of a real upper bidiagonal N-by-M",
   "matrix B with diagonal D and offdiagonal E, where M = N + SQRE.",
   "The algorithm computes orthogonal matrices U and VT such that",
   "B = U * S * VT. The singular values S are overwritten on D.",
   "A related subroutine, SLASDA, computes only the singular values,",
   "and optionally, the singular vectors in compact form."],
 "cpftri"=>
  ["CPFTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by CPFTRF."],
 "dlatdf"=>
  ["DLATDF uses the LU factorization of the n-by-n matrix Z computed by",
   "DGETC2 and computes a contribution to the reciprocal Dif-estimate",
   "by solving Z * x = b for x, and choosing the r.h.s. b such that",
   "the norm of x is as large as possible. On entry RHS = b holds the",
   "contribution from earlier solved sub-systems, and on return RHS = x.",
   "The factorization of Z returned by DGETC2 has the form Z = P*L*U*Q,",
   "where P and Q are permutation matrices. L is lower triangular with",
   "unit diagonal elements and U is upper triangular."],
 "zlaqsp"=>
  ["ZLAQSP equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "dtgsen"=>
  ["DTGSEN reorders the generalized real Schur decomposition of a real",
   "matrix pair (A, B) (in terms of an orthonormal equivalence trans-",
   "formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues",
   "appears in the leading diagonal blocks of the upper quasi-triangular",
   "matrix A and the upper triangular B. The leading columns of Q and",
   "Z form orthonormal bases of the corresponding left and right eigen-",
   "spaces (deflating subspaces). (A, B) must be in generalized real",
   "Schur canonical form (as returned by DGGES), i.e. A is block upper",
   "triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper",
   "triangular.",
   "DTGSEN also computes the generalized eigenvalues",
   "            w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)",
   "of the reordered matrix pair (A, B).",
   "Optionally, DTGSEN computes the estimates of reciprocal condition",
   "numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),",
   "(A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)",
   "between the matrix pairs (A11, B11) and (A22,B22) that correspond to",
   "the selected cluster and the eigenvalues outside the cluster, resp.,",
   "and norms of \"projections\" onto left and right eigenspaces w.r.t.",
   "the selected cluster in the (1,1)-block."],
 "zstein"=>
  ["ZSTEIN computes the eigenvectors of a real symmetric tridiagonal",
   "matrix T corresponding to specified eigenvalues, using inverse",
   "iteration.",
   "The maximum number of iterations allowed for each eigenvector is",
   "specified by an internal parameter MAXITS (currently set to 5).",
   "Although the eigenvectors are real, they are stored in a complex",
   "array, which may be passed to ZUNMTR or ZUPMTR for back",
   "transformation to the eigenvectors of a complex Hermitian matrix",
   "which was reduced to tridiagonal form."],
 "clarf"=>
  ["CLARF applies a complex elementary reflector H to a complex M-by-N",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "To apply H**H (the conjugate transpose of H), supply conjg(tau) instead",
   "tau."],
 "sorbdb6"=>[],
 "dorg2r"=>
  ["DORG2R generates an m by n real matrix Q with orthonormal columns,",
   "which is defined as the first n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by DGEQRF."],
 "ssygv_2stage"=>
  ["SSYGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric and B is also",
   "positive definite.",
   "This routine use the 2stage technique for the reduction to tridiagonal",
   "which showed higher performance on recent architecture and for large"],
 "ilazlc"=>["ILAZLC scans A for its last non-zero column."],
 "zlascl2"=>
  ["ZLASCL2 performs a diagonal scaling on a vector:",
   "  x <-- D * x",
   "where the DOUBLE PRECISION diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_zge_diag_scale in the new BLAS",
   "standard."],
 "csyrfsx"=>
  ["   CSYRFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "zhpgst"=>
  ["ZHPGST reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form, using packed storage.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.",
   "B must have been previously factorized as U**H*U or L*L**H by ZPPTRF."],
 "zheevd"=>
  ["ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A.  If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zhsein"=>
  ["ZHSEIN uses inverse iteration to find specified right and/or left",
   "eigenvectors of a complex upper Hessenberg matrix H.",
   "The right eigenvector x and the left eigenvector y of the matrix H",
   "corresponding to an eigenvalue w are defined by:",
   "             H * x = w * x,     y**h * H = w * y**h",
   "where y**h denotes the conjugate transpose of the vector y."],
 "cptsv"=>
  ["CPTSV computes the solution to a complex system of linear equations",
   "A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal",
   "matrix, and X and B are N-by-NRHS matrices.",
   "A is factored as A = L*D*L**H, and the factored form of A is then",
   "used to solve the system of equations."],
 "zlantp"=>
  ["ZLANTP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "triangular matrix A, supplied in packed form.",
   "   ZLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zungql"=>
  ["ZUNGQL generates an M-by-N complex matrix Q with orthonormal columns,",
   "which is defined as the last N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by ZGEQLF."],
 "dptsvx"=>
  ["DPTSVX uses the factorization A = L*D*L**T to compute the solution",
   "to a real system of linear equations A*X = B, where A is an N-by-N",
   "symmetric positive definite tridiagonal matrix and X and B are",
   "N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "cunbdb5"=>[],
 "sorbdb1"=>[],
 "chfrk"=>
  ["Level 3 BLAS like routine for C in RFP Format.",
   "CHFRK performs one of the Hermitian rank--k operations",
   "   C := alpha*A*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*A + beta*C,",
   "where alpha and beta are real scalars, C is an n--by--n Hermitian",
   "matrix and A is an n--by--k matrix in the first case and a k--by--n",
   "matrix in the second case."],
 "sgehrd"=>
  ["SGEHRD reduces a real general matrix A to upper Hessenberg form H by",
   "an orthogonal similarity transformation:  Q**T * A * Q = H ."],
 "zlalsa"=>
  ["ZLALSA is an itermediate step in solving the least squares problem",
   "by computing the SVD of the coefficient matrix in compact form (The",
   "singular vectors are computed as products of simple orthorgonal",
   "matrices.).",
   "If ICOMPQ = 0, ZLALSA applies the inverse of the left singular vector",
   "matrix of an upper bidiagonal matrix to the right hand side; and if",
   "ICOMPQ = 1, ZLALSA applies the right singular vector matrix to the",
   "right hand side. The singular vector matrices were generated in",
   "compact form by ZLALSA."],
 "cunmql"=>
  ["CUNMQL overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by CGEQLF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "zhetd2"=>
  ["ZHETD2 reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "zgelq2"=>
  ["ZGELQ2 computes an LQ factorization of a complex m by n matrix A:",
   "A = L * Q."],
 "slaeda"=>
  ["SLAEDA computes the Z vector corresponding to the merge step in the",
   "CURLVLth step of the merge process with TLVLS steps for the CURPBMth",
   "problem."],
 "slasrt"=>
  ["Sort the numbers in D in increasing order (if ID = 'I') or",
   "in decreasing order (if ID = 'D' ).",
   "Use Quick Sort, reverting to Insertion sort on arrays of",
   "size <= 20. Dimension of STACK limits N to about 2**32."],
 "slascl"=>
  ["SLASCL multiplies the M by N real matrix A by the real scalar",
   "CTO/CFROM.  This is done without over/underflow as long as the final",
   "result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that",
   "A may be full, upper triangular, lower triangular, upper Hessenberg,",
   "or banded."],
 "sggrqf"=>
  ["SGGRQF computes a generalized RQ factorization of an M-by-N matrix A",
   "and a P-by-N matrix B:",
   "            A = R*Q,        B = Z*T*Q,",
   "where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal",
   "matrix, and R and T assume one of the forms:",
   "if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,",
   "                 N-M  M                           ( R21 ) N",
   "                                                     N",
   "where R12 or R21 is upper triangular, and",
   "if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,",
   "                (  0  ) P-N                         P   N-P",
   "                   N",
   "where T11 is upper triangular.",
   "In particular, if B is square and nonsingular, the GRQ factorization",
   "of A and B implicitly gives the RQ factorization of A*inv(B):",
   "             A*inv(B) = (R*inv(T))*Z**T",
   "where inv(B) denotes the inverse of the matrix B, and Z**T denotes the",
   "transpose of the matrix Z."],
 "cgbsv"=>
  ["CGBSV computes the solution to a complex system of linear equations",
   "A * X = B, where A is a band matrix of order N with KL subdiagonals",
   "and KU superdiagonals, and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as A = L * U, where L is a product of permutation",
   "and unit lower triangular matrices with KL subdiagonals, and U is",
   "upper triangular with KL+KU superdiagonals.  The factored form of A",
   "is then used to solve the system of equations A * X = B."],
 "chetrs_rook"=>
  ["CHETRS_ROOK solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF_ROOK."],
 "dposvx"=>
  ["DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dgemlq"=>
  ["    DGEMLQ overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product",
   "   of blocked elementary reflectors computed by short wide LQ",
   "   factorization (DGELQ)"],
 "dgerfsx"=>
  ["   DGERFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dsytri_3x"=>
  ["DSYTRI_3X computes the inverse of a real symmetric indefinite",
   "matrix A using the factorization computed by DSYTRF_RK or DSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "clarfb"=>
  ["CLARFB applies a complex block reflector H or its transpose H**H to a",
   "complex M-by-N matrix C, from either the left or the right."],
 "clacrt"=>
  ["CLACRT performs the operation",
   "   (  c  s )( x )  ==> ( x )",
   "   ( -s  c )( y )      ( y )",
   "where c and s are complex and the vectors x and y are complex."],
 "dpftri"=>
  ["DPFTRI computes the inverse of a (real) symmetric positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by DPFTRF."],
 "slaqr2"=>
  ["   SLAQR2 is identical to SLAQR3 except that it avoids",
   "   recursion by calling SLAHQR instead of SLAQR4.",
   "   Aggressive early deflation:",
   "   This subroutine accepts as input an upper Hessenberg matrix",
   "   H and performs an orthogonal similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an orthogonal similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "zgbrfs"=>
  ["ZGBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is banded, and provides",
   "error bounds and backward error estimates for the solution."],
 "dlasda"=>
  ["Using a divide and conquer approach, DLASDA computes the singular",
   "value decomposition (SVD) of a real upper bidiagonal N-by-M matrix",
   "B with diagonal D and offdiagonal E, where M = N + SQRE. The",
   "algorithm computes the singular values in the SVD B = U * S * VT.",
   "The orthogonal matrices U and VT are optionally computed in",
   "compact form.",
   "A related subroutine, DLASD0, computes the singular values and",
   "the singular vectors in explicit form."],
 "dtpqrt2"=>
  ["DTPQRT2 computes a QR factorization of a real \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "zlarnv"=>
  ["ZLARNV returns a vector of n random complex numbers from a uniform or",
   "normal distribution."],
 "dla_gbrpvgrw"=>
  ["DLA_GBRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "zgesvxx"=>
  ["   ZGESVXX uses the LU factorization to compute the solution to a",
   "   complex*16 system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. ZGESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   ZGESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   ZGESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what ZGESVXX would itself produce."],
 "sgeqr2"=>
  ["SGEQR2 computes a QR factorization of a real m by n matrix A:",
   "A = Q * R."],
 "claqsy"=>
  ["CLAQSY equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "cgtcon"=>
  ["CGTCON estimates the reciprocal of the condition number of a complex",
   "tridiagonal matrix A using the LU factorization as computed by",
   "CGTTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "ssygvd"=>
  ["SSYGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be symmetric and B is also positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slaisnan"=>
  ["This routine is not for general use.  It exists solely to avoid",
   "over-optimization in SISNAN.",
   "SLAISNAN checks for NaNs by comparing its two arguments for",
   "inequality.  NaN is the only floating-point value where NaN != NaN",
   "returns .TRUE.  To check for NaNs, pass the same variable as both",
   "arguments.",
   "A compiler must assume that the two arguments are",
   "not the same variable, and the test will not be optimized away.",
   "Interprocedural or whole-program optimization may delete this",
   "test.  The ISNAN functions will be replaced by the correct",
   "Fortran 03 intrinsic once the intrinsic is widely available."],
 "clals0"=>
  ["CLALS0 applies back the multiplying factors of either the left or the",
   "right singular vector matrix of a diagonal matrix appended by a row",
   "to the right hand side matrix B in solving the least squares problem",
   "using the divide-and-conquer SVD approach.",
   "For the left singular vector matrix, three types of orthogonal",
   "matrices are involved:",
   "(1L) Givens rotations: the number of such rotations is GIVPTR; the",
   "     pairs of columns/rows they were applied to are stored in GIVCOL;",
   "     and the C- and S-values of these rotations are stored in GIVNUM.",
   "(2L) Permutation. The (NL+1)-st row of B is to be moved to the first",
   "     row, and for J=2:N, PERM(J)-th row of B is to be moved to the",
   "     J-th row.",
   "(3L) The left singular vector matrix of the remaining matrix.",
   "For the right singular vector matrix, four types of orthogonal",
   "matrices are involved:",
   "(1R) The right singular vector matrix of the remaining matrix.",
   "(2R) If SQRE = 1, one extra Givens rotation to generate the right",
   "     null space.",
   "(3R) The inverse transformation of (2L).",
   "(4R) The inverse transformation of (1L)."],
 "cgeqrt2"=>
  ["CGEQRT2 computes a QR factorization of a complex M-by-N matrix A,",
   "using the compact WY representation of Q."],
 "dormrq"=>
  ["DORMRQ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DGERQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "clarnv"=>
  ["CLARNV returns a vector of n random complex numbers from a uniform or",
   "normal distribution."],
 "zgehd2"=>
  ["ZGEHD2 reduces a complex general matrix A to upper Hessenberg form H",
   "by a unitary similarity transformation:  Q**H * A * Q = H ."],
 "dlaqr3"=>
  ["   Aggressive early deflation:",
   "   DLAQR3 accepts as input an upper Hessenberg matrix",
   "   H and performs an orthogonal similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an orthogonal similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "zpbtrf"=>
  ["ZPBTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "slaexc"=>
  ["SLAEXC swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in",
   "an upper quasi-triangular matrix T by an orthogonal similarity",
   "transformation.",
   "T must be in Schur canonical form, that is, block upper triangular",
   "with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block",
   "has its diagonal elemnts equal and its off-diagonal elements of",
   "opposite sign."],
 "dpbsvx"=>
  ["DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dsytrd_sy2sb"=>
  ["DSYTRD_SY2SB reduces a real symmetric matrix A to real symmetric",
   "band-diagonal form AB by a orthogonal similarity transformation:",
   "Q**T * A * Q = AB."],
 "zsptrf"=>
  ["ZSPTRF computes the factorization of a complex symmetric matrix A",
   "stored in packed format using the Bunch-Kaufman diagonal pivoting",
   "method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "zgebrd"=>
  ["ZGEBRD reduces a general complex M-by-N matrix A to upper or lower",
   "bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "sorg2r"=>
  ["SORG2R generates an m by n real matrix Q with orthonormal columns,",
   "which is defined as the first n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by SGEQRF."],
 "stpmlqt"=>
  ["DTPMQRT applies a real orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "dsbev_2stage"=>
  ["DSBEV_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "sgbequb"=>
  ["SGBEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from SGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "dlasrt"=>
  ["Sort the numbers in D in increasing order (if ID = 'I') or",
   "in decreasing order (if ID = 'D' ).",
   "Use Quick Sort, reverting to Insertion sort on arrays of",
   "size <= 20. Dimension of STACK limits N to about 2**32."],
 "sgelqt3"=>
  ["DGELQT3 recursively computes a LQ factorization of a real M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "zpbsv"=>
  ["ZPBSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular band matrix, and L is a lower",
   "triangular band matrix, with the same number of superdiagonals or",
   "subdiagonals as A.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "dgetrf"=>
  ["DGETRF computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 3 BLAS version of the algorithm."],
 "cgemqr"=>
  ["CGEMQR overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "     TRANS = 'N':      Q * C          C * Q",
   "     TRANS = 'T':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product",
   "of blocked elementary reflectors computed by tall skinny",
   "QR factorization (CGEQR)"],
 "sgbsvxx"=>
  ["   SGBSVXX uses the LU factorization to compute the solution to a",
   "   real system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. SGBSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   SGBSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   SGBSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what SGBSVXX would itself produce."],
 "dpprfs"=>
  ["DPPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "iparmq"=>
  ["     This program sets problem and machine dependent parameters",
   "     useful for xHSEQR and related subroutines for eigenvalue",
   "     problems. It is called whenever",
   "     IPARMQ is called with 12 <= ISPEC <= 16"],
 "cunbdb2"=>[],
 "zsytrf"=>
  ["ZSYTRF computes the factorization of a complex symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dsytri_3"=>
  ["DSYTRI_3 computes the inverse of a real symmetric indefinite",
   "matrix A using the factorization computed by DSYTRF_RK or DSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "DSYTRI_3 sets the leading dimension of the workspace  before calling",
   "DSYTRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "ztpqrt2"=>
  ["ZTPQRT2 computes a QR factorization of a complex \"triangular-pentagonal\"",
   "matrix C, which is composed of a triangular block A and pentagonal block B,",
   "using the compact WY representation for Q."],
 "cheevd"=>
  ["CHEEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A.  If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slatrz"=>
  ["SLATRZ factors the M-by-(M+L) real upper trapezoidal matrix",
   "[ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means",
   "of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal",
   "matrix and, R and A1 are M-by-M upper triangular matrices."],
 "sgels"=>
  ["SGELS solves overdetermined or underdetermined real linear systems",
   "involving an M-by-N matrix A, or its transpose, using a QR or LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'T' and m >= n:  find the minimum norm solution of",
   "   an underdetermined system A**T * X = B.",
   "4. If TRANS = 'T' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "zsysvx"=>
  ["ZSYSVX uses the diagonal pivoting factorization to compute the",
   "solution to a complex system of linear equations A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "ssyequb"=>
  ["SSYEQUB computes row and column scalings intended to equilibrate a",
   "symmetric matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "chgeqz"=>
  ["CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),",
   "where H is an upper Hessenberg matrix and T is upper triangular,",
   "using the single-shift QZ method.",
   "Matrix pairs of this type are produced by the reduction to",
   "generalized upper Hessenberg form of a complex matrix pair (A,B):",
   "   A = Q1*H*Z1**H,  B = Q1*T*Z1**H,",
   "as computed by CGGHRD.",
   "If JOB='S', then the Hessenberg-triangular pair (H,T) is",
   "also reduced to generalized Schur form,",
   "   H = Q*S*Z**H,  T = Q*P*Z**H,",
   "where Q and Z are unitary matrices and S and P are upper triangular.",
   "Optionally, the unitary matrix Q from the generalized Schur",
   "factorization may be postmultiplied into an input matrix Q1, and the",
   "unitary matrix Z may be postmultiplied into an input matrix Z1.",
   "If Q1 and Z1 are the unitary matrices from CGGHRD that reduced",
   "the matrix pair (A,B) to generalized Hessenberg form, then the output",
   "matrices Q1*Q and Z1*Z are the unitary factors from the generalized",
   "Schur factorization of (A,B):",
   "   A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.",
   "To avoid overflow, eigenvalues of the matrix pair (H,T)",
   "(equivalently, of (A,B)) are computed as a pair of complex values",
   "(alpha,beta).  If beta is nonzero, lambda = alpha / beta is an",
   "eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)",
   "   A*x = lambda*B*x",
   "and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the",
   "alternate form of the GNEP",
   "   mu*A*y = B*y.",
   "The values of alpha and beta for the i-th eigenvalue can be read",
   "directly from the generalized Schur form:  alpha = S(i,i),",
   "beta = P(i,i).",
   "Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix",
   "     Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),",
   "     pp. 241--256."],
 "slabad"=>
  ["SLABAD takes as input the values computed by SLAMCH for underflow and",
   "overflow, and returns the square root of each of these values if the",
   "log of LARGE is sufficiently large.  This subroutine is intended to",
   "identify machines with a large exponent range, such as the Crays, and",
   "redefine the underflow and overflow limits to be the square roots of",
   "the values computed by SLAMCH.  This subroutine is needed because",
   "SLAMCH does not compensate for poor arithmetic in the upper half of",
   "the exponent range, as is found on a Cray."],
 "cgels"=>
  ["CGELS solves overdetermined or underdetermined complex linear systems",
   "involving an M-by-N matrix A, or its conjugate-transpose, using a QR",
   "or LQ factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'C' and m >= n:  find the minimum norm solution of",
   "   an underdetermined system A**H * X = B.",
   "4. If TRANS = 'C' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**H * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "dsytrd_2stage"=>
  ["DSYTRD_2STAGE reduces a real symmetric matrix A to real symmetric",
   "tridiagonal form T by a orthogonal similarity transformation:",
   "Q1**T Q2**T* A * Q2 * Q1 = T."],
 "dla_gerpvgrw"=>
  ["DLA_GERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "zgemqrt"=>
  ["ZGEMQRT overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'C':    Q**H C            C Q**H",
   "where Q is a complex orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**H",
   "generated using the compact WY representation as returned by ZGEQRT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "stgex2"=>
  ["STGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)",
   "of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair",
   "(A, B) by an orthogonal equivalence transformation.",
   "(A, B) must be in generalized real Schur canonical form (as returned",
   "by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2",
   "diagonal blocks. B is upper triangular.",
   "Optionally, the matrices Q and Z of generalized Schur vectors are",
   "updated.",
   "       Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T",
   "       Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T"],
 "dsfrk"=>
  ["Level 3 BLAS like routine for C in RFP Format.",
   "DSFRK performs one of the symmetric rank--k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where alpha and beta are real scalars, C is an n--by--n symmetric",
   "matrix and A is an n--by--k matrix in the first case and a k--by--n",
   "matrix in the second case."],
 "dsygv"=>
  ["DSYGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric and B is also",
   "positive definite."],
 "dlag2s"=>
  ["DLAG2S converts a DOUBLE PRECISION matrix, SA, to a SINGLE",
   "PRECISION matrix, A.",
   "RMAX is the overflow for the SINGLE PRECISION arithmetic",
   "DLAG2S checks that all the entries of A are between -RMAX and",
   "RMAX. If not the conversion is aborted and a flag is raised.",
   "This is an auxiliary routine so there is no argument checking."],
 "clacgv"=>["CLACGV conjugates a complex vector of length N."],
 "clamswlq"=>
  ["   CLAMQRTS overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product of blocked",
   "   elementary reflectors computed by short wide LQ",
   "   factorization (CLASWLQ)"],
 "dsytf2_rook"=>
  ["DSYTF2_ROOK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "ilazlr"=>["ILAZLR scans A for its last non-zero row."],
 "clatps"=>
  ["CLATPS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular matrix stored in packed form.  Here A**T denotes the",
   "transpose of A, A**H denotes the conjugate transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine CTPSV is called. If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "claqsb"=>
  ["CLAQSB equilibrates a symmetric band matrix A using the scaling",
   "factors in the vector S."],
 "stpttf"=>
  ["STPTTF copies a triangular matrix A from standard packed format (TP)",
   "to rectangular full packed format (TF)."],
 "cgttrs"=>
  ["CGTTRS solves one of the systems of equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by CGTTRF."],
 "ssysv_aa"=>
  ["SSYSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**T,  if UPLO = 'U', or",
   "   A = L * T * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is symmetric tridiagonal. The factored",
   "form of A is then used to solve the system of equations A * X = B."],
 "slarfx"=>
  ["SLARFX applies a real elementary reflector H to a real m by n",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix",
   "This version uses inline code if H has order < 11."],
 "cla_lin_berr"=>
  ["   CLA_LIN_BERR computes componentwise relative backward error from",
   "   the formula",
   "       max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )",
   "   where abs(Z) is the componentwise absolute value of the matrix",
   "   or vector Z."],
 "slaqps"=>
  ["SLAQPS computes a step of QR factorization with column pivoting",
   "of a real M-by-N matrix A by using Blas-3.  It tries to factorize",
   "NB columns from A starting from the row OFFSET+1, and updates all",
   "of the matrix with Blas-3 xGEMM.",
   "In some cases, due to catastrophic cancellations, it cannot",
   "factorize NB columns.  Hence, the actual number of factorized",
   "columns is returned in KB.",
   "Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "dpptrs"=>
  ["DPPTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A in packed storage using the Cholesky",
   "factorization A = U**T*U or A = L*L**T computed by DPPTRF."],
 "cla_heamv"=>
  ["CLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "ctftri"=>
  ["CTFTRI computes the inverse of a triangular matrix A stored in RFP",
   "format.",
   "This is a Level 3 BLAS version of the algorithm."],
 "zlatrz"=>
  ["ZLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix",
   "[ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means",
   "of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary",
   "matrix and, R and A1 are M-by-M upper triangular matrices."],
 "zlaqr5"=>
  ["   ZLAQR5, called by ZLAQR0, performs a",
   "   single small-bulge multi-shift QR sweep."],
 "slaruv"=>
  ["SLARUV returns a vector of n random real numbers from a uniform (0,1)",
   "distribution (n <= 128).",
   "This is an auxiliary routine called by SLARNV and CLARNV."],
 "dgbrfsx"=>
  ["   DGBRFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "dgbrfs"=>
  ["DGBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is banded, and provides",
   "error bounds and backward error estimates for the solution."],
 "dsytd2"=>
  ["DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal",
   "form T by an orthogonal similarity transformation: Q**T * A * Q = T."],
 "dormbr"=>
  ["If VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      P * C          C * P",
   "TRANS = 'T':      P**T * C       C * P**T",
   "Here Q and P**T are the orthogonal matrices determined by DGEBRD when",
   "reducing a real matrix A to bidiagonal form: A = Q * B * P**T. Q and",
   "P**T are defined as products of elementary reflectors H(i) and G(i)",
   "respectively.",
   "Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the",
   "order of the orthogonal matrix Q or P**T that is applied.",
   "If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:",
   "if nq >= k, Q = H(1) H(2) . . . H(k);",
   "if nq < k, Q = H(1) H(2) . . . H(nq-1).",
   "If VECT = 'P', A is assumed to have been a K-by-NQ matrix:",
   "if k < nq, P = G(1) G(2) . . . G(k);",
   "if k >= nq, P = G(1) G(2) . . . G(nq-1)."],
 "sla_gerpvgrw"=>
  ["SLA_GERPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "cgbsvxx"=>
  ["   CGBSVXX uses the LU factorization to compute the solution to a",
   "   complex system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. CGBSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   CGBSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   CGBSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what CGBSVXX would itself produce."],
 "zgeevx"=>
  ["ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues",
   "(RCONDE), and reciprocal condition numbers for the right",
   "eigenvectors (RCONDV).",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real.",
   "Balancing a matrix means permuting the rows and columns to make it",
   "more nearly upper triangular, and applying a diagonal similarity",
   "transformation D * A * D**(-1), where D is a diagonal matrix, to",
   "make its rows and columns closer in norm and the condition numbers",
   "of its eigenvalues and eigenvectors smaller.  The computed",
   "reciprocal condition numbers correspond to the balanced matrix.",
   "Permuting rows and columns will not change the condition numbers",
   "(in exact arithmetic) but diagonal scaling will.  For further",
   "explanation of balancing, see section 4.10.2 of the LAPACK",
   "Users' Guide."],
 "cposvx"=>
  ["CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zhetrd_he2hb"=>
  ["ZHETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian",
   "band-diagonal form AB by a unitary similarity transformation:",
   "Q**H * A * Q = AB."],
 "zunghr"=>
  ["ZUNGHR generates a complex unitary matrix Q which is defined as the",
   "product of IHI-ILO elementary reflectors of order N, as returned by",
   "ZGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "ssytrf"=>
  ["SSYTRF computes the factorization of a real symmetric matrix A using",
   "the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "ctpttf"=>
  ["CTPTTF copies a triangular matrix A from standard packed format (TP)",
   "to rectangular full packed format (TF)."],
 "dlaqr2"=>
  ["   DLAQR2 is identical to DLAQR3 except that it avoids",
   "   recursion by calling DLAHQR instead of DLAQR4.",
   "   Aggressive early deflation:",
   "   This subroutine accepts as input an upper Hessenberg matrix",
   "   H and performs an orthogonal similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an orthogonal similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "ztfttr"=>
  ["ZTFTTR copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard full format (TR)."],
 "cggesx"=>
  ["CGGESX computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the complex Schur form (S,T),",
   "and, optionally, the left and/or right matrices of Schur vectors (VSL",
   "and VSR).  This gives the generalized Schur factorization",
   "     (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T; computes",
   "a reciprocal condition number for the average of the selected",
   "eigenvalues (RCONDE); and computes a reciprocal condition number for",
   "the right and left deflating subspaces corresponding to the selected",
   "eigenvalues (RCONDV). The leading columns of VSL and VSR then form",
   "an orthonormal basis for the corresponding left and right eigenspaces",
   "(deflating subspaces).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if T is",
   "upper triangular with non-negative diagonal and S is upper",
   "triangular."],
 "dorbdb4"=>[],
 "ssygs2"=>
  ["SSYGS2 reduces a real symmetric-definite generalized eigenproblem",
   "to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T *A*L.",
   "B must have been previously factorized as U**T *U or L*L**T by SPOTRF."],
 "sggbal"=>
  ["SGGBAL balances a pair of general real matrices (A,B).  This",
   "involves, first, permuting A and B by similarity transformations to",
   "isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N",
   "elements on the diagonal; and second, applying a diagonal similarity",
   "transformation to rows and columns ILO to IHI to make the rows",
   "and columns as close in norm as possible. Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrices, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors in the",
   "generalized eigenvalue problem A*x = lambda*B*x."],
 "ssbgvx"=>
  ["SSBGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric",
   "and banded, and B is also positive definite.  Eigenvalues and",
   "eigenvectors can be selected by specifying either all eigenvalues,",
   "a range of values or a range of indices for the desired eigenvalues."],
 "sspsvx"=>
  ["SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or",
   "A = L*D*L**T to compute the solution to a real system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "sla_gbrfsx_extended"=>
  ["SLA_GBRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by SGBRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "csprfs"=>
  ["CSPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "zlags2"=>
  ["ZLAGS2 computes 2-by-2 unitary matrices U, V and Q, such",
   "that if ( UPPER ) then",
   "          U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )",
   "                            ( 0  A3 )     ( x  x  )",
   "and",
   "          V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )",
   "                           ( 0  B3 )     ( x  x  )",
   "or if ( .NOT.UPPER ) then",
   "          U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )",
   "                            ( A2 A3 )     ( 0  x  )",
   "and",
   "          V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )",
   "                            ( B2 B3 )     ( 0  x  )",
   "where",
   "  U = (   CSU    SNU ), V = (  CSV    SNV ),",
   "      ( -SNU**H  CSU )      ( -SNV**H CSV )",
   "  Q = (   CSQ    SNQ )",
   "      ( -SNQ**H  CSQ )",
   "The rows of the transformed A and B are parallel. Moreover, if the",
   "input 2-by-2 matrix A is not zero, then the transformed (1,1) entry",
   "of A is not zero. If the input matrices A and B are both not zero,",
   "then the transformed (2,2) element of B is not zero, except when the",
   "first rows of input A and B are parallel and the second rows are",
   "zero."],
 "zlansb"=>
  ["ZLANSB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n symmetric band matrix A,  with k super-diagonals.",
   "   ZLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dsygst"=>
  ["DSYGST reduces a real symmetric-definite generalized eigenproblem",
   "to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.",
   "B must have been previously factorized as U**T*U or L*L**T by DPOTRF."],
 "zlaqhb"=>
  ["ZLAQHB equilibrates a Hermitian band matrix A",
   "using the scaling factors in the vector S."],
 "zlaed0"=>
  ["Using the divide and conquer method, ZLAED0 computes all eigenvalues",
   "of a symmetric tridiagonal matrix which is one diagonal block of",
   "those from reducing a dense or band Hermitian matrix and",
   "corresponding eigenvectors of the dense or band matrix."],
 "dtrtrs"=>
  ["DTRTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular matrix of order N, and B is an N-by-NRHS",
   "matrix.  A check is made to verify that A is nonsingular."],
 "spoequb"=>
  ["SPOEQUB computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings.",
   "This routine differs from SPOEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled diagonal entries are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "dsycon_3"=>
  ["DSYCON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "computed by DSYTRF_RK or DSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver DSYTRS_3."],
 "zhetf2_rk"=>
  ["ZHETF2_RK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "zppcon"=>
  ["ZPPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite packed matrix using",
   "the Cholesky factorization A = U**H*U or A = L*L**H computed by",
   "ZPPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cpteqr"=>
  ["CPTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric positive definite tridiagonal matrix by first factoring the",
   "matrix using SPTTRF and then calling CBDSQR to compute the singular",
   "values of the bidiagonal factor.",
   "This routine computes the eigenvalues of the positive definite",
   "tridiagonal matrix to high relative accuracy.  This means that if the",
   "eigenvalues range over many orders of magnitude in size, then the",
   "small eigenvalues and corresponding eigenvectors will be computed",
   "more accurately than, for example, with the standard QR method.",
   "The eigenvectors of a full or band positive definite Hermitian matrix",
   "can also be found if CHETRD, CHPTRD, or CHBTRD has been used to",
   "reduce this matrix to tridiagonal form.  (The reduction to",
   "tridiagonal form, however, may preclude the possibility of obtaining",
   "high relative accuracy in the small eigenvalues of the original",
   "matrix, if these eigenvalues range over many orders of magnitude.)"],
 "cpptrf"=>
  ["CPPTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A stored in packed format.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "cla_syamv"=>
  ["CLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "cla_gbamv"=>
  ["CLA_GBAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "zgesdd"=>
  ["ZGESDD computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors, by using divide-and-conquer method. The SVD is written",
   "     A = U * SIGMA * conjugate-transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   "V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns VT = V**H, not V.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "slatdf"=>
  ["SLATDF uses the LU factorization of the n-by-n matrix Z computed by",
   "SGETC2 and computes a contribution to the reciprocal Dif-estimate",
   "by solving Z * x = b for x, and choosing the r.h.s. b such that",
   "the norm of x is as large as possible. On entry RHS = b holds the",
   "contribution from earlier solved sub-systems, and on return RHS = x.",
   "The factorization of Z returned by SGETC2 has the form Z = P*L*U*Q,",
   "where P and Q are permutation matrices. L is lower triangular with",
   "unit diagonal elements and U is upper triangular."],
 "dla_gbamv"=>
  ["DLA_GBAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dsyevr_2stage"=>
  ["DSYEVR_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "DSYEVR_2STAGE first reduces the matrix A to tridiagonal form T with a call",
   "to DSYTRD.  Then, whenever possible, DSYEVR_2STAGE calls DSTEMR to compute",
   "the eigenspectrum using Relatively Robust Representations.  DSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : DSYEVR_2STAGE calls DSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "DSYEVR_2STAGE calls DSTEBZ and SSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of DSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "slasq4"=>
  ["SLASQ4 computes an approximation TAU to the smallest eigenvalue",
   "using values of d from the previous transform."],
 "dlacpy"=>
  ["DLACPY copies all or part of a two-dimensional matrix A to another",
   "matrix B."],
 "zbdsqr"=>
  ["ZBDSQR computes the singular values and, optionally, the right and/or",
   "left singular vectors from the singular value decomposition (SVD) of",
   "a real N-by-N (upper or lower) bidiagonal matrix B using the implicit",
   "zero-shift QR algorithm.  The SVD of B has the form",
   "   B = Q * S * P**H",
   "where S is the diagonal matrix of singular values, Q is an orthogonal",
   "matrix of left singular vectors, and P is an orthogonal matrix of",
   "right singular vectors.  If left singular vectors are requested, this",
   "subroutine actually returns U*Q instead of Q, and, if right singular",
   "vectors are requested, this subroutine returns P**H*VT instead of",
   "P**H, for given complex input matrices U and VT.  When U and VT are",
   "the unitary matrices that reduce a general matrix A to bidiagonal",
   "form: A = U*B*VT, as computed by ZGEBRD, then",
   "   A = (U*Q) * S * (P**H*VT)",
   "is the SVD of A.  Optionally, the subroutine may also compute Q**H*C",
   "for a given complex input matrix C.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,",
   "no. 5, pp. 873-912, Sept 1990) and",
   "\"Accurate singular values and differential qd algorithms,\" by",
   "B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics",
   "Department, University of California at Berkeley, July 1992",
   "for a detailed description of the algorithm."],
 "sgebd2"=>
  ["SGEBD2 reduces a real general m by n matrix A to upper or lower",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "dlacon"=>
  ["DLACON estimates the 1-norm of a square, real matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "strtri"=>
  ["STRTRI computes the inverse of a real upper or lower triangular",
   "matrix A.",
   "This is the Level 3 BLAS version of the algorithm."],
 "dorbdb"=>
  ["DORBDB simultaneously bidiagonalizes the blocks of an M-by-M",
   "partitioned orthogonal matrix X:",
   "                                [ B11 | B12 0  0 ]",
   "    [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**T",
   "X = [-----------] = [---------] [----------------] [---------]   .",
   "    [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]",
   "                                [  0  |  0  0  I ]",
   "X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is",
   "not the case, then X must be transposed and/or permuted. This can be",
   "done in constant time using the TRANS and SIGNS options. See DORCSD",
   "for details.)",
   "The orthogonal matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-",
   "(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are",
   "represented implicitly by Householder vectors.",
   "B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented",
   "implicitly by angles THETA, PHI."],
 "slatrs"=>
  ["SLATRS solves one of the triangular systems",
   "   A *x = s*b  or  A**T*x = s*b",
   "with scaling to prevent overflow.  Here A is an upper or lower",
   "triangular matrix, A**T denotes the transpose of A, x and b are",
   "n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine STRSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "slanv2"=>
  ["SLANV2 computes the Schur factorization of a real 2-by-2 nonsymmetric",
   "matrix in standard form:",
   "     [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]",
   "     [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]",
   "where either",
   "1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or",
   "2) AA = DD and BB*CC < 0, so that AA + or - sqrt(BB*CC) are complex",
   "conjugate eigenvalues."],
 "dgelsd"=>
  ["DGELSD computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize 2-norm(| b - A*x |)",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The problem is solved in three steps:",
   "(1) Reduce the coefficient matrix A to bidiagonal form with",
   "    Householder transformations, reducing the original problem",
   "    into a \"bidiagonal least squares problem\" (BLS)",
   "(2) Solve the BLS using a divide and conquer approach.",
   "(3) Apply back all the Householder transformations to solve",
   "    the original least squares problem.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "ssptrf"=>
  ["SSPTRF computes the factorization of a real symmetric matrix A stored",
   "in packed format using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "dlaed4"=>
  ["This subroutine computes the I-th updated eigenvalue of a symmetric",
   "rank-one modification to a diagonal matrix whose elements are",
   "given in the array d, and that",
   "           D(i) < D(j)  for  i < j",
   "and that RHO > 0.  This is arranged by the calling routine, and is",
   "no loss in generality.  The rank-one modified system is thus",
   "           diag( D )  +  RHO * Z * Z_transpose.",
   "where we assume the Euclidean norm of Z is 1.",
   "The method consists of approximating the rational functions in the",
   "secular equation by simpler interpolating rational functions."],
 "zlasyf_rook"=>
  ["ZLASYF_ROOK computes a partial factorization of a complex symmetric",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "ZLASYF_ROOK is an auxiliary routine called by ZSYTRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "zhpgvd"=>
  ["ZHPGVD computes all the eigenvalues and, optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian, stored in packed format, and B is also",
   "positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cgelqt"=>
  ["CGELQT computes a blocked LQ factorization of a complex M-by-N matrix A",
   "using the compact WY representation of Q."],
 "ssyconvf"=>
  ["If parameter WAY = 'C':",
   "SSYCONVF converts the factorization output format used in",
   "SSYTRF provided on entry in parameter A into the factorization",
   "output format used in SSYTRF_RK (or SSYTRF_BK) that is stored",
   "on exit in parameters A and E. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in SSYTRF into",
   "the format used in SSYTRF_RK (or SSYTRF_BK).",
   "If parameter WAY = 'R':",
   "SSYCONVF performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in SSYTRF_RK",
   "(or SSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in SSYTRF that is stored",
   "on exit in parameter A. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in SSYTRF_RK",
   "(or SSYTRF_BK) into the format used in SSYTRF."],
 "dgelsy"=>
  ["DGELSY computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize || A * X - B ||",
   "using a complete orthogonal factorization of A.  A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The routine first computes a QR factorization with column pivoting:",
   "    A * P = Q * [ R11 R12 ]",
   "                [  0  R22 ]",
   "with R11 defined as the largest leading submatrix whose estimated",
   "condition number is less than 1/RCOND.  The order of R11, RANK,",
   "is the effective rank of A.",
   "Then, R22 is considered to be negligible, and R12 is annihilated",
   "by orthogonal transformations from the right, arriving at the",
   "complete orthogonal factorization:",
   "   A * P = Q * [ T11 0 ] * Z",
   "               [  0  0 ]",
   "The minimum-norm solution is then",
   "   X = P * Z**T [ inv(T11)*Q1**T*B ]",
   "                [        0         ]",
   "where Q1 consists of the first RANK columns of Q.",
   "This routine is basically identical to the original xGELSX except",
   "three differences:",
   "  o The call to the subroutine xGEQPF has been substituted by the",
   "    the call to the subroutine xGEQP3. This subroutine is a Blas-3",
   "    version of the QR factorization with column pivoting.",
   "  o Matrix B (the right hand side) is updated with Blas-3.",
   "  o The permutation of matrix B (the right hand side) is faster and",
   "    more simple."],
 "sopgtr"=>
  ["SOPGTR generates a real orthogonal matrix Q which is defined as the",
   "product of n-1 elementary reflectors H(i) of order n, as returned by",
   "SSPTRD using packed storage:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "dlansf"=>
  ["DLANSF returns the value of the one norm, or the Frobenius norm, or",
   "the infinity norm, or the element of largest absolute value of a",
   "real symmetric matrix A in RFP format.",
   "   DLANSF = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm."],
 "dggevx"=>
  ["DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for",
   "the eigenvalues (RCONDE), and reciprocal condition numbers for the",
   "right eigenvectors (RCONDV).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j) .",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B.",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "cgbcon"=>
  ["CGBCON estimates the reciprocal of the condition number of a complex",
   "general band matrix A, in either the 1-norm or the infinity-norm,",
   "using the LU factorization computed by CGBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "zgees"=>
  ["ZGEES computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues, the Schur form T, and, optionally, the matrix of Schur",
   "vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "Schur form so that selected eigenvalues are at the top left.",
   "The leading columns of Z then form an orthonormal basis for the",
   "invariant subspace corresponding to the selected eigenvalues.",
   "A complex matrix is in Schur form if it is upper triangular."],
 "clantr"=>
  ["CLANTR  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "trapezoidal or triangular matrix A.",
   "   CLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cpoequb"=>
  ["CPOEQUB computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings.",
   "This routine differs from CPOEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled diagonal entries are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "cla_syrpvgrw"=>
  ["CLA_SYRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "cpotri"=>
  ["CPOTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by CPOTRF."],
 "slarft"=>
  ["SLARFT forms the triangular factor T of a real block reflector H",
   "of order n, which is defined as a product of k elementary reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**T",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**T * T * V"],
 "dlabrd"=>
  ["DLABRD reduces the first NB rows and columns of a real general",
   "m by n matrix A to upper or lower bidiagonal form by an orthogonal",
   "transformation Q**T * A * P, and returns the matrices X and Y which",
   "are needed to apply the transformation to the unreduced part of A.",
   "If m >= n, A is reduced to upper bidiagonal form; if m < n, to lower",
   "bidiagonal form.",
   "This is an auxiliary routine called by DGEBRD"],
 "dlatrs"=>
  ["DLATRS solves one of the triangular systems",
   "   A *x = s*b  or  A**T *x = s*b",
   "with scaling to prevent overflow.  Here A is an upper or lower",
   "triangular matrix, A**T denotes the transpose of A, x and b are",
   "n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "zsyrfsx"=>
  ["   ZSYRFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "clatbs"=>
  ["CLATBS solves one of the triangular systems",
   "   A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular band matrix.  Here A**T denotes the transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine CTBSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "spbsv"=>
  ["SPBSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular band matrix, and L is a lower",
   "triangular band matrix, with the same number of superdiagonals or",
   "subdiagonals as A.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "chetri2"=>
  ["CHETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "CHETRF. CHETRI2 set the LEADING DIMENSION of the workspace",
   "before calling CHETRI2X that actually computes the inverse."],
 "dsytrs2"=>
  ["DSYTRS2 solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by DSYTRF and converted by DSYCONV."],
 "csysv_aa"=>
  ["CSYSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**T,  if UPLO = 'U', or",
   "   A = L * T * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is symmetric tridiagonal. The factored",
   "form of A is then used to solve the system of equations A * X = B."],
 "dtrsen"=>
  ["DTRSEN reorders the real Schur factorization of a real matrix",
   "A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in",
   "the leading diagonal blocks of the upper quasi-triangular matrix T,",
   "and the leading columns of Q form an orthonormal basis of the",
   "corresponding right invariant subspace.",
   "Optionally the routine computes the reciprocal condition numbers of",
   "the cluster of eigenvalues and/or the invariant subspace.",
   "T must be in Schur canonical form (as returned by DHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "ztprfs"=>
  ["ZTPRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular packed",
   "coefficient matrix.",
   "The solution matrix X must be computed by ZTPTRS or some other",
   "means before entering this routine.  ZTPRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "slasda"=>
  ["Using a divide and conquer approach, SLASDA computes the singular",
   "value decomposition (SVD) of a real upper bidiagonal N-by-M matrix",
   "B with diagonal D and offdiagonal E, where M = N + SQRE. The",
   "algorithm computes the singular values in the SVD B = U * S * VT.",
   "The orthogonal matrices U and VT are optionally computed in",
   "compact form.",
   "A related subroutine, SLASD0, computes the singular values and",
   "the singular vectors in explicit form."],
 "zlahr2"=>
  ["ZLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)",
   "matrix A so that elements below the k-th subdiagonal are zero. The",
   "reduction is performed by an unitary similarity transformation",
   "Q**H * A * Q. The routine returns the matrices V and T which determine",
   "Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.",
   "This is an auxiliary routine called by ZGEHRD."],
 "sggesx"=>
  ["SGGESX computes for a pair of N-by-N real nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the real Schur form (S,T), and,",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR).  This gives the generalized Schur factorization",
   "     (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T; computes",
   "a reciprocal condition number for the average of the selected",
   "eigenvalues (RCONDE); and computes a reciprocal condition number for",
   "the right and left deflating subspaces corresponding to the selected",
   "eigenvalues (RCONDV). The leading columns of VSL and VSR then form",
   "an orthonormal basis for the corresponding left and right eigenspaces",
   "(deflating subspaces).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or for both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "zgtsvx"=>
  ["ZGTSVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a tridiagonal matrix of order N and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "clarfx"=>
  ["CLARFX applies a complex elementary reflector H to a complex m by n",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix",
   "This version uses inline code if H has order < 11."],
 "slarf"=>
  ["SLARF applies a real elementary reflector H to a real m by n matrix",
   "C, from either the left or the right. H is represented in the form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix."],
 "zungl2"=>
  ["ZUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,",
   "which is defined as the first m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(k)**H . . . H(2)**H H(1)**H",
   "as returned by ZGELQF."],
 "dstemr"=>
  ["DSTEMR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "Depending on the number of desired eigenvalues, these are computed either",
   "by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are",
   "computed by the use of various suitable L D L^T factorizations near clusters",
   "of close eigenvalues (referred to as RRRs, Relatively Robust",
   "Representations). An informal sketch of the algorithm follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "For more details, see:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Further Details",
   "1.DSTEMR works only on machines which follow IEEE-754",
   "floating-point standard in their handling of infinities and NaNs.",
   "This permits the use of efficient inner loops avoiding a check for",
   "zero divisors."],
 "csytrs_aa"=>
  ["CSYTRS_AA solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A using the factorization A = U*T*U**T or",
   "A = L*T*L**T computed by CSYTRF_AA."],
 "cheevx"=>
  ["CHEEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "sgtcon"=>
  ["SGTCON estimates the reciprocal of the condition number of a real",
   "tridiagonal matrix A using the LU factorization as computed by",
   "SGTTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "ssycon_3"=>
  ["SSYCON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "computed by DSYTRF_RK or DSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver SSYTRS_3."],
 "slals0"=>
  ["SLALS0 applies back the multiplying factors of either the left or the",
   "right singular vector matrix of a diagonal matrix appended by a row",
   "to the right hand side matrix B in solving the least squares problem",
   "using the divide-and-conquer SVD approach.",
   "For the left singular vector matrix, three types of orthogonal",
   "matrices are involved:",
   "(1L) Givens rotations: the number of such rotations is GIVPTR; the",
   "     pairs of columns/rows they were applied to are stored in GIVCOL;",
   "     and the C- and S-values of these rotations are stored in GIVNUM.",
   "(2L) Permutation. The (NL+1)-st row of B is to be moved to the first",
   "     row, and for J=2:N, PERM(J)-th row of B is to be moved to the",
   "     J-th row.",
   "(3L) The left singular vector matrix of the remaining matrix.",
   "For the right singular vector matrix, four types of orthogonal",
   "matrices are involved:",
   "(1R) The right singular vector matrix of the remaining matrix.",
   "(2R) If SQRE = 1, one extra Givens rotation to generate the right",
   "     null space.",
   "(3R) The inverse transformation of (2L).",
   "(4R) The inverse transformation of (1L)."],
 "slarrv"=>
  ["SLARRV computes the eigenvectors of the tridiagonal matrix",
   "T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.",
   "The input eigenvalues should have been computed by SLARRE."],
 "cla_herfsx_extended"=>
  ["CLA_HERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by CHERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "sormtr"=>
  ["SORMTR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by SSYTRD:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "dpbsv"=>
  ["DPBSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular band matrix, and L is a lower",
   "triangular band matrix, with the same number of superdiagonals or",
   "subdiagonals as A.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "dlaswp"=>
  ["DLASWP performs a series of row interchanges on the matrix A.",
   "One row interchange is initiated for each of rows K1 through K2 of A."],
 "dorgtr"=>
  ["DORGTR generates a real orthogonal matrix Q which is defined as the",
   "product of n-1 elementary reflectors of order N, as returned by",
   "DSYTRD:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "dsptri"=>
  ["DSPTRI computes the inverse of a real symmetric indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by DSPTRF."],
 "dsyevd"=>
  ["DSYEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A. If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.",
   "Because of large use of BLAS of level 3, DSYEVD needs N**2 more",
   "workspace than DSYEVX."],
 "dptts2"=>
  ["DPTTS2 solves a tridiagonal system of the form",
   "   A * X = B",
   "using the L*D*L**T factorization of A computed by DPTTRF.  D is a",
   "diagonal matrix specified in the vector D, L is a unit bidiagonal",
   "matrix whose subdiagonal is specified in the vector E, and X and B",
   "are N by NRHS matrices."],
 "lsamen"=>
  ["LSAMEN  tests if the first N letters of CA are the same as the",
   "first N letters of CB, regardless of case.",
   "LSAMEN returns .TRUE. if CA and CB are equivalent except for case",
   "and .FALSE. otherwise.  LSAMEN also returns .FALSE. if LEN( CA )",
   "or LEN( CB ) is less than N."],
 "ssterf"=>
  ["SSTERF computes all eigenvalues of a symmetric tridiagonal matrix",
   "using the Pal-Walker-Kahan variant of the QL or QR algorithm."],
 "zgbtrf"=>
  ["ZGBTRF computes an LU factorization of a complex m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "cgsvj1"=>
  ["CGSVJ1 is called from CGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as CGESVJ does, but",
   "it targets only particular pivots and it does not check convergence",
   "(stopping criterion). Few tunning parameters (marked by [TP]) are",
   "available for the implementer.",
   "Further Details",
   "~~~~~~~~~~~~~~~",
   "CGSVJ1 applies few sweeps of Jacobi rotations in the column space of",
   "the input M-by-N matrix A. The pivot pairs are taken from the (1,2)",
   "off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The",
   "block-entries (tiles) of the (1,2) off-diagonal block are marked by the",
   "[x]'s in the following scheme:",
   "   | *  *  * [x] [x] [x]|",
   "   | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.",
   "   | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "In terms of the columns of A, the first N1 columns are rotated 'against'",
   "the remaining N-N1 columns, trying to increase the angle between the",
   "corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is",
   "tiled using quadratic tiles of side KBL. Here, KBL is a tunning parmeter.",
   "The number of sweeps is given in NSWEEP and the orthogonality threshold",
   "is given in TOL."],
 "dtpmlqt"=>
  ["DTPMQRT applies a real orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "ctrtrs"=>
  ["CTRTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular matrix of order N, and B is an N-by-NRHS",
   "matrix.  A check is made to verify that A is nonsingular."],
 "spbstf"=>
  ["SPBSTF computes a split Cholesky factorization of a real",
   "symmetric positive definite band matrix A.",
   "This routine is designed to be used in conjunction with SSBGST.",
   "The factorization has the form  A = S**T*S  where S is a band matrix",
   "of the same bandwidth as A and the following structure:",
   "  S = ( U    )",
   "      ( M  L )",
   "where U is upper triangular of order m = (n+kd)/2, and L is lower",
   "triangular of order n-m."],
 "ztbrfs"=>
  ["ZTBRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular band",
   "coefficient matrix.",
   "The solution matrix X must be computed by ZTBTRS or some other",
   "means before entering this routine.  ZTBRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "chegv"=>
  ["CHEGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian and B is also",
   "positive definite."],
 "slaed5"=>
  ["This subroutine computes the I-th eigenvalue of a symmetric rank-one",
   "modification of a 2-by-2 diagonal matrix",
   "           diag( D )  +  RHO * Z * transpose(Z) .",
   "The diagonal elements in the array D are assumed to satisfy",
   "           D(i) < D(j)  for  i < j .",
   "We also assume RHO > 0 and that the Euclidean norm of the vector",
   "Z is one."],
 "clahr2"=>
  ["CLAHR2 reduces the first NB columns of A complex general n-BY-(n-k+1)",
   "matrix A so that elements below the k-th subdiagonal are zero. The",
   "reduction is performed by an unitary similarity transformation",
   "Q**H * A * Q. The routine returns the matrices V and T which determine",
   "Q as a block reflector I - V*T*v**H, and also the matrix Y = A * V * T.",
   "This is an auxiliary routine called by CGEHRD."],
 "dgghrd"=>
  ["DGGHRD reduces a pair of real matrices (A,B) to generalized upper",
   "Hessenberg form using orthogonal transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the orthogonal matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**T*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**T*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**T*x.",
   "The orthogonal matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T",
   "     Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T",
   "If Q1 is the orthogonal matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then DGGHRD reduces the original",
   "problem to generalized Hessenberg form."],
 "zptts2"=>
  ["ZPTTS2 solves a tridiagonal system of the form",
   "   A * X = B",
   "using the factorization A = U**H *D*U or A = L*D*L**H computed by ZPTTRF.",
   "D is a diagonal matrix specified in the vector D, U (or L) is a unit",
   "bidiagonal matrix whose superdiagonal (subdiagonal) is specified in",
   "the vector E, and X and B are N by NRHS matrices."],
 "slaqr4"=>
  ["   SLAQR4 implements one level of recursion for SLAQR0.",
   "   It is a complete implementation of the small bulge multi-shift",
   "   QR algorithm.  It may be called by SLAQR0 and, for large enough",
   "   deflation window size, it may be called by SLAQR3.  This",
   "   subroutine is identical to SLAQR0 except that it calls SLAQR2",
   "   instead of SLAQR3.",
   "   SLAQR4 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "slassq"=>
  ["SLASSQ  returns the values  scl  and  smsq  such that",
   "   ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,",
   "where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is",
   "assumed to be non-negative and  scl  returns the value",
   "   scl = max( scale, abs( x( i ) ) ).",
   "scale and sumsq must be supplied in SCALE and SUMSQ and",
   "scl and smsq are overwritten on SCALE and SUMSQ respectively.",
   "The routine makes only one pass through the vector x."],
 "dlasd3"=>
  ["DLASD3 finds all the square roots of the roots of the secular",
   "equation, as defined by the values in D and Z.  It makes the",
   "appropriate calls to DLASD4 and then updates the singular",
   "vectors by matrix multiplication.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.",
   "DLASD3 is called from DLASD1."],
 "dgesdd"=>
  ["DGESDD computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, optionally computing the left and right singular",
   "vectors.  If singular vectors are desired, it uses a",
   "divide-and-conquer algorithm.",
   "The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   "V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns VT = V**T, not V.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dspev"=>
  ["DSPEV computes all the eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A in packed storage."],
 "spotrf2"=>
  ["SPOTRF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A using the recursive algorithm.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = n/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "The subroutine calls itself to factor A11. Update and scale A21",
   "or A12, update A22 then call itself to factor A22."],
 "sggev"=>
  ["SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j).",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B .",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "zhetrf_rk"=>
  ["ZHETRF_RK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "ssteqr"=>
  ["SSTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the implicit QL or QR method.",
   "The eigenvectors of a full or band symmetric matrix can also be found",
   "if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to",
   "tridiagonal form."],
 "dlaqp2"=>
  ["DLAQP2 computes a QR factorization with column pivoting of",
   "the block A(OFFSET+1:M,1:N).",
   "The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "stgsna"=>
  ["STGSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or eigenvectors of a matrix pair (A, B) in",
   "generalized real Schur canonical form (or of any matrix pair",
   "(Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where",
   "Z**T denotes the transpose of Z.",
   "(A, B) must be in generalized real Schur form (as returned by SGGES),",
   "i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal",
   "blocks. B is upper triangular."],
 "zunmtr"=>
  ["ZUNMTR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by ZHETRD:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "sgesvj"=>
  ["SGESVJ computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, where M >= N. The SVD of A is written as",
   "                                   [++]   [xx]   [x0]   [xx]",
   "             A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]",
   "                                   [++]   [xx]",
   "where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal",
   "matrix, and V is an N-by-N orthogonal matrix. The diagonal elements",
   "of SIGMA are the singular values of A. The columns of U and V are the",
   "left and the right singular vectors of A, respectively.",
   "SGESVJ can sometimes compute tiny singular values and their singular vectors much",
   "more accurately than other SVD routines, see below under Further Details."],
 "zsyconv"=>
  ["ZSYCONV converts A given by ZHETRF into L and D or vice-versa.",
   "Get nondiagonal elements of D (returned in workspace) and",
   "apply or reverse permutation done in TRF."],
 "slartgs"=>
  ["SLARTGS generates a plane rotation designed to introduce a bulge in",
   "Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD",
   "problem. X and Y are the top-row entries, and SIGMA is the shift.",
   "The computed CS and SN define a plane rotation satisfying",
   "   [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],",
   "   [ -SN  CS  ]     [    X * Y    ]     [ 0 ]",
   "with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the",
   "rotation is by PI/2."],
 "dlaqsb"=>
  ["DLAQSB equilibrates a symmetric band matrix A using the scaling",
   "factors in the vector S."],
 "strttp"=>
  ["STRTTP copies a triangular matrix A from full format (TR) to standard",
   "packed format (TP)."],
 "sgetf2"=>
  ["SGETF2 computes an LU factorization of a general m-by-n matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 2 BLAS version of the algorithm."],
 "dgeev"=>
  ["DGEEV computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate-transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real."],
 "slauum"=>
  ["SLAUUM computes the product U * U**T or L**T * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the blocked form of the algorithm, calling Level 3 BLAS."],
 "clanhp"=>
  ["CLANHP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex hermitian matrix A,  supplied in packed form.",
   "   CLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zsysv_rook"=>
  ["ZSYSV_ROOK computes the solution to a complex system of linear",
   "equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "ZSYTRF_ROOK is called to compute the factorization of a complex",
   "symmetric matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling ZSYTRS_ROOK."],
 "zsytf2_rk"=>
  ["ZSYTF2_RK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "dlangt"=>
  ["DLANGT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real tridiagonal matrix A.",
   "   DLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dsbgv"=>
  ["DSBGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric",
   "and banded, and B is also positive definite."],
 "slaed8"=>
  ["SLAED8 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny element in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "zla_syrcond_x"=>
  ["   ZLA_SYRCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX*16 vector."],
 "zla_syrfsx_extended"=>
  ["ZLA_SYRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by ZSYRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "ssygst"=>
  ["SSYGST reduces a real symmetric-definite generalized eigenproblem",
   "to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.",
   "B must have been previously factorized as U**T*U or L*L**T by SPOTRF."],
 "zgebd2"=>
  ["ZGEBD2 reduces a complex general m by n matrix A to upper or lower",
   "real bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "zpftri"=>
  ["ZPFTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by ZPFTRF."],
 "zsytrf_rook"=>
  ["ZSYTRF_ROOK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dgetf2"=>
  ["DGETF2 computes an LU factorization of a general m-by-n matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 2 BLAS version of the algorithm."],
 "sgerfs"=>
  ["SGERFS improves the computed solution to a system of linear",
   "equations and provides error bounds and backward error estimates for",
   "the solution."],
 "clange"=>
  ["CLANGE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex matrix A.",
   "   CLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "ddisna"=>
  ["DDISNA computes the reciprocal condition numbers for the eigenvectors",
   "of a real symmetric or complex Hermitian matrix or for the left or",
   "right singular vectors of a general m-by-n matrix. The reciprocal",
   "condition number is the 'gap' between the corresponding eigenvalue or",
   "singular value and the nearest other one.",
   "The bound on the error, measured by angle in radians, in the I-th",
   "computed vector is given by",
   "       DLAMCH( 'E' ) * ( ANORM / SEP( I ) )",
   "where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed",
   "to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of",
   "the error bound.",
   "DDISNA may also be used to compute error bounds for eigenvectors of",
   "the generalized symmetric definite eigenproblem."],
 "ztrttf"=>
  ["ZTRTTF copies a triangular matrix A from standard full format (TR)",
   "to rectangular full packed format (TF) ."],
 "cgeqrt"=>
  ["CGEQRT computes a blocked QR factorization of a complex M-by-N matrix A",
   "using the compact WY representation of Q."],
 "zsprfs"=>
  ["ZSPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "ztgsja"=>
  ["ZTGSJA computes the generalized singular value decomposition (GSVD)",
   "of two complex upper triangular (or trapezoidal) matrices A and B.",
   "On entry, it is assumed that matrices A and B have the following",
   "forms, which may be obtained by the preprocessing subroutine ZGGSVP",
   "from a general M-by-N matrix A and P-by-N matrix B:",
   "             N-K-L  K    L",
   "   A =    K ( 0    A12  A13 ) if M-K-L >= 0;",
   "          L ( 0     0   A23 )",
   "      M-K-L ( 0     0    0  )",
   "           N-K-L  K    L",
   "   A =  K ( 0    A12  A13 ) if M-K-L < 0;",
   "      M-K ( 0     0   A23 )",
   "           N-K-L  K    L",
   "   B =  L ( 0     0   B13 )",
   "      P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.",
   "On exit,",
   "       U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),",
   "where U, V and Q are unitary matrices.",
   "R is a nonsingular upper triangular matrix, and D1",
   "and D2 are ``diagonal'' matrices, which are of the following",
   "structures:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                   K  L",
   "       D2 = L   ( 0  S )",
   "            P-L ( 0  0 )",
   "               N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 ) K",
   "            L (  0    0   R22 ) L",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "               K M-K K+L-M",
   "    D1 =   K ( I  0    0   )",
   "         M-K ( 0  C    0   )",
   "                 K M-K K+L-M",
   "    D2 =   M-K ( 0  S    0   )",
   "         K+L-M ( 0  0    I   )",
   "           P-L ( 0  0    0   )",
   "               N-K-L  K   M-K  K+L-M",
   "( 0 R ) =    K ( 0    R11  R12  R13  )",
   "          M-K ( 0     0   R22  R23  )",
   "        K+L-M ( 0     0    0   R33  )",
   "where",
   "C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "S = diag( BETA(K+1),  ... , BETA(M) ),",
   "C**2 + S**2 = I.",
   "R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored",
   "    (  0  R22 R23 )",
   "in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The computation of the unitary transformation matrices U, V or Q",
   "is optional.  These matrices may either be formed explicitly, or they",
   "may be postmultiplied into input matrices U1, V1, or Q1."],
 "sgetsls"=>
  ["SGETSLS solves overdetermined or underdetermined real linear systems",
   "involving an M-by-N matrix A, using a tall skinny QR or short wide LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'T' and m >= n:  find the minimum norm solution of",
   "   an undetermined system A**T * X = B.",
   "4. If TRANS = 'T' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "zhetrf_aa"=>
  ["ZHETRF_AA computes the factorization of a complex hermitian matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**H  or  A = L*T*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a hermitian tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "ctgsja"=>
  ["CTGSJA computes the generalized singular value decomposition (GSVD)",
   "of two complex upper triangular (or trapezoidal) matrices A and B.",
   "On entry, it is assumed that matrices A and B have the following",
   "forms, which may be obtained by the preprocessing subroutine CGGSVP",
   "from a general M-by-N matrix A and P-by-N matrix B:",
   "             N-K-L  K    L",
   "   A =    K ( 0    A12  A13 ) if M-K-L >= 0;",
   "          L ( 0     0   A23 )",
   "      M-K-L ( 0     0    0  )",
   "           N-K-L  K    L",
   "   A =  K ( 0    A12  A13 ) if M-K-L < 0;",
   "      M-K ( 0     0   A23 )",
   "           N-K-L  K    L",
   "   B =  L ( 0     0   B13 )",
   "      P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.",
   "On exit,",
   "       U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),",
   "where U, V and Q are unitary matrices.",
   "R is a nonsingular upper triangular matrix, and D1",
   "and D2 are ``diagonal'' matrices, which are of the following",
   "structures:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                   K  L",
   "       D2 = L   ( 0  S )",
   "            P-L ( 0  0 )",
   "               N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 ) K",
   "            L (  0    0   R22 ) L",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "               K M-K K+L-M",
   "    D1 =   K ( I  0    0   )",
   "         M-K ( 0  C    0   )",
   "                 K M-K K+L-M",
   "    D2 =   M-K ( 0  S    0   )",
   "         K+L-M ( 0  0    I   )",
   "           P-L ( 0  0    0   )",
   "               N-K-L  K   M-K  K+L-M",
   "( 0 R ) =    K ( 0    R11  R12  R13  )",
   "          M-K ( 0     0   R22  R23  )",
   "        K+L-M ( 0     0    0   R33  )",
   "where",
   "C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "S = diag( BETA(K+1),  ... , BETA(M) ),",
   "C**2 + S**2 = I.",
   "R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored",
   "    (  0  R22 R23 )",
   "in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The computation of the unitary transformation matrices U, V or Q",
   "is optional.  These matrices may either be formed explicitly, or they",
   "may be postmultiplied into input matrices U1, V1, or Q1."],
 "ssytf2_rook"=>
  ["SSYTF2_ROOK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "slangt"=>
  ["SLANGT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real tridiagonal matrix A.",
   "   SLANGT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dlaed1"=>
  ["DLAED1 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix.  This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles",
   "the case in which eigenvalues only or eigenvalues and eigenvectors",
   "of a full symmetric matrix (which was reduced to tridiagonal form)",
   "are desired.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)",
   "   where Z = Q**T*u, u is a vector of length N with ones in the",
   "   CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine DLAED2.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine DLAED4 (as called by DLAED3).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "spoequ"=>
  ["SPOEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "dstevd"=>
  ["DSTEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric tridiagonal matrix. If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zlascl"=>
  ["ZLASCL multiplies the M by N complex matrix A by the real scalar",
   "CTO/CFROM.  This is done without over/underflow as long as the final",
   "result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that",
   "A may be full, upper triangular, lower triangular, upper Hessenberg,",
   "or banded."],
 "dpotri"=>
  ["DPOTRI computes the inverse of a real symmetric positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by DPOTRF."],
 "cgeqp3"=>
  ["CGEQP3 computes a QR factorization with column pivoting of a",
   "matrix A:  A*P = Q*R  using Level 3 BLAS."],
 "dstevr"=>
  ["DSTEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T.  Eigenvalues and",
   "eigenvectors can be selected by specifying either a range of values",
   "or a range of indices for the desired eigenvalues.",
   "Whenever possible, DSTEVR calls DSTEMR to compute the",
   "eigenspectrum using Relatively Robust Representations.  DSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows. For the i-th",
   "unreduced block of T,",
   "   (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T",
   "        is a relatively robust representation,",
   "   (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high",
   "       relative accuracy by the dqds algorithm,",
   "   (c) If there is a cluster of close eigenvalues, \"choose\" sigma_i",
   "       close to the cluster, and go to step (a),",
   "   (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,",
   "       compute the corresponding eigenvector by forming a",
   "       rank-revealing twisted factorization.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see \"A new O(n^2) algorithm for the symmetric",
   "tridiagonal eigenvalue/eigenvector problem\", by Inderjit Dhillon,",
   "Computer Science Division Technical Report No. UCB//CSD-97-971,",
   "UC Berkeley, May 1997.",
   "Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of DSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "cupgtr"=>
  ["CUPGTR generates a complex unitary matrix Q which is defined as the",
   "product of n-1 elementary reflectors H(i) of order n, as returned by",
   "CHPTRD using packed storage:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "spbrfs"=>
  ["SPBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and banded, and provides error bounds and backward error estimates",
   "for the solution."],
 "dlaev2"=>
  ["DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix",
   "   [  A   B  ]",
   "   [  B   C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, RT2 is the",
   "eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right",
   "eigenvector for RT1, giving the decomposition",
   "   [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]",
   "   [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ]."],
 "sgebak"=>
  ["SGEBAK forms the right or left eigenvectors of a real general matrix",
   "by backward transformation on the computed eigenvectors of the",
   "balanced matrix output by SGEBAL."],
 "zlarscl2"=>
  ["ZLARSCL2 performs a reciprocal diagonal scaling on an vector:",
   "  x <-- inv(D) * x",
   "where the DOUBLE PRECISION diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_zge_diag_scale in the new BLAS",
   "standard."],
 "zlantr"=>
  ["ZLANTR  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "trapezoidal or triangular matrix A.",
   "   ZLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "slapmt"=>
  ["SLAPMT rearranges the columns of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N."],
 "dla_syrcond"=>
  ["   DLA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "cggrqf"=>
  ["CGGRQF computes a generalized RQ factorization of an M-by-N matrix A",
   "and a P-by-N matrix B:",
   "            A = R*Q,        B = Z*T*Q,",
   "where Q is an N-by-N unitary matrix, Z is a P-by-P unitary",
   "matrix, and R and T assume one of the forms:",
   "if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,",
   "                 N-M  M                           ( R21 ) N",
   "                                                     N",
   "where R12 or R21 is upper triangular, and",
   "if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,",
   "                (  0  ) P-N                         P   N-P",
   "                   N",
   "where T11 is upper triangular.",
   "In particular, if B is square and nonsingular, the GRQ factorization",
   "of A and B implicitly gives the RQ factorization of A*inv(B):",
   "             A*inv(B) = (R*inv(T))*Z**H",
   "where inv(B) denotes the inverse of the matrix B, and Z**H denotes the",
   "conjugate transpose of the matrix Z."],
 "sorcsd"=>
  ["SORCSD computes the CS decomposition of an M-by-M partitioned",
   "orthogonal matrix X:",
   "                                [  I  0  0 |  0  0  0 ]",
   "                                [  0  C  0 |  0 -S  0 ]",
   "    [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T",
   "X = [-----------] = [---------] [---------------------] [---------]   .",
   "    [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]",
   "                                [  0  S  0 |  0  C  0 ]",
   "                                [  0  0  I |  0  0  0 ]",
   "X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,",
   "(M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are",
   "R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in",
   "which R = MIN(P,M-P,Q,M-Q)."],
 "cgeql2"=>
  ["CGEQL2 computes a QL factorization of a complex m by n matrix A:",
   "A = Q * L."],
 "slauu2"=>
  ["SLAUU2 computes the product U * U**T or L**T * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the unblocked form of the algorithm, calling Level 2 BLAS."],
 "cgebal"=>
  ["CGEBAL balances a general complex matrix A.  This involves, first,",
   "permuting A by a similarity transformation to isolate eigenvalues",
   "in the first 1 to ILO-1 and last IHI+1 to N elements on the",
   "diagonal; and second, applying a diagonal similarity transformation",
   "to rows and columns ILO to IHI to make the rows and columns as",
   "close in norm as possible.  Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrix, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors."],
 "sorgtr"=>
  ["SORGTR generates a real orthogonal matrix Q which is defined as the",
   "product of n-1 elementary reflectors of order N, as returned by",
   "SSYTRD:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "dsposv"=>
  ["DSPOSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "DSPOSV first attempts to factorize the matrix in SINGLE PRECISION",
   "and use this factorization within an iterative refinement procedure",
   "to produce a solution with DOUBLE PRECISION normwise backward error",
   "quality (see below). If the approach fails the method switches to a",
   "DOUBLE PRECISION factorization and solve.",
   "The iterative refinement is not going to be a winning strategy if",
   "the ratio SINGLE PRECISION performance over DOUBLE PRECISION",
   "performance is too small. A reasonable strategy should take the",
   "number of right-hand sides and the size of the matrix into account.",
   "This might be done with a call to ILAENV in the future. Up to now, we",
   "always try iterative refinement.",
   "The iterative refinement process is stopped if",
   "    ITER > ITERMAX",
   "or for all the RHS we have:",
   "    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX",
   "where",
   "    o ITER is the number of the current iteration in the iterative",
   "      refinement process",
   "    o RNRM is the infinity-norm of the residual",
   "    o XNRM is the infinity-norm of the solution",
   "    o ANRM is the infinity-operator-norm of the matrix A",
   "    o EPS is the machine epsilon returned by DLAMCH('Epsilon')",
   "The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00",
   "respectively."],
 "ztrti2"=>
  ["ZTRTI2 computes the inverse of a complex upper or lower triangular",
   "matrix.",
   "This is the Level 2 BLAS version of the algorithm."],
 "dormr3"=>
  ["DORMR3 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'C',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DTZRZF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "cgbsvx"=>
  ["CGBSVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a band matrix of order N with KL subdiagonals and KU",
   "superdiagonals, and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zgeequ"=>
  ["ZGEEQU computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "zheevd_2stage"=>
  ["ZHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "chbgvd"=>
  ["CHBGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cgbtf2"=>
  ["CGBTF2 computes an LU factorization of a complex m-by-n band matrix",
   "A using partial pivoting with row interchanges.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "ilaver"=>[" This subroutine returns the LAPACK version."],
 "dlatps"=>
  ["DLATPS solves one of the triangular systems",
   "   A *x = s*b  or  A**T*x = s*b",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular matrix stored in packed form.  Here A**T denotes the",
   "transpose of A, x and b are n-element vectors, and s is a scaling",
   "factor, usually less than or equal to 1, chosen so that the",
   "components of x will be less than the overflow threshold.  If the",
   "unscaled problem will not cause overflow, the Level 2 BLAS routine",
   "DTPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),",
   "then s is set to 0 and a non-trivial solution to A*x = 0 is returned."],
 "dsterf"=>
  ["DSTERF computes all eigenvalues of a symmetric tridiagonal matrix",
   "using the Pal-Walker-Kahan variant of the QL or QR algorithm."],
 "zggev"=>
  ["ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right generalized eigenvector v(j) corresponding to the",
   "generalized eigenvalue lambda(j) of (A,B) satisfies",
   "             A * v(j) = lambda(j) * B * v(j).",
   "The left generalized eigenvector u(j) corresponding to the",
   "generalized eigenvalues lambda(j) of (A,B) satisfies",
   "             u(j)**H * A = lambda(j) * u(j)**H * B",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "dlasr"=>
  ["DLASR applies a sequence of plane rotations to a real matrix A,",
   "from either the left or the right.",
   "When SIDE = 'L', the transformation takes the form",
   "   A := P*A",
   "and when SIDE = 'R', the transformation takes the form",
   "   A := A*P**T",
   "where P is an orthogonal matrix consisting of a sequence of z plane",
   "rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',",
   "and P**T is the transpose of P.",
   "When DIRECT = 'F' (Forward sequence), then",
   "   P = P(z-1) * ... * P(2) * P(1)",
   "and when DIRECT = 'B' (Backward sequence), then",
   "   P = P(1) * P(2) * ... * P(z-1)",
   "where P(k) is a plane rotation matrix defined by the 2-by-2 rotation",
   "   R(k) = (  c(k)  s(k) )",
   "        = ( -s(k)  c(k) ).",
   "When PIVOT = 'V' (Variable pivot), the rotation is performed",
   "for the plane (k,k+1), i.e., P(k) has the form",
   "   P(k) = (  1                                            )",
   "          (       ...                                     )",
   "          (              1                                )",
   "          (                   c(k)  s(k)                  )",
   "          (                  -s(k)  c(k)                  )",
   "          (                                1              )",
   "          (                                     ...       )",
   "          (                                            1  )",
   "where R(k) appears as a rank-2 modification to the identity matrix in",
   "rows and columns k and k+1.",
   "When PIVOT = 'T' (Top pivot), the rotation is performed for the",
   "plane (1,k+1), so P(k) has the form",
   "   P(k) = (  c(k)                    s(k)                 )",
   "          (         1                                     )",
   "          (              ...                              )",
   "          (                     1                         )",
   "          ( -s(k)                    c(k)                 )",
   "          (                                 1             )",
   "          (                                      ...      )",
   "          (                                             1 )",
   "where R(k) appears in rows and columns 1 and k+1.",
   "Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is",
   "performed for the plane (k,z), giving P(k) the form",
   "   P(k) = ( 1                                             )",
   "          (      ...                                      )",
   "          (             1                                 )",
   "          (                  c(k)                    s(k) )",
   "          (                         1                     )",
   "          (                              ...              )",
   "          (                                     1         )",
   "          (                 -s(k)                    c(k) )",
   "where R(k) appears in rows and columns k and z.  The rotations are",
   "performed without ever forming P(k) explicitly."],
 "csptrs"=>
  ["CSPTRS solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A stored in packed format using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by CSPTRF."],
 "dggbak"=>
  ["DGGBAK forms the right or left eigenvectors of a real generalized",
   "eigenvalue problem A*x = lambda*B*x, by backward transformation on",
   "the computed eigenvectors of the balanced pair of matrices output by",
   "DGGBAL."],
 "zhbevx"=>
  ["ZHBEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "sgemqr"=>
  ["SGEMQR overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "    TRANS = 'N':      Q * C          C * Q",
   "    TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product",
   "of blocked elementary reflectors computed by tall skinny",
   "QR factorization (SGEQR)"],
 "zgeequb"=>
  ["ZGEEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from ZGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "sposv"=>
  ["SPOSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T* U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "dsptrd"=>
  ["DSPTRD reduces a real symmetric matrix A stored in packed form to",
   "symmetric tridiagonal form T by an orthogonal similarity",
   "transformation: Q**T * A * Q = T."],
 "cgsvj0"=>
  ["CGSVJ0 is called from CGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as CGESVJ does, but",
   "it does not check convergence (stopping criterion). Few tuning",
   "parameters (marked by [TP]) are available for the implementer."],
 "ilaprec"=>
  ["This subroutine translated from a character string specifying an",
   "intermediate precision to the relevant BLAST-specified integer",
   "constant.",
   "ILAPREC returns an INTEGER.  If ILAPREC < 0, then the input is not a",
   "character indicating a supported intermediate precision.  Otherwise",
   "ILAPREC returns the constant value corresponding to PREC."],
 "ztrcon"=>
  ["ZTRCON estimates the reciprocal of the condition number of a",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dlasq2"=>
  ["DLASQ2 computes all the eigenvalues of the symmetric positive",
   "definite tridiagonal matrix associated with the qd array Z to high",
   "relative accuracy are computed to high relative accuracy, in the",
   "absence of denormalization, underflow and overflow.",
   "To see the relation of Z to the tridiagonal matrix, let L be a",
   "unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and",
   "let U be an upper bidiagonal matrix with 1's above and diagonal",
   "Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the",
   "symmetric tridiagonal to which it is similar.",
   "Note : DLASQ2 defines a logical variable, IEEE, which is true",
   "on machines which follow ieee-754 floating-point standard in their",
   "handling of infinities and NaNs, and false otherwise. This variable",
   "is passed to DLASQ3."],
 "sorm2l"=>
  ["SORM2L overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T * C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by SGEQLF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dopgtr"=>
  ["DOPGTR generates a real orthogonal matrix Q which is defined as the",
   "product of n-1 elementary reflectors H(i) of order n, as returned by",
   "DSPTRD using packed storage:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "chbgv"=>
  ["CHBGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite."],
 "dlasd0"=>
  ["Using a divide and conquer approach, DLASD0 computes the singular",
   "value decomposition (SVD) of a real upper bidiagonal N-by-M",
   "matrix B with diagonal D and offdiagonal E, where M = N + SQRE.",
   "The algorithm computes orthogonal matrices U and VT such that",
   "B = U * S * VT. The singular values S are overwritten on D.",
   "A related subroutine, DLASDA, computes only the singular values,",
   "and optionally, the singular vectors in compact form."],
 "dlapmr"=>
  ["DLAPMR rearranges the rows of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(K(I),*) is moved X(I,*) for I = 1,2,...,M.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(I,*) is moved to X(K(I),*) for I = 1,2,...,M."],
 "zunm2r"=>
  ["ZUNM2R overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by ZGEQRF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "zhptrd"=>
  ["ZHPTRD reduces a complex Hermitian matrix A stored in packed form to",
   "real symmetric tridiagonal form T by a unitary similarity",
   "transformation: Q**H * A * Q = T."],
 "sgelsy"=>
  ["SGELSY computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize || A * X - B ||",
   "using a complete orthogonal factorization of A.  A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The routine first computes a QR factorization with column pivoting:",
   "    A * P = Q * [ R11 R12 ]",
   "                [  0  R22 ]",
   "with R11 defined as the largest leading submatrix whose estimated",
   "condition number is less than 1/RCOND.  The order of R11, RANK,",
   "is the effective rank of A.",
   "Then, R22 is considered to be negligible, and R12 is annihilated",
   "by orthogonal transformations from the right, arriving at the",
   "complete orthogonal factorization:",
   "   A * P = Q * [ T11 0 ] * Z",
   "               [  0  0 ]",
   "The minimum-norm solution is then",
   "   X = P * Z**T [ inv(T11)*Q1**T*B ]",
   "                [        0         ]",
   "where Q1 consists of the first RANK columns of Q.",
   "This routine is basically identical to the original xGELSX except",
   "three differences:",
   "  o The call to the subroutine xGEQPF has been substituted by the",
   "    the call to the subroutine xGEQP3. This subroutine is a Blas-3",
   "    version of the QR factorization with column pivoting.",
   "  o Matrix B (the right hand side) is updated with Blas-3.",
   "  o The permutation of matrix B (the right hand side) is faster and",
   "    more simple."],
 "ztrexc"=>
  ["ZTREXC reorders the Schur factorization of a complex matrix",
   "A = Q*T*Q**H, so that the diagonal element of T with row index IFST",
   "is moved to row ILST.",
   "The Schur form T is reordered by a unitary similarity transformation",
   "Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by",
   "postmultplying it with Z."],
 "zlasr"=>
  ["ZLASR applies a sequence of real plane rotations to a complex matrix",
   "A, from either the left or the right.",
   "When SIDE = 'L', the transformation takes the form",
   "   A := P*A",
   "and when SIDE = 'R', the transformation takes the form",
   "   A := A*P**T",
   "where P is an orthogonal matrix consisting of a sequence of z plane",
   "rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',",
   "and P**T is the transpose of P.",
   "When DIRECT = 'F' (Forward sequence), then",
   "   P = P(z-1) * ... * P(2) * P(1)",
   "and when DIRECT = 'B' (Backward sequence), then",
   "   P = P(1) * P(2) * ... * P(z-1)",
   "where P(k) is a plane rotation matrix defined by the 2-by-2 rotation",
   "   R(k) = (  c(k)  s(k) )",
   "        = ( -s(k)  c(k) ).",
   "When PIVOT = 'V' (Variable pivot), the rotation is performed",
   "for the plane (k,k+1), i.e., P(k) has the form",
   "   P(k) = (  1                                            )",
   "          (       ...                                     )",
   "          (              1                                )",
   "          (                   c(k)  s(k)                  )",
   "          (                  -s(k)  c(k)                  )",
   "          (                                1              )",
   "          (                                     ...       )",
   "          (                                            1  )",
   "where R(k) appears as a rank-2 modification to the identity matrix in",
   "rows and columns k and k+1.",
   "When PIVOT = 'T' (Top pivot), the rotation is performed for the",
   "plane (1,k+1), so P(k) has the form",
   "   P(k) = (  c(k)                    s(k)                 )",
   "          (         1                                     )",
   "          (              ...                              )",
   "          (                     1                         )",
   "          ( -s(k)                    c(k)                 )",
   "          (                                 1             )",
   "          (                                      ...      )",
   "          (                                             1 )",
   "where R(k) appears in rows and columns 1 and k+1.",
   "Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is",
   "performed for the plane (k,z), giving P(k) the form",
   "   P(k) = ( 1                                             )",
   "          (      ...                                      )",
   "          (             1                                 )",
   "          (                  c(k)                    s(k) )",
   "          (                         1                     )",
   "          (                              ...              )",
   "          (                                     1         )",
   "          (                 -s(k)                    c(k) )",
   "where R(k) appears in rows and columns k and z.  The rotations are",
   "performed without ever forming P(k) explicitly."],
 "chpsv"=>
  ["CHPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**H,  if UPLO = 'U', or",
   "   A = L * D * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is Hermitian and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "dgemqr"=>
  ["DGEMQR overwrites the general real M-by-N matrix C with",
   "                     SIDE = 'L'     SIDE = 'R'",
   "     TRANS = 'N':      Q * C          C * Q",
   "     TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product",
   "of blocked elementary reflectors computed by tall skinny",
   "QR factorization (DGEQR)"],
 "cunmr3"=>
  ["CUNMR3 overwrites the general complex m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by CTZRZF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dlatrz"=>
  ["DLATRZ factors the M-by-(M+L) real upper trapezoidal matrix",
   "[ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z, by means",
   "of orthogonal transformations.  Z is an (M+L)-by-(M+L) orthogonal",
   "matrix and, R and A1 are M-by-M upper triangular matrices."],
 "zla_syrcond_c"=>
  ["   ZLA_SYRCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector."],
 "dgtsv"=>
  ["DGTSV  solves the equation",
   "   A*X = B,",
   "where A is an n by n tridiagonal matrix, by Gaussian elimination with",
   "partial pivoting.",
   "Note that the equation  A**T*X = B  may be solved by interchanging the",
   "order of the arguments DU and DL."],
 "ztrtri"=>
  ["ZTRTRI computes the inverse of a complex upper or lower triangular",
   "matrix A.",
   "This is the Level 3 BLAS version of the algorithm."],
 "dlarzb"=>
  ["DLARZB applies a real block reflector H or its transpose H**T to",
   "a real distributed M-by-N  C from the left or the right.",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "cgesvdx"=>
  [" CGESVDX computes the singular value decomposition (SVD) of a complex",
   " M-by-N matrix A, optionally computing the left and/or right singular",
   " vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   " where SIGMA is an M-by-N matrix which is zero except for its",
   " min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   " V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   " are the singular values of A; they are real and non-negative, and",
   " are returned in descending order.  The first min(m,n) columns of",
   " U and V are the left and right singular vectors of A.",
   " CGESVDX uses an eigenvalue problem for obtaining the SVD, which",
   " allows for the computation of a subset of singular values and",
   " vectors. See SBDSVDX for details.",
   " Note that the routine returns V**T, not V."],
 "dgebal"=>
  ["DGEBAL balances a general real matrix A.  This involves, first,",
   "permuting A by a similarity transformation to isolate eigenvalues",
   "in the first 1 to ILO-1 and last IHI+1 to N elements on the",
   "diagonal; and second, applying a diagonal similarity transformation",
   "to rows and columns ILO to IHI to make the rows and columns as",
   "close in norm as possible.  Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrix, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors."],
 "clanhf"=>
  ["CLANHF  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex Hermitian matrix A in RFP format.",
   "   CLANHF = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a  matrix norm."],
 "sstebz"=>
  ["SSTEBZ computes the eigenvalues of a symmetric tridiagonal",
   "matrix T.  The user may ask for all eigenvalues, all eigenvalues",
   "in the half-open interval (VL, VU], or the IL-th through IU-th",
   "eigenvalues.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "dlasd2"=>
  ["DLASD2 merges the two sets of singular values together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "singular values are close together or if there is a tiny entry in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one.",
   "DLASD2 is called from DLASD1."],
 "dsbevx"=>
  ["DSBEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric band matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "cungbr"=>
  ["CUNGBR generates one of the complex unitary matrices Q or P**H",
   "determined by CGEBRD when reducing a complex matrix A to bidiagonal",
   "form: A = Q * B * P**H.  Q and P**H are defined as products of",
   "elementary reflectors H(i) or G(i) respectively.",
   "If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q",
   "is of order M:",
   "if m >= k, Q = H(1) H(2) . . . H(k) and CUNGBR returns the first n",
   "columns of Q, where m >= n >= k;",
   "if m < k, Q = H(1) H(2) . . . H(m-1) and CUNGBR returns Q as an",
   "M-by-M matrix.",
   "If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H",
   "is of order N:",
   "if k < n, P**H = G(k) . . . G(2) G(1) and CUNGBR returns the first m",
   "rows of P**H, where n >= m >= k;",
   "if k >= n, P**H = G(n-1) . . . G(2) G(1) and CUNGBR returns P**H as",
   "an N-by-N matrix."],
 "zunmrz"=>
  ["ZUNMRZ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by ZTZRZF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "chpevx"=>
  ["CHPEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A in packed storage.",
   "Eigenvalues/vectors can be selected by specifying either a range of",
   "values or a range of indices for the desired eigenvalues."],
 "cla_hercond_x"=>
  ["   CLA_HERCOND_X computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX vector."],
 "spbequ"=>
  ["SPBEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite band matrix A and reduce its condition",
   "number (with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "slansb"=>
  ["SLANSB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n symmetric band matrix A,  with k super-diagonals.",
   "   SLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dlasd5"=>
  ["This subroutine computes the square root of the I-th eigenvalue",
   "of a positive symmetric rank-one modification of a 2-by-2 diagonal",
   "matrix",
   "           diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .",
   "The diagonal entries in the array D are assumed to satisfy",
   "           0 <= D(i) < D(j)  for  i < j .",
   "We also assume RHO > 0 and that the Euclidean norm of the vector",
   "Z is one."],
 "sgges"=>
  ["SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),",
   "the generalized eigenvalues, the generalized real Schur form (S,T),",
   "optionally, the left and/or right matrices of Schur vectors (VSL and",
   "VSR). This gives the generalized Schur factorization",
   "         (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "quasi-triangular matrix S and the upper triangular matrix T.The",
   "leading columns of VSL and VSR then form an orthonormal basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "SGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0 or both being zero.",
   "A pair of matrices (S,T) is in generalized real Schur form if T is",
   "upper triangular with non-negative diagonal and S is block upper",
   "triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond",
   "to real generalized eigenvalues, while 2-by-2 blocks of S will be",
   "\"standardized\" by making the corresponding elements of T have the",
   "form:",
   "        [  a  0  ]",
   "        [  0  b  ]",
   "and the pair of corresponding 2-by-2 blocks in S and T will have a",
   "complex conjugate pair of generalized eigenvalues."],
 "dpftrf"=>
  ["DPFTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "dppsv"=>
  ["DPPSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T* U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "chbev_2stage"=>
  ["CHBEV_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "zhseqr"=>
  ["   ZHSEQR computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H."],
 "zcposv"=>
  ["ZCPOSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "ZCPOSV first attempts to factorize the matrix in COMPLEX and use this",
   "factorization within an iterative refinement procedure to produce a",
   "solution with COMPLEX*16 normwise backward error quality (see below).",
   "If the approach fails the method switches to a COMPLEX*16",
   "factorization and solve.",
   "The iterative refinement is not going to be a winning strategy if",
   "the ratio COMPLEX performance over COMPLEX*16 performance is too",
   "small. A reasonable strategy should take the number of right-hand",
   "sides and the size of the matrix into account. This might be done",
   "with a call to ILAENV in the future. Up to now, we always try",
   "iterative refinement.",
   "The iterative refinement process is stopped if",
   "    ITER > ITERMAX",
   "or for all the RHS we have:",
   "    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX",
   "where",
   "    o ITER is the number of the current iteration in the iterative",
   "      refinement process",
   "    o RNRM is the infinity-norm of the residual",
   "    o XNRM is the infinity-norm of the solution",
   "    o ANRM is the infinity-operator-norm of the matrix A",
   "    o EPS is the machine epsilon returned by DLAMCH('Epsilon')",
   "The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00",
   "respectively."],
 "cunghr"=>
  ["CUNGHR generates a complex unitary matrix Q which is defined as the",
   "product of IHI-ILO elementary reflectors of order N, as returned by",
   "CGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "sppsv"=>
  ["SPPSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**T* U,  if UPLO = 'U', or",
   "   A = L * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "sgetc2"=>
  ["SGETC2 computes an LU factorization with complete pivoting of the",
   "n-by-n matrix A. The factorization has the form A = P * L * U * Q,",
   "where P and Q are permutation matrices, L is lower triangular with",
   "unit diagonal elements and U is upper triangular.",
   "This is the Level 2 BLAS algorithm."],
 "ctrttp"=>
  ["CTRTTP copies a triangular matrix A from full format (TR) to standard",
   "packed format (TP)."],
 "ztftri"=>
  ["ZTFTRI computes the inverse of a triangular matrix A stored in RFP",
   "format.",
   "This is a Level 3 BLAS version of the algorithm."],
 "cporfs"=>
  ["CPORFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite,",
   "and provides error bounds and backward error estimates for the",
   "solution."],
 "dlar1v"=>
  ["DLAR1V computes the (scaled) r-th column of the inverse of",
   "the sumbmatrix in rows B1 through BN of the tridiagonal matrix",
   "L D L**T - sigma I. When sigma is close to an eigenvalue, the",
   "computed vector is an accurate eigenvector. Usually, r corresponds",
   "to the index where the eigenvector is largest in magnitude.",
   "The following steps accomplish this computation :",
   "(a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,",
   "(b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,",
   "(c) Computation of the diagonal elements of the inverse of",
   "    L D L**T - sigma I by combining the above transforms, and choosing",
   "    r as the index where the diagonal of the inverse is (one of the)",
   "    largest in magnitude.",
   "(d) Computation of the (scaled) r-th column of the inverse using the",
   "    twisted factorization obtained by combining the top part of the",
   "    the stationary and the bottom part of the progressive transform."],
 "dlaic1"=>
  ["DLAIC1 applies one step of incremental condition estimation in",
   "its simplest version:",
   "Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j",
   "lower triangular matrix L, such that",
   "         twonorm(L*x) = sest",
   "Then DLAIC1 computes sestpr, s, c such that",
   "the vector",
   "                [ s*x ]",
   "         xhat = [  c  ]",
   "is an approximate singular vector of",
   "                [ L       0  ]",
   "         Lhat = [ w**T gamma ]",
   "in the sense that",
   "         twonorm(Lhat*xhat) = sestpr.",
   "Depending on JOB, an estimate for the largest or smallest singular",
   "value is computed.",
   "Note that [s c]**T and sestpr**2 is an eigenpair of the system",
   "    diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]",
   "                                          [ gamma ]",
   "where  alpha =  x**T*w."],
 "cungr2"=>
  ["CUNGR2 generates an m by n complex matrix Q with orthonormal rows,",
   "which is defined as the last m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(1)**H H(2)**H . . . H(k)**H",
   "as returned by CGERQF."],
 "stgsja"=>
  ["STGSJA computes the generalized singular value decomposition (GSVD)",
   "of two real upper triangular (or trapezoidal) matrices A and B.",
   "On entry, it is assumed that matrices A and B have the following",
   "forms, which may be obtained by the preprocessing subroutine SGGSVP",
   "from a general M-by-N matrix A and P-by-N matrix B:",
   "             N-K-L  K    L",
   "   A =    K ( 0    A12  A13 ) if M-K-L >= 0;",
   "          L ( 0     0   A23 )",
   "      M-K-L ( 0     0    0  )",
   "           N-K-L  K    L",
   "   A =  K ( 0    A12  A13 ) if M-K-L < 0;",
   "      M-K ( 0     0   A23 )",
   "           N-K-L  K    L",
   "   B =  L ( 0     0   B13 )",
   "      P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.",
   "On exit,",
   "       U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),",
   "where U, V and Q are orthogonal matrices.",
   "R is a nonsingular upper triangular matrix, and D1 and D2 are",
   "``diagonal'' matrices, which are of the following structures:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 = L   ( 0  S )",
   "            P-L ( 0  0 )",
   "               N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 ) K",
   "            L (  0    0   R22 ) L",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "               K M-K K+L-M",
   "    D1 =   K ( I  0    0   )",
   "         M-K ( 0  C    0   )",
   "                 K M-K K+L-M",
   "    D2 =   M-K ( 0  S    0   )",
   "         K+L-M ( 0  0    I   )",
   "           P-L ( 0  0    0   )",
   "               N-K-L  K   M-K  K+L-M",
   "( 0 R ) =    K ( 0    R11  R12  R13  )",
   "          M-K ( 0     0   R22  R23  )",
   "        K+L-M ( 0     0    0   R33  )",
   "where",
   "C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "S = diag( BETA(K+1),  ... , BETA(M) ),",
   "C**2 + S**2 = I.",
   "R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored",
   "    (  0  R22 R23 )",
   "in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The computation of the orthogonal transformation matrices U, V or Q",
   "is optional.  These matrices may either be formed explicitly, or they",
   "may be postmultiplied into input matrices U1, V1, or Q1."],
 "dla_gerfsx_extended"=>
  ["DLA_GERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by DGERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERRS_N",
   "and ERRS_C for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERRS_N and ERRS_C."],
 "dgels"=>
  ["DGELS solves overdetermined or underdetermined real linear systems",
   "involving an M-by-N matrix A, or its transpose, using a QR or LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'T' and m >= n:  find the minimum norm solution of",
   "   an underdetermined system A**T * X = B.",
   "4. If TRANS = 'T' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "zunmr2"=>
  ["ZUNMR2 overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1)**H H(2)**H . . . H(k)**H",
   "as returned by ZGERQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "zla_gbrcond_x"=>
  ["   ZLA_GBRCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX*16 vector."],
 "sla_gerfsx_extended"=>
  ["SLA_GERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by SGERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERRS_N",
   "and ERRS_C for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERRS_N and ERRS_C."],
 "chetrs_3"=>
  ["CHETRS_3 solves a system of linear equations A * X = B with a complex",
   "Hermitian matrix A using the factorization computed",
   "by CHETRF_RK or CHETRF_BK:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "dggglm"=>
  ["DGGGLM solves a general Gauss-Markov linear model (GLM) problem:",
   "        minimize || y ||_2   subject to   d = A*x + B*y",
   "            x",
   "where A is an N-by-M matrix, B is an N-by-P matrix, and d is a",
   "given N-vector. It is assumed that M <= N <= M+P, and",
   "           rank(A) = M    and    rank( A B ) = N.",
   "Under these assumptions, the constrained equation is always",
   "consistent, and there is a unique solution x and a minimal 2-norm",
   "solution y, which is obtained using a generalized QR factorization",
   "of the matrices (A, B) given by",
   "   A = Q*(R),   B = Q*T*Z.",
   "         (0)",
   "In particular, if matrix B is square nonsingular, then the problem",
   "GLM is equivalent to the following weighted linear least squares",
   "problem",
   "             minimize || inv(B)*(d-A*x) ||_2",
   "                 x",
   "where inv(B) denotes the inverse of B."],
 "ilaslr"=>["ILASLR scans A for its last non-zero row."],
 "slaed4"=>
  ["This subroutine computes the I-th updated eigenvalue of a symmetric",
   "rank-one modification to a diagonal matrix whose elements are",
   "given in the array d, and that",
   "           D(i) < D(j)  for  i < j",
   "and that RHO > 0.  This is arranged by the calling routine, and is",
   "no loss in generality.  The rank-one modified system is thus",
   "           diag( D )  +  RHO * Z * Z_transpose.",
   "where we assume the Euclidean norm of Z is 1.",
   "The method consists of approximating the rational functions in the",
   "secular equation by simpler interpolating rational functions."],
 "zunmql"=>
  ["ZUNMQL overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "dgbtrs"=>
  ["DGBTRS solves a system of linear equations",
   "   A * X = B  or  A**T * X = B",
   "with a general band matrix A using the LU factorization computed",
   "by DGBTRF."],
 "sorgrq"=>
  ["SORGRQ generates an M-by-N real matrix Q with orthonormal rows,",
   "which is defined as the last M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by SGERQF."],
 "zgbsv"=>
  ["ZGBSV computes the solution to a complex system of linear equations",
   "A * X = B, where A is a band matrix of order N with KL subdiagonals",
   "and KU superdiagonals, and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as A = L * U, where L is a product of permutation",
   "and unit lower triangular matrices with KL subdiagonals, and U is",
   "upper triangular with KL+KU superdiagonals.  The factored form of A",
   "is then used to solve the system of equations A * X = B."],
 "slangb"=>
  ["SLANGB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.",
   "   SLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dlartg"=>
  ["DLARTG generate a plane rotation so that",
   "   [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a slower, more accurate version of the BLAS1 routine DROTG,",
   "with the following other differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=1 and SN=0.",
   "   If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any",
   "      floating point operations (saves work in DBDSQR when",
   "      there are zeros on the diagonal).",
   "If F exceeds G in magnitude, CS will be positive."],
 "zupgtr"=>
  ["ZUPGTR generates a complex unitary matrix Q which is defined as the",
   "product of n-1 elementary reflectors H(i) of order n, as returned by",
   "ZHPTRD using packed storage:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "sormr2"=>
  ["SORMR2 overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by SGERQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "spstf2"=>
  ["SPSTF2 computes the Cholesky factorization with complete",
   "pivoting of a real symmetric positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**T * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 2 BLAS."],
 "cungl2"=>
  ["CUNGL2 generates an m-by-n complex matrix Q with orthonormal rows,",
   "which is defined as the first m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(k)**H . . . H(2)**H H(1)**H",
   "as returned by CGELQF."],
 "csytri"=>
  ["CSYTRI computes the inverse of a complex symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "CSYTRF."],
 "sgelss"=>
  ["SGELSS computes the minimum norm solution to a real linear least",
   "squares problem:",
   "Minimize 2-norm(| b - A*x |).",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix",
   "X.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value."],
 "shgeqz"=>
  ["SHGEQZ computes the eigenvalues of a real matrix pair (H,T),",
   "where H is an upper Hessenberg matrix and T is upper triangular,",
   "using the double-shift QZ method.",
   "Matrix pairs of this type are produced by the reduction to",
   "generalized upper Hessenberg form of a real matrix pair (A,B):",
   "   A = Q1*H*Z1**T,  B = Q1*T*Z1**T,",
   "as computed by SGGHRD.",
   "If JOB='S', then the Hessenberg-triangular pair (H,T) is",
   "also reduced to generalized Schur form,",
   "   H = Q*S*Z**T,  T = Q*P*Z**T,",
   "where Q and Z are orthogonal matrices, P is an upper triangular",
   "matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2",
   "diagonal blocks.",
   "The 1-by-1 blocks correspond to real eigenvalues of the matrix pair",
   "(H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of",
   "eigenvalues.",
   "Additionally, the 2-by-2 upper triangular diagonal blocks of P",
   "corresponding to 2-by-2 blocks of S are reduced to positive diagonal",
   "form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,",
   "P(j,j) > 0, and P(j+1,j+1) > 0.",
   "Optionally, the orthogonal matrix Q from the generalized Schur",
   "factorization may be postmultiplied into an input matrix Q1, and the",
   "orthogonal matrix Z may be postmultiplied into an input matrix Z1.",
   "If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced",
   "the matrix pair (A,B) to generalized upper Hessenberg form, then the",
   "output matrices Q1*Q and Z1*Z are the orthogonal factors from the",
   "generalized Schur factorization of (A,B):",
   "   A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.",
   "To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,",
   "of (A,B)) are computed as a pair of values (alpha,beta), where alpha is",
   "complex and beta real.",
   "If beta is nonzero, lambda = alpha / beta is an eigenvalue of the",
   "generalized nonsymmetric eigenvalue problem (GNEP)",
   "   A*x = lambda*B*x",
   "and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the",
   "alternate form of the GNEP",
   "   mu*A*y = B*y.",
   "Real eigenvalues can be read directly from the generalized Schur",
   "form:",
   "  alpha = S(i,i), beta = P(i,i).",
   "Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix",
   "     Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),",
   "     pp. 241--256."],
 "clasyf"=>
  ["CLASYF computes a partial factorization of a complex symmetric matrix",
   "A using the Bunch-Kaufman diagonal pivoting method. The partial",
   "factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) ( 0   A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**T denotes the transpose of U.",
   "CLASYF is an auxiliary routine called by CSYTRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "zheequb"=>
  ["ZHEEQUB computes row and column scalings intended to equilibrate a",
   "Hermitian matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "cunbdb1"=>[],
 "zbbcsd"=>
  ["ZBBCSD computes the CS decomposition of a unitary matrix in",
   "bidiagonal-block form,",
   "    [ B11 | B12 0  0 ]",
   "    [  0  |  0 -I  0 ]",
   "X = [----------------]",
   "    [ B21 | B22 0  0 ]",
   "    [  0  |  0  0  I ]",
   "                              [  C | -S  0  0 ]",
   "                  [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H",
   "                = [---------] [---------------] [---------]   .",
   "                  [    | U2 ] [  S |  C  0  0 ] [    | V2 ]",
   "                              [  0 |  0  0  I ]",
   "X is M-by-M, its top-left block is P-by-Q, and Q must be no larger",
   "than P, M-P, or M-Q. (If Q is not the smallest index, then X must be",
   "transposed and/or permuted. This can be done in constant time using",
   "the TRANS and SIGNS options. See ZUNCSD for details.)",
   "The bidiagonal matrices B11, B12, B21, and B22 are represented",
   "implicitly by angles THETA(1:Q) and PHI(1:Q-1).",
   "The unitary matrices U1, U2, V1T, and V2T are input/output.",
   "The input matrices are pre- or post-multiplied by the appropriate",
   "singular vector matrices."],
 "dgbequb"=>
  ["DGBEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from DGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "spstrf"=>
  ["SPSTRF computes the Cholesky factorization with complete",
   "pivoting of a real symmetric positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**T * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 3 BLAS."],
 "zpftrf"=>
  ["ZPFTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "zheevr"=>
  ["ZHEEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "ZHEEVR first reduces the matrix A to tridiagonal form T with a call",
   "to ZHETRD.  Then, whenever possible, ZHEEVR calls ZSTEMR to compute",
   "eigenspectrum using Relatively Robust Representations.  ZSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : ZHEEVR calls ZSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "ZHEEVR calls DSTEBZ and ZSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of ZSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "dorgbr"=>
  ["DORGBR generates one of the real orthogonal matrices Q or P**T",
   "determined by DGEBRD when reducing a real matrix A to bidiagonal",
   "form: A = Q * B * P**T.  Q and P**T are defined as products of",
   "elementary reflectors H(i) or G(i) respectively.",
   "If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q",
   "is of order M:",
   "if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n",
   "columns of Q, where m >= n >= k;",
   "if m < k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an",
   "M-by-M matrix.",
   "If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T",
   "is of order N:",
   "if k < n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m",
   "rows of P**T, where n >= m >= k;",
   "if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as",
   "an N-by-N matrix."],
 "zla_heamv"=>
  ["ZLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "slansy"=>
  ["SLANSY  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric matrix A.",
   "   SLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zgbequ"=>
  ["ZGBEQU computes row and column scalings intended to equilibrate an",
   "M-by-N band matrix A and reduce its condition number.  R returns the",
   "row scale factors and C the column scale factors, chosen to try to",
   "make the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "dsytrf_rook"=>
  ["DSYTRF_ROOK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "csytrf_rook"=>
  ["CSYTRF_ROOK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "sla_syrfsx_extended"=>
  ["SLA_SYRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by SSYRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "zhetri2x"=>
  ["ZHETRI2X computes the inverse of a COMPLEX*16 Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "ZHETRF."],
 "zlanhb"=>
  ["ZLANHB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n hermitian band matrix A,  with k super-diagonals.",
   "   ZLANHB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cstedc"=>
  ["CSTEDC computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method.",
   "The eigenvectors of a full or band complex Hermitian matrix can also",
   "be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this",
   "matrix to tridiagonal form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See SLAED3 for details."],
 "slasq2"=>
  ["SLASQ2 computes all the eigenvalues of the symmetric positive",
   "definite tridiagonal matrix associated with the qd array Z to high",
   "relative accuracy are computed to high relative accuracy, in the",
   "absence of denormalization, underflow and overflow.",
   "To see the relation of Z to the tridiagonal matrix, let L be a",
   "unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and",
   "let U be an upper bidiagonal matrix with 1's above and diagonal",
   "Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the",
   "symmetric tridiagonal to which it is similar.",
   "Note : SLASQ2 defines a logical variable, IEEE, which is true",
   "on machines which follow ieee-754 floating-point standard in their",
   "handling of infinities and NaNs, and false otherwise. This variable",
   "is passed to SLASQ3."],
 "dgees"=>
  ["DGEES computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues, the real Schur form T, and, optionally, the matrix of",
   "Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "real Schur form so that selected eigenvalues are at the top left.",
   "The leading columns of Z then form an orthonormal basis for the",
   "invariant subspace corresponding to the selected eigenvalues.",
   "A matrix is in real Schur form if it is upper quasi-triangular with",
   "1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the",
   "form",
   "        [  a  b  ]",
   "        [  c  a  ]",
   "where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc)."],
 "cgbequ"=>
  ["CGBEQU computes row and column scalings intended to equilibrate an",
   "M-by-N band matrix A and reduce its condition number.  R returns the",
   "row scale factors and C the column scale factors, chosen to try to",
   "make the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "sgttrs"=>
  ["SGTTRS solves one of the systems of equations",
   "   A*X = B  or  A**T*X = B,",
   "with a tridiagonal matrix A using the LU factorization computed",
   "by SGTTRF."],
 "cungrq"=>
  ["CUNGRQ generates an M-by-N complex matrix Q with orthonormal rows,",
   "which is defined as the last M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(1)**H H(2)**H . . . H(k)**H",
   "as returned by CGERQF."],
 "sgtsvx"=>
  ["SGTSVX uses the LU factorization to compute the solution to a real",
   "system of linear equations A * X = B or A**T * X = B,",
   "where A is a tridiagonal matrix of order N and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "csysv"=>
  ["CSYSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "dgglse"=>
  ["DGGLSE solves the linear equality-constrained least squares (LSE)",
   "problem:",
   "        minimize || c - A*x ||_2   subject to   B*x = d",
   "where A is an M-by-N matrix, B is a P-by-N matrix, c is a given",
   "M-vector, and d is a given P-vector. It is assumed that",
   "P <= N <= M+P, and",
   "         rank(B) = P and  rank( (A) ) = N.",
   "                              ( (B) )",
   "These conditions ensure that the LSE problem has a unique solution,",
   "which is obtained using a generalized RQ factorization of the",
   "matrices (B, A) given by",
   "   B = (0 R)*Q,   A = Z*T*Q."],
 "chetrs_aa"=>
  ["CHETRS_AA solves a system of linear equations A*X = B with a complex",
   "hermitian matrix A using the factorization A = U*T*U**H or",
   "A = L*T*L**H computed by CHETRF_AA."],
 "dpstf2"=>
  ["DPSTF2 computes the Cholesky factorization with complete",
   "pivoting of a real symmetric positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**T * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 2 BLAS."],
 "dgetsls"=>
  ["DGETSLS solves overdetermined or underdetermined real linear systems",
   "involving an M-by-N matrix A, using a tall skinny QR or short wide LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'T' and m >= n:  find the minimum norm solution of",
   "   an undetermined system A**T * X = B.",
   "4. If TRANS = 'T' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "zposvxx"=>
  ["   ZPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T",
   "   to compute the solution to a complex*16 system of linear equations",
   "   A * X = B, where A is an N-by-N symmetric positive definite matrix",
   "   and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. ZPOSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   ZPOSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   ZPOSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what ZPOSVXX would itself produce."],
 "clasr"=>
  ["CLASR applies a sequence of real plane rotations to a complex matrix",
   "A, from either the left or the right.",
   "When SIDE = 'L', the transformation takes the form",
   "   A := P*A",
   "and when SIDE = 'R', the transformation takes the form",
   "   A := A*P**T",
   "where P is an orthogonal matrix consisting of a sequence of z plane",
   "rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',",
   "and P**T is the transpose of P.",
   "When DIRECT = 'F' (Forward sequence), then",
   "   P = P(z-1) * ... * P(2) * P(1)",
   "and when DIRECT = 'B' (Backward sequence), then",
   "   P = P(1) * P(2) * ... * P(z-1)",
   "where P(k) is a plane rotation matrix defined by the 2-by-2 rotation",
   "   R(k) = (  c(k)  s(k) )",
   "        = ( -s(k)  c(k) ).",
   "When PIVOT = 'V' (Variable pivot), the rotation is performed",
   "for the plane (k,k+1), i.e., P(k) has the form",
   "   P(k) = (  1                                            )",
   "          (       ...                                     )",
   "          (              1                                )",
   "          (                   c(k)  s(k)                  )",
   "          (                  -s(k)  c(k)                  )",
   "          (                                1              )",
   "          (                                     ...       )",
   "          (                                            1  )",
   "where R(k) appears as a rank-2 modification to the identity matrix in",
   "rows and columns k and k+1.",
   "When PIVOT = 'T' (Top pivot), the rotation is performed for the",
   "plane (1,k+1), so P(k) has the form",
   "   P(k) = (  c(k)                    s(k)                 )",
   "          (         1                                     )",
   "          (              ...                              )",
   "          (                     1                         )",
   "          ( -s(k)                    c(k)                 )",
   "          (                                 1             )",
   "          (                                      ...      )",
   "          (                                             1 )",
   "where R(k) appears in rows and columns 1 and k+1.",
   "Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is",
   "performed for the plane (k,z), giving P(k) the form",
   "   P(k) = ( 1                                             )",
   "          (      ...                                      )",
   "          (             1                                 )",
   "          (                  c(k)                    s(k) )",
   "          (                         1                     )",
   "          (                              ...              )",
   "          (                                     1         )",
   "          (                 -s(k)                    c(k) )",
   "where R(k) appears in rows and columns k and z.  The rotations are",
   "performed without ever forming P(k) explicitly."],
 "zheswapr"=>
  ["ZHESWAPR applies an elementary permutation on the rows and the columns of",
   "a hermitian matrix."],
 "dgeqrt2"=>
  ["DGEQRT2 computes a QR factorization of a real M-by-N matrix A,",
   "using the compact WY representation of Q."],
 "zlapmr"=>
  ["ZLAPMR rearranges the rows of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(K(I),*) is moved X(I,*) for I = 1,2,...,M.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(I,*) is moved to X(K(I),*) for I = 1,2,...,M."],
 "dlarre"=>
  ["To find the desired eigenvalues of a given real symmetric",
   "tridiagonal matrix T, DLARRE sets any \"small\" off-diagonal",
   "elements to zero, and for each unreduced block T_i, it finds",
   "(a) a suitable shift at one end of the block's spectrum,",
   "(b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and",
   "(c) eigenvalues of each L_i D_i L_i^T.",
   "The representations and eigenvalues found are then used by",
   "DSTEMR to compute the eigenvectors of T.",
   "The accuracy varies depending on whether bisection is used to",
   "find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to",
   "conpute all and then discard any unwanted one.",
   "As an added benefit, DLARRE also outputs the n",
   "Gerschgorin intervals for the matrices L_i D_i L_i^T."],
 "zlals0"=>
  ["ZLALS0 applies back the multiplying factors of either the left or the",
   "right singular vector matrix of a diagonal matrix appended by a row",
   "to the right hand side matrix B in solving the least squares problem",
   "using the divide-and-conquer SVD approach.",
   "For the left singular vector matrix, three types of orthogonal",
   "matrices are involved:",
   "(1L) Givens rotations: the number of such rotations is GIVPTR; the",
   "     pairs of columns/rows they were applied to are stored in GIVCOL;",
   "     and the C- and S-values of these rotations are stored in GIVNUM.",
   "(2L) Permutation. The (NL+1)-st row of B is to be moved to the first",
   "     row, and for J=2:N, PERM(J)-th row of B is to be moved to the",
   "     J-th row.",
   "(3L) The left singular vector matrix of the remaining matrix.",
   "For the right singular vector matrix, four types of orthogonal",
   "matrices are involved:",
   "(1R) The right singular vector matrix of the remaining matrix.",
   "(2R) If SQRE = 1, one extra Givens rotation to generate the right",
   "     null space.",
   "(3R) The inverse transformation of (2L).",
   "(4R) The inverse transformation of (1L)."],
 "sgejsv"=>
  ["SGEJSV computes the singular value decomposition (SVD) of a real M-by-N",
   "matrix [A], where M >= N. The SVD of [A] is written as",
   "             [A] = [U] * [SIGMA] * [V]^t,",
   "where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N",
   "diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and",
   "[V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are",
   "the singular values of [A]. The columns of [U] and [V] are the left and",
   "the right singular vectors of [A], respectively. The matrices [U] and [V]",
   "are computed and stored in the arrays U and V, respectively. The diagonal",
   "of [SIGMA] is computed and stored in the array SVA.",
   "SGEJSV can sometimes compute tiny singular values and their singular vectors much",
   "more accurately than other SVD routines, see below under Further Details."],
 "cggevx"=>
  ["CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B) the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "Optionally, it also computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for",
   "the eigenvalues (RCONDE), and reciprocal condition numbers for the",
   "right eigenvectors (RCONDV).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j) .",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B.",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "slanhs"=>
  ["SLANHS  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "Hessenberg matrix A.",
   "   SLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dgeqrt3"=>
  ["DGEQRT3 recursively computes a QR factorization of a real M-by-N",
   "matrix A, using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "sla_geamv"=>
  ["SLA_GEAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dgesvdx"=>
  [" DGESVDX computes the singular value decomposition (SVD) of a real",
   " M-by-N matrix A, optionally computing the left and/or right singular",
   " vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   " where SIGMA is an M-by-N matrix which is zero except for its",
   " min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   " V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   " are the singular values of A; they are real and non-negative, and",
   " are returned in descending order.  The first min(m,n) columns of",
   " U and V are the left and right singular vectors of A.",
   " DGESVDX uses an eigenvalue problem for obtaining the SVD, which",
   " allows for the computation of a subset of singular values and",
   " vectors. See DBDSVDX for details.",
   " Note that the routine returns V**T, not V."],
 "slanst"=>
  ["SLANST  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric tridiagonal matrix A.",
   "   SLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zgelsd"=>
  ["ZGELSD computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize 2-norm(| b - A*x |)",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The problem is solved in three steps:",
   "(1) Reduce the coefficient matrix A to bidiagonal form with",
   "    Householder transformations, reducing the original problem",
   "    into a \"bidiagonal least squares problem\" (BLS)",
   "(2) Solve the BLS using a divide and conquer approach.",
   "(3) Apply back all the Householder transformations to solve",
   "    the original least squares problem.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cgesvj"=>
  ["CGESVJ computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, where M >= N. The SVD of A is written as",
   "                                   [++]   [xx]   [x0]   [xx]",
   "             A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]",
   "                                   [++]   [xx]",
   "where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal",
   "matrix, and V is an N-by-N unitary matrix. The diagonal elements",
   "of SIGMA are the singular values of A. The columns of U and V are the",
   "left and the right singular vectors of A, respectively."],
 "dorbdb6"=>[],
 "zgbtf2"=>
  ["ZGBTF2 computes an LU factorization of a complex m-by-n band matrix",
   "A using partial pivoting with row interchanges.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zunbdb3"=>[],
 "slacpy"=>
  ["SLACPY copies all or part of a two-dimensional matrix A to another",
   "matrix B."],
 "sspevd"=>
  ["SSPEVD computes all the eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A in packed storage. If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cgetc2"=>
  ["CGETC2 computes an LU factorization, using complete pivoting, of the",
   "n-by-n matrix A. The factorization has the form A = P * L * U * Q,",
   "where P and Q are permutation matrices, L is lower triangular with",
   "unit diagonal elements and U is upper triangular.",
   "This is a level 1 BLAS version of the algorithm."],
 "zladiv"=>
  ["ZLADIV := X / Y, where X and Y are complex.  The computation of X / Y",
   "will not overflow on an intermediary step unless the results",
   "overflows."],
 "ctrrfs"=>
  ["CTRRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular",
   "coefficient matrix.",
   "The solution matrix X must be computed by CTRTRS or some other",
   "means before entering this routine.  CTRRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "dgesvd"=>
  ["DGESVD computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   "V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns V**T, not V."],
 "chesv"=>
  ["CHESV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**H,  if UPLO = 'U', or",
   "   A = L * D * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "slagts"=>
  ["SLAGTS may be used to solve one of the systems of equations",
   "   (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,",
   "where T is an n by n tridiagonal matrix, for x, following the",
   "factorization of (T - lambda*I) as",
   "   (T - lambda*I) = P*L*U ,",
   "by routine SLAGTF. The choice of equation to be solved is",
   "controlled by the argument JOB, and in each case there is an option",
   "to perturb zero or very small diagonal elements of U, this option",
   "being intended for use in applications such as inverse iteration."],
 "ztzrzf"=>
  ["ZTZRZF reduces the M-by-N ( M<=N ) complex upper trapezoidal matrix A",
   "to upper triangular form by means of unitary transformations.",
   "The upper trapezoidal matrix A is factored as",
   "   A = ( R  0 ) * Z,",
   "where Z is an N-by-N unitary matrix and R is an M-by-M upper",
   "triangular matrix."],
 "slarfy"=>
  ["SLARFY applies an elementary reflector, or Householder matrix, H,",
   "to an n x n symmetric matrix C, from both the left and the right.",
   "H is represented in the form",
   "   H = I - tau * v * v'",
   "where  tau  is a scalar and  v  is a vector.",
   "If  tau  is  zero, then  H  is taken to be the unit matrix."],
 "dorgr2"=>
  ["DORGR2 generates an m by n real matrix Q with orthonormal rows,",
   "which is defined as the last m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by DGERQF."],
 "ssytrs2"=>
  ["SSYTRS2 solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by SSYTRF and converted by SSYCONV."],
 "cgeqrt3"=>
  ["CGEQRT3 recursively computes a QR factorization of a complex M-by-N matrix A,",
   "using the compact WY representation of Q.",
   "Based on the algorithm of Elmroth and Gustavson,",
   "IBM J. Res. Develop. Vol 44 No. 4 July 2000."],
 "dsysv"=>
  ["DSYSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "dsb2st_kernels"=>
  ["DSB2ST_KERNELS is an internal routine used by the DSYTRD_SB2ST",
   "subroutine."],
 "dlansp"=>
  ["DLANSP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric matrix A,  supplied in packed form.",
   "   DLANSP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "clanht"=>
  ["CLANHT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex Hermitian tridiagonal matrix A.",
   "   CLANHT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dgesc2"=>
  ["DGESC2 solves a system of linear equations",
   "          A * X = scale* RHS",
   "with a general N-by-N matrix A using the LU factorization with",
   "complete pivoting computed by DGETC2."],
 "stpmqrt"=>
  ["STPMQRT applies a real orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "chbgvx"=>
  ["CHBGVX computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian",
   "and banded, and B is also positive definite.  Eigenvalues and",
   "eigenvectors can be selected by specifying either all eigenvalues,",
   "a range of values or a range of indices for the desired eigenvalues."],
 "zlauum"=>
  ["ZLAUUM computes the product U * U**H or L**H * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the blocked form of the algorithm, calling Level 3 BLAS."],
 "ssytrs_rook"=>
  ["SSYTRS_ROOK solves a system of linear equations A*X = B with",
   "a real symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by SSYTRF_ROOK."],
 "dlasd6"=>
  ["DLASD6 computes the SVD of an updated upper bidiagonal matrix B",
   "obtained by merging two smaller ones by appending a row. This",
   "routine is used only for the problem which requires all singular",
   "values and optionally singular vector matrices in factored form.",
   "B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.",
   "A related subroutine, DLASD1, handles the case in which all singular",
   "values and singular vectors of the bidiagonal matrix are desired.",
   "DLASD6 computes the SVD as follows:",
   "              ( D1(in)    0    0       0 )",
   "  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)",
   "              (   0       0   D2(in)   0 )",
   "    = U(out) * ( D(out) 0) * VT(out)",
   "where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M",
   "with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros",
   "elsewhere; and the entry b is empty if SQRE = 0.",
   "The singular values of B can be computed using D1, D2, the first",
   "components of all the right singular vectors of the lower block, and",
   "the last components of all the right singular vectors of the upper",
   "block. These components are stored and updated in VF and VL,",
   "respectively, in DLASD6. Hence U and VT are not explicitly",
   "referenced.",
   "The singular values are stored in D. The algorithm consists of two",
   "stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple singular values or if there is a zero",
   "      in the Z vector. For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one. This stage is",
   "      performed by the routine DLASD7.",
   "      The second stage consists of calculating the updated",
   "      singular values. This is done by finding the roots of the",
   "      secular equation via the routine DLASD4 (as called by DLASD8).",
   "      This routine also updates VF and VL and computes the distances",
   "      between the updated singular values and the old singular",
   "      values.",
   "DLASD6 is called from DLASDA."],
 "zlaqr3"=>
  ["   Aggressive early deflation:",
   "   ZLAQR3 accepts as input an upper Hessenberg matrix",
   "   H and performs an unitary similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an unitary similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "cpftrs"=>
  ["CPFTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**H*U or A = L*L**H computed by CPFTRF."],
 "dlasyf_rk"=>
  ["DLASYF_RK computes a partial factorization of a real symmetric",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "DLASYF_RK is an auxiliary routine called by DSYTRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "cheevr"=>
  ["CHEEVR computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues.",
   "CHEEVR first reduces the matrix A to tridiagonal form T with a call",
   "to CHETRD.  Then, whenever possible, CHEEVR calls CSTEMR to compute",
   "the eigenspectrum using Relatively Robust Representations.  CSTEMR",
   "computes eigenvalues by the dqds algorithm, while orthogonal",
   "eigenvectors are computed from various \"good\" L D L^T representations",
   "(also known as Relatively Robust Representations). Gram-Schmidt",
   "orthogonalization is avoided as far as possible. More specifically,",
   "the various steps of the algorithm are as follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "The desired accuracy of the output can be specified by the input",
   "parameter ABSTOL.",
   "For more details, see DSTEMR's documentation and:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested",
   "on machines which conform to the ieee-754 floating point standard.",
   "CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and",
   "when partial spectrum requests are made.",
   "Normal execution of CSTEMR may create NaNs and infinities and",
   "hence may abort due to a floating point exception in environments",
   "which do not handle NaNs and infinities in the ieee standard default",
   "manner."],
 "dlasyf_aa"=>
  ["DLATRF_AA factorizes a panel of a real symmetric matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "stprfs"=>
  ["STPRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular packed",
   "coefficient matrix.",
   "The solution matrix X must be computed by STPTRS or some other",
   "means before entering this routine.  STPRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "dgelss"=>
  ["DGELSS computes the minimum norm solution to a real linear least",
   "squares problem:",
   "Minimize 2-norm(| b - A*x |).",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix",
   "X.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value."],
 "dlansb"=>
  ["DLANSB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n symmetric band matrix A,  with k super-diagonals.",
   "   DLANSB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "chbevx_2stage"=>
  ["CHBEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "slasy2"=>
  ["SLASY2 solves for the N1 by N2 matrix X, 1 <= N1,N2 <= 2, in",
   "       op(TL)*X + ISGN*X*op(TR) = SCALE*B,",
   "where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or",
   "-1.  op(T) = T or T**T, where T**T denotes the transpose of T."],
 "dgebak"=>
  ["DGEBAK forms the right or left eigenvectors of a real general matrix",
   "by backward transformation on the computed eigenvectors of the",
   "balanced matrix output by DGEBAL."],
 "zlahqr"=>
  ["   ZLAHQR is an auxiliary routine called by CHSEQR to update the",
   "   eigenvalues and Schur decomposition already computed by CHSEQR, by",
   "   dealing with the Hessenberg submatrix in rows and columns ILO to",
   "   IHI."],
 "zhesv"=>
  ["ZHESV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**H,  if UPLO = 'U', or",
   "   A = L * D * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "ztrevc3"=>
  ["ZTREVC3 computes some or all of the right and/or left eigenvectors of",
   "a complex upper triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "             T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of the vector y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix. If Q is the unitary factor that reduces a matrix A to",
   "Schur form T, then Q*X and Q*Y are the matrices of right and left",
   "eigenvectors of A.",
   "This uses a Level 3 BLAS version of the back transformation."],
 "ztptri"=>
  ["ZTPTRI computes the inverse of a complex upper or lower triangular",
   "matrix A stored in packed format."],
 "cgeqlf"=>
  ["CGEQLF computes a QL factorization of a complex M-by-N matrix A:",
   "A = Q * L."],
 "dlaqsy"=>
  ["DLAQSY equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "dsbev"=>
  ["DSBEV computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A."],
 "dstedc"=>
  ["DSTEDC computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method.",
   "The eigenvectors of a full or band real symmetric matrix can also be",
   "found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this",
   "matrix to tridiagonal form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See DLAED3 for details."],
 "cla_syrfsx_extended"=>
  ["CLA_SYRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by CSYRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "dla_porfsx_extended"=>
  ["DLA_PORFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by DPORFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "cunm2l"=>
  ["CUNM2L overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by CGEQLF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "spocon"=>
  ["SPOCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite matrix using the",
   "Cholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "slamtsqr"=>
  ["     SLAMTSQR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "     where Q is a real orthogonal matrix defined as the product",
   "     of blocked elementary reflectors computed by tall skinny",
   "     QR factorization (DLATSQR)"],
 "dtpmqrt"=>
  ["DTPMQRT applies a real orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "zlarfg"=>
  ["ZLARFG generates a complex elementary reflector H of order n, such",
   "that",
   "      H**H * ( alpha ) = ( beta ),   H**H * H = I.",
   "             (   x   )   (   0  )",
   "where alpha and beta are scalars, with beta real, and x is an",
   "(n-1)-element complex vector. H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**H ) ,",
   "                    ( v )",
   "where tau is a complex scalar and v is a complex (n-1)-element",
   "vector. Note that H is not hermitian.",
   "If the elements of x are all zero and alpha is real, then tau = 0",
   "and H is taken to be the unit matrix.",
   "Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 ."],
 "zsytrf_aa"=>
  ["ZSYTRF_AA computes the factorization of a complex symmetric matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**T  or  A = L*T*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a complex symmetric tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "sggqrf"=>
  ["SGGQRF computes a generalized QR factorization of an N-by-M matrix A",
   "and an N-by-P matrix B:",
   "            A = Q*R,        B = Q*T*Z,",
   "where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal",
   "matrix, and R and T assume one of the forms:",
   "if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,",
   "                (  0  ) N-M                         N   M-N",
   "                   M",
   "where R11 is upper triangular, and",
   "if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,",
   "                 P-N  N                           ( T21 ) P",
   "                                                     P",
   "where T12 or T21 is upper triangular.",
   "In particular, if B is square and nonsingular, the GQR factorization",
   "of A and B implicitly gives the QR factorization of inv(B)*A:",
   "             inv(B)*A = Z**T*(inv(T)*R)",
   "where inv(B) denotes the inverse of the matrix B, and Z**T denotes the",
   "transpose of the matrix Z."],
 "zunmr3"=>
  ["ZUNMR3 overwrites the general complex m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by ZTZRZF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dgeqr2p"=>
  ["DGEQR2P computes a QR factorization of a real m by n matrix A:",
   "A = Q * R. The diagonal entries of R are nonnegative."],
 "zggrqf"=>
  ["ZGGRQF computes a generalized RQ factorization of an M-by-N matrix A",
   "and a P-by-N matrix B:",
   "            A = R*Q,        B = Z*T*Q,",
   "where Q is an N-by-N unitary matrix, Z is a P-by-P unitary",
   "matrix, and R and T assume one of the forms:",
   "if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,",
   "                 N-M  M                           ( R21 ) N",
   "                                                     N",
   "where R12 or R21 is upper triangular, and",
   "if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,",
   "                (  0  ) P-N                         P   N-P",
   "                   N",
   "where T11 is upper triangular.",
   "In particular, if B is square and nonsingular, the GRQ factorization",
   "of A and B implicitly gives the RQ factorization of A*inv(B):",
   "             A*inv(B) = (R*inv(T))*Z**H",
   "where inv(B) denotes the inverse of the matrix B, and Z**H denotes the",
   "conjugate transpose of the matrix Z."],
 "zsycon_3"=>
  ["ZSYCON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "computed by ZSYTRF_RK or ZSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver ZSYTRS_3."],
 "zgbtrs"=>
  ["ZGBTRS solves a system of linear equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B",
   "with a general band matrix A using the LU factorization computed",
   "by ZGBTRF."],
 "sspgvd"=>
  ["SSPGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be symmetric, stored in packed format, and B is also",
   "positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlauu2"=>
  ["DLAUU2 computes the product U * U**T or L**T * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the unblocked form of the algorithm, calling Level 2 BLAS."],
 "dgbtrf"=>
  ["DGBTRF computes an LU factorization of a real m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "ssb2st_kernels"=>
  ["SSB2ST_KERNELS is an internal routine used by the SSYTRD_SB2ST",
   "subroutine."],
 "cunmbr"=>
  ["If VECT = 'Q', CUNMBR overwrites the general complex M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "If VECT = 'P', CUNMBR overwrites the general complex M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      P * C          C * P",
   "TRANS = 'C':      P**H * C       C * P**H",
   "Here Q and P**H are the unitary matrices determined by CGEBRD when",
   "reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q",
   "and P**H are defined as products of elementary reflectors H(i) and",
   "G(i) respectively.",
   "Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the",
   "order of the unitary matrix Q or P**H that is applied.",
   "If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:",
   "if nq >= k, Q = H(1) H(2) . . . H(k);",
   "if nq < k, Q = H(1) H(2) . . . H(nq-1).",
   "If VECT = 'P', A is assumed to have been a K-by-NQ matrix:",
   "if k < nq, P = G(1) G(2) . . . G(k);",
   "if k >= nq, P = G(1) G(2) . . . G(nq-1)."],
 "chptrd"=>
  ["CHPTRD reduces a complex Hermitian matrix A stored in packed form to",
   "real symmetric tridiagonal form T by a unitary similarity",
   "transformation: Q**H * A * Q = T."],
 "chbtrd"=>
  ["CHBTRD reduces a complex Hermitian band matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "dggsvd3"=>
  ["DGGSVD3 computes the generalized singular value decomposition (GSVD)",
   "of an M-by-N real matrix A and P-by-N real matrix B:",
   "      U**T*A*Q = D1*( 0 R ),    V**T*B*Q = D2*( 0 R )",
   "where U, V and Q are orthogonal matrices.",
   "Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,",
   "then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and",
   "D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\" matrices and of the",
   "following structures, respectively:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 =   L ( 0  S )",
   "            P-L ( 0  0 )",
   "                N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 )",
   "            L (  0    0   R22 )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "                  K M-K K+L-M",
   "       D1 =   K ( I  0    0   )",
   "            M-K ( 0  C    0   )",
   "                    K M-K K+L-M",
   "       D2 =   M-K ( 0  S    0  )",
   "            K+L-M ( 0  0    I  )",
   "              P-L ( 0  0    0  )",
   "                   N-K-L  K   M-K  K+L-M",
   "  ( 0 R ) =     K ( 0    R11  R12  R13  )",
   "              M-K ( 0     0   R22  R23  )",
   "            K+L-M ( 0     0    0   R33  )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "  S = diag( BETA(K+1),  ... , BETA(M) ),",
   "  C**2 + S**2 = I.",
   "  (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored",
   "  ( 0  R22 R23 )",
   "  in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The routine computes C, S, R, and optionally the orthogonal",
   "transformation matrices U, V and Q.",
   "In particular, if B is an N-by-N nonsingular matrix, then the GSVD of",
   "A and B implicitly gives the SVD of A*inv(B):",
   "                     A*inv(B) = U*(D1*inv(D2))*V**T.",
   "If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is",
   "also equal to the CS decomposition of A and B. Furthermore, the GSVD",
   "can be used to derive the solution of the eigenvalue problem:",
   "                     A**T*A x = lambda* B**T*B x.",
   "In some literature, the GSVD of A and B is presented in the form",
   "                 U**T*A*X = ( 0 D1 ),   V**T*B*X = ( 0 D2 )",
   "where U and V are orthogonal and X is nonsingular, D1 and D2 are",
   "``diagonal''.  The former GSVD form can be converted to the latter",
   "form by taking the nonsingular matrix X as",
   "                     X = Q*( I   0    )",
   "                           ( 0 inv(R) )."],
 "cpotrs"=>
  ["CPOTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A using the Cholesky factorization",
   "A = U**H*U or A = L*L**H computed by CPOTRF."],
 "dtpcon"=>
  ["DTPCON estimates the reciprocal of the condition number of a packed",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "clasyf_aa"=>
  ["DLATRF_AA factorizes a panel of a complex symmetric matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "dtrttp"=>
  ["DTRTTP copies a triangular matrix A from full format (TR) to standard",
   "packed format (TP)."],
 "slaev2"=>
  ["SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix",
   "   [  A   B  ]",
   "   [  B   C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, RT2 is the",
   "eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right",
   "eigenvector for RT1, giving the decomposition",
   "   [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]",
   "   [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ]."],
 "csycon_3"=>
  ["CSYCON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "computed by CSYTRF_RK or CSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver CSYTRS_3."],
 "dlaqtr"=>
  ["DLAQTR solves the real quasi-triangular system",
   "             op(T)*p = scale*c,               if LREAL = .TRUE.",
   "or the complex quasi-triangular systems",
   "           op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.",
   "in real arithmetic, where T is upper quasi-triangular.",
   "If LREAL = .FALSE., then the first diagonal block of T must be",
   "1 by 1, B is the specially structured matrix",
   "               B = [ b(1) b(2) ... b(n) ]",
   "                   [       w            ]",
   "                   [           w        ]",
   "                   [              .     ]",
   "                   [                 w  ]",
   "op(A) = A or A**T, A**T denotes the transpose of",
   "matrix A.",
   "On input, X = [ c ].  On output, X = [ p ].",
   "              [ d ]                  [ q ]",
   "This subroutine is designed for the condition number estimation",
   "in routine DTRSNA."],
 "sormrz"=>
  ["SORMRZ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by STZRZF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "cspsv"=>
  ["CSPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is symmetric and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "zunglq"=>
  ["ZUNGLQ generates an M-by-N complex matrix Q with orthonormal rows,",
   "which is defined as the first M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(k)**H . . . H(2)**H H(1)**H",
   "as returned by ZGELQF."],
 "zlansy"=>
  ["ZLANSY  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex symmetric matrix A.",
   "   ZLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cgetrf"=>
  ["CGETRF computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 3 BLAS version of the algorithm."],
 "dgeequ"=>
  ["DGEEQU computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "zlaqhp"=>
  ["ZLAQHP equilibrates a Hermitian matrix A using the scaling factors",
   "in the vector S."],
 "cla_gbrcond_x"=>
  ["   CLA_GBRCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX vector."],
 "zspsv"=>
  ["ZSPSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix stored in packed format and X",
   "and B are N-by-NRHS matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, D is symmetric and block diagonal with 1-by-1",
   "and 2-by-2 diagonal blocks.  The factored form of A is then used to",
   "solve the system of equations A * X = B."],
 "dgeqrt"=>
  ["DGEQRT computes a blocked QR factorization of a real M-by-N matrix A",
   "using the compact WY representation of Q."],
 "cgtsv"=>
  ["CGTSV  solves the equation",
   "   A*X = B,",
   "where A is an N-by-N tridiagonal matrix, by Gaussian elimination with",
   "partial pivoting.",
   "Note that the equation  A**T *X = B  may be solved by interchanging the",
   "order of the arguments DU and DL."],
 "zlaed7"=>
  ["ZLAED7 computes the updated eigensystem of a diagonal",
   "matrix after modification by a rank-one symmetric matrix. This",
   "routine is used only for the eigenproblem which requires all",
   "eigenvalues and optionally eigenvectors of a dense or banded",
   "Hermitian matrix that has been reduced to tridiagonal form.",
   "  T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)",
   "  where Z = Q**Hu, u is a vector of length N with ones in the",
   "  CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.",
   "   The eigenvectors of the original matrix are stored in Q, and the",
   "   eigenvalues are in D.  The algorithm consists of three stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple eigenvalues or if there is a zero in",
   "      the Z vector.  For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one.  This stage is",
   "      performed by the routine DLAED2.",
   "      The second stage consists of calculating the updated",
   "      eigenvalues. This is done by finding the roots of the secular",
   "      equation via the routine DLAED4 (as called by SLAED3).",
   "      This routine also calculates the eigenvectors of the current",
   "      problem.",
   "      The final stage consists of computing the updated eigenvectors",
   "      directly using the updated eigenvalues.  The eigenvectors for",
   "      the current problem are multiplied with the eigenvectors from",
   "      the overall problem."],
 "sgemlq"=>
  ["    SGEMLQ overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product",
   "   of blocked elementary reflectors computed by short wide LQ",
   "   factorization (SGELQ)"],
 "stzrzf"=>
  ["STZRZF reduces the M-by-N ( M<=N ) real upper trapezoidal matrix A",
   "to upper triangular form by means of orthogonal transformations.",
   "The upper trapezoidal matrix A is factored as",
   "   A = ( R  0 ) * Z,",
   "where Z is an N-by-N orthogonal matrix and R is an M-by-M upper",
   "triangular matrix."],
 "slaset"=>
  ["SLASET initializes an m-by-n matrix A to BETA on the diagonal and",
   "ALPHA on the offdiagonals."],
 "spbtrs"=>
  ["SPBTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite band matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by SPBTRF."],
 "dgetc2"=>
  ["DGETC2 computes an LU factorization with complete pivoting of the",
   "n-by-n matrix A. The factorization has the form A = P * L * U * Q,",
   "where P and Q are permutation matrices, L is lower triangular with",
   "unit diagonal elements and U is upper triangular.",
   "This is the Level 2 BLAS algorithm."],
 "dtpqrt"=>
  ["DTPQRT computes a blocked QR factorization of a real",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "zlaqsb"=>
  ["ZLAQSB equilibrates a symmetric band matrix A using the scaling",
   "factors in the vector S."],
 "ilaclr"=>["ILACLR scans A for its last non-zero row."],
 "sppsvx"=>
  ["SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dsysv_rk"=>
  ["DSYSV_RK computes the solution to a real system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "DSYTRF_RK is called to compute the factorization of a real",
   "symmetric matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine DSYTRS_3."],
 "dsbevd_2stage"=>
  ["DSBEVD_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal. If eigenvectors are desired, it uses",
   "a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cungql"=>
  ["CUNGQL generates an M-by-N complex matrix Q with orthonormal columns,",
   "which is defined as the last N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by CGEQLF."],
 "zlat2c"=>
  ["ZLAT2C converts a COMPLEX*16 triangular matrix, SA, to a COMPLEX",
   "triangular matrix, A.",
   "RMAX is the overflow for the SINGLE PRECISION arithmetic",
   "ZLAT2C checks that all the entries of A are between -RMAX and",
   "RMAX. If not the conversion is aborted and a flag is raised.",
   "This is an auxiliary routine so there is no argument checking."],
 "zgghd3"=>
  ["ZGGHD3 reduces a pair of complex matrices (A,B) to generalized upper",
   "Hessenberg form using unitary transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the unitary matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**H*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**H*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**H*x.",
   "The unitary matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H",
   "     Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H",
   "If Q1 is the unitary matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then ZGGHD3 reduces the original",
   "problem to generalized Hessenberg form.",
   "This is a blocked variant of CGGHRD, using matrix-matrix",
   "multiplications for parts of the computation to enhance performance."],
 "chetrs2"=>
  ["CHETRS2 solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF and converted by CSYCONV."],
 "dlaisnan"=>
  ["This routine is not for general use.  It exists solely to avoid",
   "over-optimization in DISNAN.",
   "DLAISNAN checks for NaNs by comparing its two arguments for",
   "inequality.  NaN is the only floating-point value where NaN != NaN",
   "returns .TRUE.  To check for NaNs, pass the same variable as both",
   "arguments.",
   "A compiler must assume that the two arguments are",
   "not the same variable, and the test will not be optimized away.",
   "Interprocedural or whole-program optimization may delete this",
   "test.  The ISNAN functions will be replaced by the correct",
   "Fortran 03 intrinsic once the intrinsic is widely available."],
 "ctpqrt"=>
  ["CTPQRT computes a blocked QR factorization of a complex",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "dbdsdc"=>
  ["DBDSDC computes the singular value decomposition (SVD) of a real",
   "N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,",
   "using a divide and conquer method, where S is a diagonal matrix",
   "with non-negative diagonal elements (the singular values of B), and",
   "U and VT are orthogonal matrices of left and right singular vectors,",
   "respectively. DBDSDC can be used to compute all singular values,",
   "and optionally, singular vectors or singular vectors in compact form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See DLASD3 for details.",
   "The code currently calls DLASDQ if singular values only are desired.",
   "However, it can be slightly modified to compute singular values",
   "using the divide and conquer method."],
 "dlaqgb"=>
  ["DLAQGB equilibrates a general M by N band matrix A with KL",
   "subdiagonals and KU superdiagonals using the row and scaling factors",
   "in the vectors R and C."],
 "cptcon"=>
  ["CPTCON computes the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite tridiagonal matrix",
   "using the factorization A = L*D*L**H or A = U**H*D*U computed by",
   "CPTTRF.",
   "Norm(inv(A)) is computed by a direct method, and the reciprocal of",
   "the condition number is computed as",
   "                 RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dlange"=>
  ["DLANGE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real matrix A.",
   "   DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dlag2"=>
  ["DLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue",
   "problem  A - w B, with scaling as necessary to avoid over-/underflow.",
   "The scaling factor \"s\" results in a modified eigenvalue equation",
   "    s A - w B",
   "where  s  is a non-negative scaling factor chosen so that  w,  w B,",
   "and  s A  do not overflow and, if possible, do not underflow, either."],
 "cgeequ"=>
  ["CGEEQU computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "ctpcon"=>
  ["CTPCON estimates the reciprocal of the condition number of a packed",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cunbdb"=>
  ["CUNBDB simultaneously bidiagonalizes the blocks of an M-by-M",
   "partitioned unitary matrix X:",
   "                                [ B11 | B12 0  0 ]",
   "    [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H",
   "X = [-----------] = [---------] [----------------] [---------]   .",
   "    [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]",
   "                                [  0  |  0  0  I ]",
   "X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is",
   "not the case, then X must be transposed and/or permuted. This can be",
   "done in constant time using the TRANS and SIGNS options. See CUNCSD",
   "for details.)",
   "The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-",
   "(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are",
   "represented implicitly by Householder vectors.",
   "B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented",
   "implicitly by angles THETA, PHI."],
 "ssyevd"=>
  ["SSYEVD computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A. If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.",
   "Because of large use of BLAS of level 3, SSYEVD needs N**2 more",
   "workspace than SSYEVX."],
 "cgetsls"=>
  ["CGETSLS solves overdetermined or underdetermined complex linear systems",
   "involving an M-by-N matrix A, using a tall skinny QR or short wide LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'C' and m >= n:  find the minimum norm solution of",
   "   an undetermined system A**T * X = B.",
   "4. If TRANS = 'C' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "dsyrfs"=>
  ["DSYRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "slaln2"=>
  ["SLALN2 solves a system of the form  (ca A - w D ) X = s B",
   "or (ca A**T - w D) X = s B   with possible scaling (\"s\") and",
   "perturbation of A.  (A**T means A-transpose.)",
   "A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA",
   "real diagonal matrix, w is a real or complex value, and X and B are",
   "NA x 1 matrices -- real if w is real, complex if w is complex.  NA",
   "may be 1 or 2.",
   "If w is complex, X and B are represented as NA x 2 matrices,",
   "the first column of each being the real part and the second",
   "being the imaginary part.",
   "\"s\" is a scaling factor (.LE. 1), computed by SLALN2, which is",
   "so chosen that X can be computed without overflow.  X is further",
   "scaled if necessary to assure that norm(ca A - w D)*norm(X) is less",
   "than overflow.",
   "If both singular values of (ca A - w D) are less than SMIN,",
   "SMIN*identity will be used instead of (ca A - w D).  If only one",
   "singular value is less than SMIN, one element of (ca A - w D) will be",
   "perturbed enough to make the smallest singular value roughly SMIN.",
   "If both singular values are at least SMIN, (ca A - w D) will not be",
   "perturbed.  In any case, the perturbation will be at most some small",
   "multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values",
   "are computed by infinity-norm approximations, and thus will only be",
   "correct to a factor of 2 or so.",
   "Note: all input quantities are assumed to be smaller than overflow",
   "by a reasonable factor.  (See BIGNUM.)"],
 "dpttrs"=>
  ["DPTTRS solves a tridiagonal system of the form",
   "   A * X = B",
   "using the L*D*L**T factorization of A computed by DPTTRF.  D is a",
   "diagonal matrix specified in the vector D, L is a unit bidiagonal",
   "matrix whose subdiagonal is specified in the vector E, and X and B",
   "are N by NRHS matrices."],
 "dzsum1"=>
  ["DZSUM1 takes the sum of the absolute values of a complex",
   "vector and returns a double precision result.",
   "Based on DZASUM from the Level 1 BLAS.",
   "The change is to use the 'genuine' absolute value."],
 "zgges"=>
  ["ZGGES computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the generalized complex Schur",
   "form (S, T), and optionally left and/or right Schur vectors (VSL",
   "and VSR). This gives the generalized Schur factorization",
   "        (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T. The leading",
   "columns of VSL and VSR then form an unitary basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "ZGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0, and even for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if S",
   "and T are upper triangular and, in addition, the diagonal elements",
   "of T are non-negative real numbers."],
 "dlartgs"=>
  ["DLARTGS generates a plane rotation designed to introduce a bulge in",
   "Golub-Reinsch-style implicit QR iteration for the bidiagonal SVD",
   "problem. X and Y are the top-row entries, and SIGMA is the shift.",
   "The computed CS and SN define a plane rotation satisfying",
   "   [  CS  SN  ]  .  [ X^2 - SIGMA ]  =  [ R ],",
   "   [ -SN  CS  ]     [    X * Y    ]     [ 0 ]",
   "with R nonnegative.  If X^2 - SIGMA and X * Y are 0, then the",
   "rotation is by PI/2."],
 "zgetc2"=>
  ["ZGETC2 computes an LU factorization, using complete pivoting, of the",
   "n-by-n matrix A. The factorization has the form A = P * L * U * Q,",
   "where P and Q are permutation matrices, L is lower triangular with",
   "unit diagonal elements and U is upper triangular.",
   "This is a level 1 BLAS version of the algorithm."],
 "slahr2"=>
  ["SLAHR2 reduces the first NB columns of A real general n-BY-(n-k+1)",
   "matrix A so that elements below the k-th subdiagonal are zero. The",
   "reduction is performed by an orthogonal similarity transformation",
   "Q**T * A * Q. The routine returns the matrices V and T which determine",
   "Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.",
   "This is an auxiliary routine called by SGEHRD."],
 "slaqr0"=>
  ["   SLAQR0 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "zgsvj0"=>
  ["ZGSVJ0 is called from ZGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as ZGESVJ does, but",
   "it does not check convergence (stopping criterion). Few tuning",
   "parameters (marked by [TP]) are available for the implementer."],
 "clarzb"=>
  ["CLARZB applies a complex block reflector H or its transpose H**H",
   "to a complex distributed M-by-N  C from the left or the right.",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "dsyswapr"=>
  ["DSYSWAPR applies an elementary permutation on the rows and the columns of",
   "a symmetric matrix."],
 "csycon"=>
  ["CSYCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by CSYTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "claqhb"=>
  ["CLAQHB equilibrates an Hermitian band matrix A using the scaling",
   "factors in the vector S."],
 "zsytrs_3"=>
  ["ZSYTRS_3 solves a system of linear equations A * X = B with a complex",
   "symmetric matrix A using the factorization computed",
   "by ZSYTRF_RK or ZSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "dormhr"=>
  ["DORMHR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "IHI-ILO elementary reflectors, as returned by DGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "zgeqr"=>["ZGEQR computes a QR factorization of an M-by-N matrix A."],
 "zlartg"=>
  ["ZLARTG generates a plane rotation so that",
   "   [  CS  SN  ]     [ F ]     [ R ]",
   "   [  __      ]  .  [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a faster version of the BLAS1 routine ZROTG, except for",
   "the following differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=1 and SN=0.",
   "   If F=0, then CS=0 and SN is chosen so that R is real."],
 "ctpmlqt"=>
  ["CTPMQRT applies a complex orthogonal matrix Q obtained from a",
   "\"triangular-pentagonal\" real block reflector H to a general",
   "real matrix C, which consists of two blocks A and B."],
 "stpcon"=>
  ["STPCON estimates the reciprocal of the condition number of a packed",
   "triangular matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cgeqrfp"=>
  ["CGEQRFP computes a QR factorization of a complex M-by-N matrix A:",
   "A = Q * R. The diagonal entries of R are real and nonnegative."],
 "slacn2"=>
  ["SLACN2 estimates the 1-norm of a square, real matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "spotri"=>
  ["SPOTRI computes the inverse of a real symmetric positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by SPOTRF."],
 "zlarf"=>
  ["ZLARF applies a complex elementary reflector H to a complex M-by-N",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "To apply H**H, supply conjg(tau) instead",
   "tau."],
 "dlals0"=>
  ["DLALS0 applies back the multiplying factors of either the left or the",
   "right singular vector matrix of a diagonal matrix appended by a row",
   "to the right hand side matrix B in solving the least squares problem",
   "using the divide-and-conquer SVD approach.",
   "For the left singular vector matrix, three types of orthogonal",
   "matrices are involved:",
   "(1L) Givens rotations: the number of such rotations is GIVPTR; the",
   "     pairs of columns/rows they were applied to are stored in GIVCOL;",
   "     and the C- and S-values of these rotations are stored in GIVNUM.",
   "(2L) Permutation. The (NL+1)-st row of B is to be moved to the first",
   "     row, and for J=2:N, PERM(J)-th row of B is to be moved to the",
   "     J-th row.",
   "(3L) The left singular vector matrix of the remaining matrix.",
   "For the right singular vector matrix, four types of orthogonal",
   "matrices are involved:",
   "(1R) The right singular vector matrix of the remaining matrix.",
   "(2R) If SQRE = 1, one extra Givens rotation to generate the right",
   "     null space.",
   "(3R) The inverse transformation of (2L).",
   "(4R) The inverse transformation of (1L)."],
 "slaed0"=>
  ["SLAED0 computes all eigenvalues and corresponding eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method."],
 "dlaebz"=>
  ["DLAEBZ contains the iteration loops which compute and use the",
   "function N(w), which is the count of eigenvalues of a symmetric",
   "tridiagonal matrix T less than or equal to its argument  w.  It",
   "performs a choice of two types of loops:",
   "IJOB=1, followed by",
   "IJOB=2: It takes as input a list of intervals and returns a list of",
   "        sufficiently small intervals whose union contains the same",
   "        eigenvalues as the union of the original intervals.",
   "        The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.",
   "        The output interval (AB(j,1),AB(j,2)] will contain",
   "        eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.",
   "IJOB=3: It performs a binary search in each input interval",
   "        (AB(j,1),AB(j,2)] for a point  w(j)  such that",
   "        N(w(j))=NVAL(j), and uses  C(j)  as the starting point of",
   "        the search.  If such a w(j) is found, then on output",
   "        AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output",
   "        (AB(j,1),AB(j,2)] will be a small interval containing the",
   "        point where N(w) jumps through NVAL(j), unless that point",
   "        lies outside the initial interval.",
   "Note that the intervals are in all cases half-open intervals,",
   "i.e., of the form  (a,b] , which includes  b  but not  a .",
   "To avoid underflow, the matrix should be scaled so that its largest",
   "element is no greater than  overflow**(1/2) * underflow**(1/4)",
   "in absolute value.  To assure the most accurate computation",
   "of small eigenvalues, the matrix should be scaled to be",
   "not much smaller than that, either.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966",
   "Note: the arguments are, in general, *not* checked for unreasonable",
   "values."],
 "sgeequb"=>
  ["SGEEQUB computes row and column scalings intended to equilibrate an",
   "M-by-N matrix A and reduce its condition number.  R returns the row",
   "scale factors and C the column scale factors, chosen to try to make",
   "the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most",
   "the radix.",
   "R(i) and C(j) are restricted to be a power of the radix between",
   "SMLNUM = smallest safe number and BIGNUM = largest safe number.  Use",
   "of these scaling factors is not guaranteed to reduce the condition",
   "number of A but works well in practice.",
   "This routine differs from SGEEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled entries' magnitudes are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "slasdt"=>
  ["SLASDT creates a tree of subproblems for bidiagonal divide and",
   "conquer."],
 "zlarfb"=>
  ["ZLARFB applies a complex block reflector H or its transpose H**H to a",
   "complex M-by-N matrix C, from either the left or the right."],
 "dorgql"=>
  ["DORGQL generates an M-by-N real matrix Q with orthonormal columns,",
   "which is defined as the last N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by DGEQLF."],
 "zggglm"=>
  ["ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:",
   "        minimize || y ||_2   subject to   d = A*x + B*y",
   "            x",
   "where A is an N-by-M matrix, B is an N-by-P matrix, and d is a",
   "given N-vector. It is assumed that M <= N <= M+P, and",
   "           rank(A) = M    and    rank( A B ) = N.",
   "Under these assumptions, the constrained equation is always",
   "consistent, and there is a unique solution x and a minimal 2-norm",
   "solution y, which is obtained using a generalized QR factorization",
   "of the matrices (A, B) given by",
   "   A = Q*(R),   B = Q*T*Z.",
   "         (0)",
   "In particular, if matrix B is square nonsingular, then the problem",
   "GLM is equivalent to the following weighted linear least squares",
   "problem",
   "             minimize || inv(B)*(d-A*x) ||_2",
   "                 x",
   "where inv(B) denotes the inverse of B."],
 "cpttrf"=>
  ["CPTTRF computes the L*D*L**H factorization of a complex Hermitian",
   "positive definite tridiagonal matrix A.  The factorization may also",
   "be regarded as having the form A = U**H *D*U."],
 "chpgvd"=>
  ["CHPGVD computes all the eigenvalues and, optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and",
   "B are assumed to be Hermitian, stored in packed format, and B is also",
   "positive definite.",
   "If eigenvectors are desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "claev2"=>
  ["CLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix",
   "   [  A         B  ]",
   "   [  CONJG(B)  C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, RT2 is the",
   "eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right",
   "eigenvector for RT1, giving the decomposition",
   "[ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]",
   "[-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ]."],
 "dlapy2"=>
  ["DLAPY2 returns sqrt(x**2+y**2), taking care not to cause unnecessary",
   "overflow."],
 "dpbtf2"=>
  ["DPBTF2 computes the Cholesky factorization of a real symmetric",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**T * U ,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix, U**T is the transpose of U, and",
   "L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "cheev"=>
  ["CHEEV computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A."],
 "dgbtf2"=>
  ["DGBTF2 computes an LU factorization of a real m-by-n band matrix A",
   "using partial pivoting with row interchanges.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "chetrf"=>
  ["CHETRF computes the factorization of a complex Hermitian matrix A",
   "using the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "dgesvx"=>
  ["DGESVX uses the LU factorization to compute the solution to a real",
   "system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "clamtsqr"=>
  ["     CLAMTSQR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**C * C       C * Q**C",
   "     where Q is a real orthogonal matrix defined as the product",
   "     of blocked elementary reflectors computed by tall skinny",
   "     QR factorization (CLATSQR)"],
 "zlauu2"=>
  ["ZLAUU2 computes the product U * U**H or L**H * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the unblocked form of the algorithm, calling Level 2 BLAS."],
 "ssysv_rook"=>
  ["SSYSV_ROOK computes the solution to a real system of linear",
   "equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "SSYTRF_ROOK is called to compute the factorization of a real",
   "symmetric matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method.",
   "The factored form of A is then used to solve the system",
   "of equations A * X = B by calling SSYTRS_ROOK."],
 "zspcon"=>
  ["ZSPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex symmetric packed matrix A using the",
   "factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dlarrr"=>
  ["Perform tests to decide whether the symmetric tridiagonal matrix T",
   "warrants expensive computations which guarantee high relative accuracy",
   "in the eigenvalues."],
 "zlaswp"=>
  ["ZLASWP performs a series of row interchanges on the matrix A.",
   "One row interchange is initiated for each of rows K1 through K2 of A."],
 "zggqrf"=>
  ["ZGGQRF computes a generalized QR factorization of an N-by-M matrix A",
   "and an N-by-P matrix B:",
   "            A = Q*R,        B = Q*T*Z,",
   "where Q is an N-by-N unitary matrix, Z is a P-by-P unitary matrix,",
   "and R and T assume one of the forms:",
   "if N >= M,  R = ( R11 ) M  ,   or if N < M,  R = ( R11  R12 ) N,",
   "                (  0  ) N-M                         N   M-N",
   "                   M",
   "where R11 is upper triangular, and",
   "if N <= P,  T = ( 0  T12 ) N,   or if N > P,  T = ( T11 ) N-P,",
   "                 P-N  N                           ( T21 ) P",
   "                                                     P",
   "where T12 or T21 is upper triangular.",
   "In particular, if B is square and nonsingular, the GQR factorization",
   "of A and B implicitly gives the QR factorization of inv(B)*A:",
   "             inv(B)*A = Z**H * (inv(T)*R)",
   "where inv(B) denotes the inverse of the matrix B, and Z**H denotes the",
   "conjugate transpose of matrix Z."],
 "slarrf"=>
  ["Given the initial representation L D L^T and its cluster of close",
   "eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...",
   "W( CLEND ), SLARRF finds a new relatively robust representation",
   "L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the",
   "eigenvalues of L(+) D(+) L(+)^T is relatively isolated."],
 "spbtrf"=>
  ["SPBTRF computes the Cholesky factorization of a real symmetric",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "zgehrd"=>
  ["ZGEHRD reduces a complex general matrix A to upper Hessenberg form H by",
   "an unitary similarity transformation:  Q**H * A * Q = H ."],
 "spprfs"=>
  ["SPPRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and packed, and provides error bounds and backward error estimates",
   "for the solution."],
 "dgesvxx"=>
  ["   DGESVXX uses the LU factorization to compute the solution to a",
   "   double precision system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. DGESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   DGESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   DGESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what DGESVXX would itself produce."],
 "cpbequ"=>
  ["CPBEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite band matrix A and reduce its condition",
   "number (with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "dsytrs_3"=>
  ["DSYTRS_3 solves a system of linear equations A * X = B with a real",
   "symmetric matrix A using the factorization computed",
   "by DSYTRF_RK or DSYTRF_BK:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This algorithm is using Level 3 BLAS."],
 "zgeqrt"=>
  ["ZGEQRT computes a blocked QR factorization of a complex M-by-N matrix A",
   "using the compact WY representation of Q."],
 "zlaev2"=>
  ["ZLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix",
   "   [  A         B  ]",
   "   [  CONJG(B)  C  ].",
   "On return, RT1 is the eigenvalue of larger absolute value, RT2 is the",
   "eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right",
   "eigenvector for RT1, giving the decomposition",
   "[ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]",
   "[-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ]."],
 "zpbcon"=>
  ["ZPBCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite band matrix using",
   "the Cholesky factorization A = U**H*U or A = L*L**H computed by",
   "ZPBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "sgeqr"=>["SGEQR computes a QR factorization of an M-by-N matrix A."],
 "strrfs"=>
  ["STRRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular",
   "coefficient matrix.",
   "The solution matrix X must be computed by STRTRS or some other",
   "means before entering this routine.  STRRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "dtprfs"=>
  ["DTPRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular packed",
   "coefficient matrix.",
   "The solution matrix X must be computed by DTPTRS or some other",
   "means before entering this routine.  DTPRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "sgesvd"=>
  ["SGESVD computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors. The SVD is written",
   "     A = U * SIGMA * transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and",
   "V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns V**T, not V."],
 "dpbtrs"=>
  ["DPBTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite band matrix A using the Cholesky factorization",
   "A = U**T*U or A = L*L**T computed by DPBTRF."],
 "ssbev_2stage"=>
  ["SSBEV_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "zpoequ"=>
  ["ZPOEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "ilaenv"=>
  ["ILAENV is called from the LAPACK routines to choose problem-dependent",
   "parameters for the local environment.  See ISPEC for a description of",
   "the parameters.",
   "ILAENV returns an INTEGER",
   "if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC",
   "if ILAENV < 0:  if ILAENV = -k, the k-th argument had an illegal value.",
   "This version provides a set of parameters which should give good,",
   "but not optimal, performance on many of the currently available",
   "computers.  Users are encouraged to modify this subroutine to set",
   "the tuning parameters for their particular machine using the option",
   "and problem size information in the arguments.",
   "This routine will not function correctly if it is converted to all",
   "lower case.  Converting it to all upper case is allowed."],
 "zsysv_aa"=>
  ["ZSYSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**T,  if UPLO = 'U', or",
   "   A = L * T * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is symmetric tridiagonal. The factored",
   "form of A is then used to solve the system of equations A * X = B."],
 "chetri"=>
  ["CHETRI computes the inverse of a complex Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "CHETRF."],
 "clarfgp"=>
  ["CLARFGP generates a complex elementary reflector H of order n, such",
   "that",
   "      H**H * ( alpha ) = ( beta ),   H**H * H = I.",
   "             (   x   )   (   0  )",
   "where alpha and beta are scalars, beta is real and non-negative, and",
   "x is an (n-1)-element complex vector.  H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**H ) ,",
   "                    ( v )",
   "where tau is a complex scalar and v is a complex (n-1)-element",
   "vector. Note that H is not hermitian.",
   "If the elements of x are all zero and alpha is real, then tau = 0",
   "and H is taken to be the unit matrix."],
 "clahef_rook"=>
  ["CLAHEF_ROOK computes a partial factorization of a complex Hermitian",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting",
   "method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0      I     )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**H denotes the conjugate transpose of U.",
   "CLAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "sgghd3"=>
  ["SGGHD3 reduces a pair of real matrices (A,B) to generalized upper",
   "Hessenberg form using orthogonal transformations, where A is a",
   "general matrix and B is upper triangular.  The form of the",
   "generalized eigenvalue problem is",
   "   A*x = lambda*B*x,",
   "and B is typically made upper triangular by computing its QR",
   "factorization and moving the orthogonal matrix Q to the left side",
   "of the equation.",
   "This subroutine simultaneously reduces A to a Hessenberg matrix H:",
   "   Q**T*A*Z = H",
   "and transforms B to another upper triangular matrix T:",
   "   Q**T*B*Z = T",
   "in order to reduce the problem to its standard form",
   "   H*y = lambda*T*y",
   "where y = Z**T*x.",
   "The orthogonal matrices Q and Z are determined as products of Givens",
   "rotations.  They may either be formed explicitly, or they may be",
   "postmultiplied into input matrices Q1 and Z1, so that",
   "     Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T",
   "     Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T",
   "If Q1 is the orthogonal matrix from the QR factorization of B in the",
   "original equation A*x = lambda*B*x, then SGGHD3 reduces the original",
   "problem to generalized Hessenberg form.",
   "This is a blocked variant of SGGHRD, using matrix-matrix",
   "multiplications for parts of the computation to enhance performance."],
 "clatrd"=>
  ["CLATRD reduces NB rows and columns of a complex Hermitian matrix A to",
   "Hermitian tridiagonal form by a unitary similarity",
   "transformation Q**H * A * Q, and returns the matrices V and W which are",
   "needed to apply the transformation to the unreduced part of A.",
   "If UPLO = 'U', CLATRD reduces the last NB rows and columns of a",
   "matrix, of which the upper triangle is supplied;",
   "if UPLO = 'L', CLATRD reduces the first NB rows and columns of a",
   "matrix, of which the lower triangle is supplied.",
   "This is an auxiliary routine called by CHETRD."],
 "cunmrq"=>
  ["CUNMRQ overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1)**H H(2)**H . . . H(k)**H",
   "as returned by CGERQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "strevc"=>
  ["STREVC computes some or all of the right and/or left eigenvectors of",
   "a real upper quasi-triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "   T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal blocks of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix.  If Q is the orthogonal factor that reduces a matrix",
   "A to Schur form T, then Q*X and Q*Y are the matrices of right and",
   "left eigenvectors of A."],
 "dggev"=>
  ["DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j).",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B .",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "slag2"=>
  ["SLAG2 computes the eigenvalues of a 2 x 2 generalized eigenvalue",
   "problem  A - w B, with scaling as necessary to avoid over-/underflow.",
   "The scaling factor \"s\" results in a modified eigenvalue equation",
   "    s A - w B",
   "where  s  is a non-negative scaling factor chosen so that  w,  w B,",
   "and  s A  do not overflow and, if possible, do not underflow, either."],
 "dgesvj"=>
  ["DGESVJ computes the singular value decomposition (SVD) of a real",
   "M-by-N matrix A, where M >= N. The SVD of A is written as",
   "                                   [++]   [xx]   [x0]   [xx]",
   "             A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]",
   "                                   [++]   [xx]",
   "where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal",
   "matrix, and V is an N-by-N orthogonal matrix. The diagonal elements",
   "of SIGMA are the singular values of A. The columns of U and V are the",
   "left and the right singular vectors of A, respectively.",
   "DGESVJ can sometimes compute tiny singular values and their singular vectors much",
   "more accurately than other SVD routines, see below under Further Details."],
 "dpoequ"=>
  ["DPOEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "clantp"=>
  ["CLANTP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "triangular matrix A, supplied in packed form.",
   "   CLANTP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zggevx"=>
  ["ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B) the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "Optionally, it also computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for",
   "the eigenvalues (RCONDE), and reciprocal condition numbers for the",
   "right eigenvectors (RCONDV).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j) .",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B.",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "zposvx"=>
  ["ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "slamrg"=>
  ["SLAMRG will create a permutation list which will merge the elements",
   "of A (which is composed of two independently sorted sets) into a",
   "single set which is sorted in ascending order."],
 "claein"=>
  ["CLAEIN uses inverse iteration to find a right or left eigenvector",
   "corresponding to the eigenvalue W of a complex upper Hessenberg",
   "matrix H."],
 "dtfttr"=>
  ["DTFTTR copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard full format (TR)."],
 "ssptri"=>
  ["SSPTRI computes the inverse of a real symmetric indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by SSPTRF."],
 "sorglq"=>
  ["SORGLQ generates an M-by-N real matrix Q with orthonormal rows,",
   "which is defined as the first M rows of a product of K elementary",
   "reflectors of order N",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by SGELQF."],
 "sgerqf"=>
  ["SGERQF computes an RQ factorization of a real M-by-N matrix A:",
   "A = R * Q."],
 "zlapll"=>
  ["Given two column vectors X and Y, let",
   "                     A = ( X Y ).",
   "The subroutine first computes the QR factorization of A = Q*R,",
   "and then computes the SVD of the 2-by-2 upper triangular matrix R.",
   "The smaller singular value of R is returned in SSMIN, which is used",
   "as the measurement of the linear dependency of the vectors X and Y."],
 "zlar2v"=>
  ["ZLAR2V applies a vector of complex plane rotations with real cosines",
   "from both sides to a sequence of 2-by-2 complex Hermitian matrices,",
   "defined by the elements of the vectors x, y and z. For i = 1,2,...,n",
   "   (       x(i)  z(i) ) :=",
   "   ( conjg(z(i)) y(i) )",
   "     (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )",
   "     ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )"],
 "dlarrd"=>
  ["DLARRD computes the eigenvalues of a symmetric tridiagonal",
   "matrix T to suitable accuracy. This is an auxiliary code to be",
   "called from DSTEMR.",
   "The user may ask for all eigenvalues, all eigenvalues",
   "in the half-open interval (VL, VU], or the IL-th through IU-th",
   "eigenvalues.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "zlangb"=>
  ["ZLANGB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.",
   "   ZLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "cla_gerfsx_extended"=>
  ["CLA_GERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by CGERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERRS_N",
   "and ERRS_C for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERRS_N and ERRS_C."],
 "dlamrg"=>
  ["DLAMRG will create a permutation list which will merge the elements",
   "of A (which is composed of two independently sorted sets) into a",
   "single set which is sorted in ascending order."],
 "zhesvxx"=>
  ["   ZHESVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a complex*16 system of linear equations A * X = B, where",
   "   A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "   matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. ZHESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   ZHESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   ZHESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what ZHESVXX would itself produce."],
 "sptrfs"=>
  ["SPTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric positive definite",
   "and tridiagonal, and provides error bounds and backward error",
   "estimates for the solution."],
 "cgemlqt"=>
  ["CGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'C':   Q**C C            C Q**C",
   "where Q is a complex orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V C V**C",
   "generated using the compact WY representation as returned by CGELQT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "cgeqr"=>["CGEQR computes a QR factorization of an M-by-N matrix A."],
 "dgeqr2"=>
  ["DGEQR2 computes a QR factorization of a real m by n matrix A:",
   "A = Q * R."],
 "dlaein"=>
  ["DLAEIN uses inverse iteration to find a right or left eigenvector",
   "corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg",
   "matrix H."],
 "ssyevd_2stage"=>
  ["SSYEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal. If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "csyr"=>
  ["CSYR   performs the symmetric rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a complex scalar, x is an n element vector and A is an",
   "n by n symmetric matrix."],
 "zlassq"=>
  ["ZLASSQ returns the values scl and ssq such that",
   "   ( scl**2 )*ssq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,",
   "where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is",
   "assumed to be at least unity and the value of ssq will then satisfy",
   "   1.0 .le. ssq .le. ( sumsq + 2*n ).",
   "scale is assumed to be non-negative and scl returns the value",
   "   scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),",
   "          i",
   "scale and sumsq must be supplied in SCALE and SUMSQ respectively.",
   "SCALE and SUMSQ are overwritten by scl and ssq respectively.",
   "The routine makes only one pass through the vector X."],
 "csytri_3"=>
  ["CSYTRI_3 computes the inverse of a complex symmetric indefinite",
   "matrix A using the factorization computed by CSYTRF_RK or CSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "CSYTRI_3 sets the leading dimension of the workspace  before calling",
   "CSYTRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "claqhp"=>
  ["CLAQHP equilibrates a Hermitian matrix A using the scaling factors",
   "in the vector S."],
 "zppequ"=>
  ["ZPPEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A in packed storage and reduce",
   "its condition number (with respect to the two-norm).  S contains the",
   "scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix",
   "B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.",
   "This choice of S puts the condition number of B within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "clatsqr"=>
  ["SLATSQR computes a blocked Tall-Skinny QR factorization of",
   "an M-by-N matrix A, where M >= N:",
   "A = Q * R ."],
 "spteqr"=>
  ["SPTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric positive definite tridiagonal matrix by first factoring the",
   "matrix using SPTTRF, and then calling SBDSQR to compute the singular",
   "values of the bidiagonal factor.",
   "This routine computes the eigenvalues of the positive definite",
   "tridiagonal matrix to high relative accuracy.  This means that if the",
   "eigenvalues range over many orders of magnitude in size, then the",
   "small eigenvalues and corresponding eigenvectors will be computed",
   "more accurately than, for example, with the standard QR method.",
   "The eigenvectors of a full or band symmetric positive definite matrix",
   "can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to",
   "reduce this matrix to tridiagonal form. (The reduction to tridiagonal",
   "form, however, may preclude the possibility of obtaining high",
   "relative accuracy in the small eigenvalues of the original matrix, if",
   "these eigenvalues range over many orders of magnitude.)"],
 "zhptri"=>
  ["ZHPTRI computes the inverse of a complex Hermitian indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHPTRF."],
 "zgesvx"=>
  ["ZGESVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "srscl"=>
  ["SRSCL multiplies an n-element real vector x by the real scalar 1/a.",
   "This is done without overflow or underflow as long as",
   "the final result x/a does not overflow or underflow."],
 "zggsvp3"=>
  ["ZGGSVP3 computes unitary matrices U, V and Q such that",
   "                   N-K-L  K    L",
   " U**H*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;",
   "                L ( 0     0   A23 )",
   "            M-K-L ( 0     0    0  )",
   "                 N-K-L  K    L",
   "        =     K ( 0    A12  A13 )  if M-K-L < 0;",
   "            M-K ( 0     0   A23 )",
   "                 N-K-L  K    L",
   " V**H*B*Q =   L ( 0     0   B13 )",
   "            P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective",
   "numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H.",
   "This decomposition is the preprocessing step for computing the",
   "Generalized Singular Value Decomposition (GSVD), see subroutine",
   "ZGGSVD3."],
 "clauu2"=>
  ["CLAUU2 computes the product U * U**H or L**H * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the unblocked form of the algorithm, calling Level 2 BLAS."],
 "csytrf_aa"=>
  ["CSYTRF_AA computes the factorization of a complex symmetric matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**T  or  A = L*T*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a complex symmetric tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "zgetrf2"=>
  ["ZGETRF2 computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = min(m,n)/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "                                      [ A11 ]",
   "The subroutine calls itself to factor [ --- ],",
   "                                      [ A12 ]",
   "                [ A12 ]",
   "do the swaps on [ --- ], solve A12, update A22,",
   "                [ A22 ]",
   "then calls itself to factor A22 and do the swaps on A21."],
 "ssytri_3"=>
  ["SSYTRI_3 computes the inverse of a real symmetric indefinite",
   "matrix A using the factorization computed by SSYTRF_RK or SSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "SSYTRI_3 sets the leading dimension of the workspace  before calling",
   "SSYTRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "dlas2"=>
  ["DLAS2  computes the singular values of the 2-by-2 matrix",
   "   [  F   G  ]",
   "   [  0   H  ].",
   "On return, SSMIN is the smaller singular value and SSMAX is the",
   "larger singular value."],
 "dorbdb3"=>[],
 "ssyevx_2stage"=>
  ["SSYEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "zlarrv"=>
  ["ZLARRV computes the eigenvectors of the tridiagonal matrix",
   "T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.",
   "The input eigenvalues should have been computed by DLARRE."],
 "dspgst"=>
  ["DSPGST reduces a real symmetric-definite generalized eigenproblem",
   "to standard form, using packed storage.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**T)*A*inv(U) or inv(L)*A*inv(L**T)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**T or L**T*A*L.",
   "B must have been previously factorized as U**T*U or L*L**T by DPPTRF."],
 "cgetf2"=>
  ["CGETF2 computes an LU factorization of a general m-by-n matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the right-looking Level 2 BLAS version of the algorithm."],
 "zhetf2_rook"=>
  ["ZHETF2_ROOK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**H is the conjugate transpose of U, and D is",
   "Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zhbevd_2stage"=>
  ["ZHBEVD_2STAGE computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlacn2"=>
  ["DLACN2 estimates the 1-norm of a square, real matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "dlarfg"=>
  ["DLARFG generates a real elementary reflector H of order n, such",
   "that",
   "      H * ( alpha ) = ( beta ),   H**T * H = I.",
   "          (   x   )   (   0  )",
   "where alpha and beta are scalars, and x is an (n-1)-element real",
   "vector. H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**T ) ,",
   "                    ( v )",
   "where tau is a real scalar and v is a real (n-1)-element",
   "vector.",
   "If the elements of x are all zero, then tau = 0 and H is taken to be",
   "the unit matrix.",
   "Otherwise  1 <= tau <= 2."],
 "dlaset"=>
  ["DLASET initializes an m-by-n matrix A to BETA on the diagonal and",
   "ALPHA on the offdiagonals."],
 "dgeqlf"=>
  ["DGEQLF computes a QL factorization of a real M-by-N matrix A:",
   "A = Q * L."],
 "scsum1"=>
  ["SCSUM1 takes the sum of the absolute values of a complex",
   "vector and returns a single precision result.",
   "Based on SCASUM from the Level 1 BLAS.",
   "The change is to use the 'genuine' absolute value."],
 "csytrs_rook"=>
  ["CSYTRS_ROOK solves a system of linear equations A*X = B with",
   "a complex symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by CSYTRF_ROOK."],
 "dlarfx"=>
  ["DLARFX applies a real elementary reflector H to a real m by n",
   "matrix C, from either the left or the right. H is represented in the",
   "form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix",
   "This version uses inline code if H has order < 11."],
 "dstev"=>
  ["DSTEV computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric tridiagonal matrix A."],
 "clasyf_rook"=>
  ["CLASYF_ROOK computes a partial factorization of a complex symmetric",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "CLASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "sgees"=>
  ["SGEES computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues, the real Schur form T, and, optionally, the matrix of",
   "Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "real Schur form so that selected eigenvalues are at the top left.",
   "The leading columns of Z then form an orthonormal basis for the",
   "invariant subspace corresponding to the selected eigenvalues.",
   "A matrix is in real Schur form if it is upper quasi-triangular with",
   "1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the",
   "form",
   "        [  a  b  ]",
   "        [  c  a  ]",
   "where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc)."],
 "claqr3"=>
  ["   Aggressive early deflation:",
   "   CLAQR3 accepts as input an upper Hessenberg matrix",
   "   H and performs an unitary similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an unitary similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "sporfsx"=>
  ["   SPORFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric positive",
   "   definite, and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "slatrd"=>
  ["SLATRD reduces NB rows and columns of a real symmetric matrix A to",
   "symmetric tridiagonal form by an orthogonal similarity",
   "transformation Q**T * A * Q, and returns the matrices V and W which are",
   "needed to apply the transformation to the unreduced part of A.",
   "If UPLO = 'U', SLATRD reduces the last NB rows and columns of a",
   "matrix, of which the upper triangle is supplied;",
   "if UPLO = 'L', SLATRD reduces the first NB rows and columns of a",
   "matrix, of which the lower triangle is supplied.",
   "This is an auxiliary routine called by SSYTRD."],
 "dgemqrt"=>
  ["DGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'T':   Q**T C            C Q**T",
   "where Q is a real orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**T",
   "generated using the compact WY representation as returned by DGEQRT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "clasyf_rk"=>
  ["CLASYF_RK computes a partial factorization of a complex symmetric",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "CLASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "dsytrs_aa"=>
  ["DSYTRS_AA solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*T*U**T or",
   "A = L*T*L**T computed by DSYTRF_AA."],
 "dlasdt"=>
  ["DLASDT creates a tree of subproblems for bidiagonal divide and",
   "conquer."],
 "claqps"=>
  ["CLAQPS computes a step of QR factorization with column pivoting",
   "of a complex M-by-N matrix A by using Blas-3.  It tries to factorize",
   "NB columns from A starting from the row OFFSET+1, and updates all",
   "of the matrix with Blas-3 xGEMM.",
   "In some cases, due to catastrophic cancellations, it cannot",
   "factorize NB columns.  Hence, the actual number of factorized",
   "columns is returned in KB.",
   "Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "dpptrf"=>
  ["DPPTRF computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A stored in packed format.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "clacn2"=>
  ["CLACN2 estimates the 1-norm of a square, complex matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "slatbs"=>
  ["SLATBS solves one of the triangular systems",
   "   A *x = s*b  or  A**T*x = s*b",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular band matrix.  Here A**T denotes the transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine STBSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "sla_porcond"=>
  ["   SLA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)",
   "   where op2 is determined by CMODE as follows",
   "   CMODE =  1    op2(C) = C",
   "   CMODE =  0    op2(C) = I",
   "   CMODE = -1    op2(C) = inv(C)",
   "   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )",
   "   is computed by computing scaling factors R such that",
   "   diag(R)*A*op2(C) is row equilibrated and computing the standard",
   "   infinity-norm condition number."],
 "zpstrf"=>
  ["ZPSTRF computes the Cholesky factorization with complete",
   "pivoting of a complex Hermitian positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**H * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 3 BLAS."],
 "zsytri_3x"=>
  ["ZSYTRI_3X computes the inverse of a complex symmetric indefinite",
   "matrix A using the factorization computed by ZSYTRF_RK or ZSYTRF_BK:",
   "    A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "zunm2l"=>
  ["ZUNM2L overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by ZGEQLF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "dlaqps"=>
  ["DLAQPS computes a step of QR factorization with column pivoting",
   "of a real M-by-N matrix A by using Blas-3.  It tries to factorize",
   "NB columns from A starting from the row OFFSET+1, and updates all",
   "of the matrix with Blas-3 xGEMM.",
   "In some cases, due to catastrophic cancellations, it cannot",
   "factorize NB columns.  Hence, the actual number of factorized",
   "columns is returned in KB.",
   "Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "slagtm"=>
  ["SLAGTM performs a matrix-vector product of the form",
   "   B := alpha * A * X + beta * B",
   "where A is a tridiagonal matrix of order N, B and X are N by NRHS",
   "matrices, and alpha and beta are real scalars, each of which may be",
   "0., 1., or -1."],
 "cggsvp3"=>
  ["CGGSVP3 computes unitary matrices U, V and Q such that",
   "                   N-K-L  K    L",
   " U**H*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;",
   "                L ( 0     0   A23 )",
   "            M-K-L ( 0     0    0  )",
   "                 N-K-L  K    L",
   "        =     K ( 0    A12  A13 )  if M-K-L < 0;",
   "            M-K ( 0     0   A23 )",
   "                 N-K-L  K    L",
   " V**H*B*Q =   L ( 0     0   B13 )",
   "            P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective",
   "numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H.",
   "This decomposition is the preprocessing step for computing the",
   "Generalized Singular Value Decomposition (GSVD), see subroutine",
   "CGGSVD3."],
 "sgbequ"=>
  ["SGBEQU computes row and column scalings intended to equilibrate an",
   "M-by-N band matrix A and reduce its condition number.  R returns the",
   "row scale factors and C the column scale factors, chosen to try to",
   "make the largest element in each row and column of the matrix B with",
   "elements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.",
   "R(i) and C(j) are restricted to be between SMLNUM = smallest safe",
   "number and BIGNUM = largest safe number.  Use of these scaling",
   "factors is not guaranteed to reduce the condition number of A but",
   "works well in practice."],
 "sstevx"=>
  ["SSTEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix A.  Eigenvalues and",
   "eigenvectors can be selected by specifying either a range of values",
   "or a range of indices for the desired eigenvalues."],
 "cgerfs"=>
  ["CGERFS improves the computed solution to a system of linear",
   "equations and provides error bounds and backward error estimates for",
   "the solution."],
 "icmax1"=>
  ["ICMAX1 finds the index of the first vector element of maximum absolute value.",
   "Based on ICAMAX from Level 1 BLAS.",
   "The change is to use the 'genuine' absolute value."],
 "dormql"=>
  ["DORMQL overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "sgbrfsx"=>
  ["   SGBRFSX improves the computed solution to a system of linear",
   "   equations and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED, R",
   "   and C below. In this case, the solution and error bounds returned",
   "   are for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "zhecon_3"=>
  ["ZHECON_3 estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian matrix A using the factorization",
   "computed by ZHETRF_RK or ZHETRF_BK:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).",
   "This routine uses BLAS3 solver ZHETRS_3."],
 "dlasyf_rook"=>
  ["DLASYF_ROOK computes a partial factorization of a real symmetric",
   "matrix A using the bounded Bunch-Kaufman (\"rook\") diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "DLASYF_ROOK is an auxiliary routine called by DSYTRF_ROOK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "zla_porfsx_extended"=>
  ["ZLA_PORFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by ZPORFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "spptri"=>
  ["SPPTRI computes the inverse of a real symmetric positive definite",
   "matrix A using the Cholesky factorization A = U**T*U or A = L*L**T",
   "computed by SPPTRF."],
 "ssytrd"=>
  ["SSYTRD reduces a real symmetric matrix A to real symmetric",
   "tridiagonal form T by an orthogonal similarity transformation:",
   "Q**T * A * Q = T."],
 "slartgp"=>
  ["SLARTGP generates a plane rotation so that",
   "   [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a slower, more accurate version of the Level 1 BLAS routine SROTG,",
   "with the following other differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=(+/-)1 and SN=0.",
   "   If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.",
   "The sign is chosen so that R >= 0."],
 "chetrf_aa"=>
  ["CHETRF_AA computes the factorization of a complex hermitian matrix A",
   "using the Aasen's algorithm.  The form of the factorization is",
   "   A = U*T*U**H  or  A = L*T*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is a hermitian tridiagonal matrix.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "chb2st_kernels"=>
  ["CHB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST",
   "subroutine."],
 "zsyequb"=>
  ["ZSYEQUB computes row and column scalings intended to equilibrate a",
   "symmetric matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "cstegr"=>
  ["CSTEGR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "CSTEGR is a compatibility wrapper around the improved CSTEMR routine.",
   "See SSTEMR for further details.",
   "One important change is that the ABSTOL parameter no longer provides any",
   "benefit and hence is no longer used.",
   "Note : CSTEGR and CSTEMR work only on machines which follow",
   "IEEE-754 floating-point standard in their handling of infinities and",
   "NaNs.  Normal execution may create these exceptiona values and hence",
   "may abort due to a floating point exception in environments which",
   "do not conform to the IEEE-754 standard."],
 "zgeqrfp"=>
  ["ZGEQRFP computes a QR factorization of a complex M-by-N matrix A:",
   "A = Q * R. The diagonal entries of R are real and nonnegative."],
 "chegst"=>
  ["CHEGST reduces a complex Hermitian-definite generalized",
   "eigenproblem to standard form.",
   "If ITYPE = 1, the problem is A*x = lambda*B*x,",
   "and A is overwritten by inv(U**H)*A*inv(U) or inv(L)*A*inv(L**H)",
   "If ITYPE = 2 or 3, the problem is A*B*x = lambda*x or",
   "B*A*x = lambda*x, and A is overwritten by U*A*U**H or L**H*A*L.",
   "B must have been previously factorized as U**H*U or L*L**H by CPOTRF."],
 "ctfttp"=>
  ["CTFTTP copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard packed format (TP)."],
 "cpbcon"=>
  ["CPBCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite band matrix using",
   "the Cholesky factorization A = U**H*U or A = L*L**H computed by",
   "CPBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "claqhe"=>
  ["CLAQHE equilibrates a Hermitian matrix A using the scaling factors",
   "in the vector S."],
 "dgeevx"=>
  ["DGEEVX computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues",
   "(RCONDE), and reciprocal condition numbers for the right",
   "eigenvectors (RCONDV).",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate-transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real.",
   "Balancing a matrix means permuting the rows and columns to make it",
   "more nearly upper triangular, and applying a diagonal similarity",
   "transformation D * A * D**(-1), where D is a diagonal matrix, to",
   "make its rows and columns closer in norm and the condition numbers",
   "of its eigenvalues and eigenvectors smaller.  The computed",
   "reciprocal condition numbers correspond to the balanced matrix.",
   "Permuting rows and columns will not change the condition numbers",
   "(in exact arithmetic) but diagonal scaling will.  For further",
   "explanation of balancing, see section 4.10.2 of the LAPACK",
   "Users' Guide."],
 "ssytri_rook"=>
  ["SSYTRI_ROOK computes the inverse of a real symmetric",
   "matrix A using the factorization A = U*D*U**T or A = L*D*L**T",
   "computed by SSYTRF_ROOK."],
 "slaqtr"=>
  ["SLAQTR solves the real quasi-triangular system",
   "             op(T)*p = scale*c,               if LREAL = .TRUE.",
   "or the complex quasi-triangular systems",
   "           op(T + iB)*(p+iq) = scale*(c+id),  if LREAL = .FALSE.",
   "in real arithmetic, where T is upper quasi-triangular.",
   "If LREAL = .FALSE., then the first diagonal block of T must be",
   "1 by 1, B is the specially structured matrix",
   "               B = [ b(1) b(2) ... b(n) ]",
   "                   [       w            ]",
   "                   [           w        ]",
   "                   [              .     ]",
   "                   [                 w  ]",
   "op(A) = A or A**T, A**T denotes the transpose of",
   "matrix A.",
   "On input, X = [ c ].  On output, X = [ p ].",
   "              [ d ]                  [ q ]",
   "This subroutine is designed for the condition number estimation",
   "in routine STRSNA."],
 "cla_gbrfsx_extended"=>
  ["CLA_GBRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by CGBRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "ctrttf"=>
  ["CTRTTF copies a triangular matrix A from standard full format (TR)",
   "to rectangular full packed format (TF) ."],
 "chesv_rk"=>
  ["CHESV_RK computes the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N Hermitian matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "CHETRF_RK is called to compute the factorization of a complex",
   "Hermitian matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine CHETRS_3."],
 "iladlr"=>["ILADLR scans A for its last non-zero row."],
 "dgsvj1"=>
  ["DGSVJ1 is called from DGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as DGESVJ does, but",
   "it targets only particular pivots and it does not check convergence",
   "(stopping criterion). Few tunning parameters (marked by [TP]) are",
   "available for the implementer.",
   "Further Details",
   "~~~~~~~~~~~~~~~",
   "DGSVJ1 applies few sweeps of Jacobi rotations in the column space of",
   "the input M-by-N matrix A. The pivot pairs are taken from the (1,2)",
   "off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The",
   "block-entries (tiles) of the (1,2) off-diagonal block are marked by the",
   "[x]'s in the following scheme:",
   "   | *  *  * [x] [x] [x]|",
   "   | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.",
   "   | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "In terms of the columns of A, the first N1 columns are rotated 'against'",
   "the remaining N-N1 columns, trying to increase the angle between the",
   "corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is",
   "tiled using quadratic tiles of side KBL. Here, KBL is a tunning parmeter.",
   "The number of sweeps is given in NSWEEP and the orthogonality threshold",
   "is given in TOL."],
 "dlapy3"=>
  ["DLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause",
   "unnecessary overflow."],
 "clanhs"=>
  ["CLANHS  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "Hessenberg matrix A.",
   "   CLANHS = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zlamswlq"=>
  ["   ZLAMQRTS overwrites the general real M-by-N matrix C with",
   "                   SIDE = 'L'     SIDE = 'R'",
   "   TRANS = 'N':      Q * C          C * Q",
   "   TRANS = 'T':      Q**T * C       C * Q**T",
   "   where Q is a real orthogonal matrix defined as the product of blocked",
   "   elementary reflectors computed by short wide LQ",
   "   factorization (ZLASWLQ)"],
 "cungqr"=>
  ["CUNGQR generates an M-by-N complex matrix Q with orthonormal columns,",
   "which is defined as the first N columns of a product of K elementary",
   "reflectors of order M",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by CGEQRF."],
 "zstemr"=>
  ["ZSTEMR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "Depending on the number of desired eigenvalues, these are computed either",
   "by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are",
   "computed by the use of various suitable L D L^T factorizations near clusters",
   "of close eigenvalues (referred to as RRRs, Relatively Robust",
   "Representations). An informal sketch of the algorithm follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "For more details, see:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Further Details",
   "1.ZSTEMR works only on machines which follow IEEE-754",
   "floating-point standard in their handling of infinities and NaNs.",
   "This permits the use of efficient inner loops avoiding a check for",
   "zero divisors.",
   "2. LAPACK routines can be used to reduce a complex Hermitean matrix to",
   "real symmetric tridiagonal form.",
   "(Any complex Hermitean tridiagonal matrix has real values on its diagonal",
   "and potentially complex numbers on its off-diagonals. By applying a",
   "similarity transform with an appropriate diagonal matrix",
   "diag(1,e^{i \\phy_1}, ... , e^{i \\phy_{n-1}}), the complex Hermitean",
   "matrix can be transformed into a real symmetric matrix and complex",
   "arithmetic can be entirely avoided.)",
   "While the eigenvectors of the real symmetric tridiagonal matrix are real,",
   "the eigenvectors of original complex Hermitean matrix have complex entries",
   "in general.",
   "Since LAPACK drivers overwrite the matrix data with the eigenvectors,",
   "ZSTEMR accepts complex workspace to facilitate interoperability",
   "with ZUNMTR or ZUPMTR."],
 "dlassq"=>
  ["DLASSQ  returns the values  scl  and  smsq  such that",
   "   ( scl**2 )*smsq = x( 1 )**2 +...+ x( n )**2 + ( scale**2 )*sumsq,",
   "where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is",
   "assumed to be non-negative and  scl  returns the value",
   "   scl = max( scale, abs( x( i ) ) ).",
   "scale and sumsq must be supplied in SCALE and SUMSQ and",
   "scl and smsq are overwritten on SCALE and SUMSQ respectively.",
   "The routine makes only one pass through the vector x."],
 "zuncsd2by1"=>[],
 "ssysvxx"=>
  ["   SSYSVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a real system of linear equations A * X = B, where A",
   "   is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. SSYSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   SSYSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   SSYSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what SSYSVXX would itself produce."],
 "dhsein"=>
  ["DHSEIN uses inverse iteration to find specified right and/or left",
   "eigenvectors of a real upper Hessenberg matrix H.",
   "The right eigenvector x and the left eigenvector y of the matrix H",
   "corresponding to an eigenvalue w are defined by:",
   "             H * x = w * x,     y**h * H = w * y**h",
   "where y**h denotes the conjugate transpose of the vector y."],
 "sla_syamv"=>
  ["SLA_SYAMV  performs the matrix-vector operation",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "n by n symmetric matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dgebd2"=>
  ["DGEBD2 reduces a real general m by n matrix A to upper or lower",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "sgeevx"=>
  ["SGEEVX computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues",
   "(RCONDE), and reciprocal condition numbers for the right",
   "eigenvectors (RCONDV).",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate-transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real.",
   "Balancing a matrix means permuting the rows and columns to make it",
   "more nearly upper triangular, and applying a diagonal similarity",
   "transformation D * A * D**(-1), where D is a diagonal matrix, to",
   "make its rows and columns closer in norm and the condition numbers",
   "of its eigenvalues and eigenvectors smaller.  The computed",
   "reciprocal condition numbers correspond to the balanced matrix.",
   "Permuting rows and columns will not change the condition numbers",
   "(in exact arithmetic) but diagonal scaling will.  For further",
   "explanation of balancing, see section 4.10.2 of the LAPACK",
   "Users' Guide."],
 "dlantr"=>
  ["DLANTR  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "trapezoidal or triangular matrix A.",
   "   DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "ssygv"=>
  ["SSYGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be symmetric and B is also",
   "positive definite."],
 "stfsm"=>
  ["Level 3 BLAS like routine for A in RFP Format.",
   "STFSM  solves the matrix equation",
   "   op( A )*X = alpha*B  or  X*op( A ) = alpha*B",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T.",
   "A is in Rectangular Full Packed (RFP) Format.",
   "The matrix X is overwritten on B."],
 "dsbgst"=>
  ["DSBGST reduces a real symmetric-definite banded generalized",
   "eigenproblem  A*x = lambda*B*x  to standard form  C*y = lambda*y,",
   "such that C has the same bandwidth as A.",
   "B must have been previously factorized as S**T*S by DPBSTF, using a",
   "split Cholesky factorization. A is overwritten by C = X**T*A*X, where",
   "X = S**(-1)*Q and Q is an orthogonal matrix chosen to preserve the",
   "bandwidth of A."],
 "cunmtr"=>
  ["CUNMTR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "nq-1 elementary reflectors, as returned by CHETRD:",
   "if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1)."],
 "dlanst"=>
  ["DLANST  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric tridiagonal matrix A.",
   "   DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "csyconvf"=>
  ["If parameter WAY = 'C':",
   "CSYCONVF converts the factorization output format used in",
   "CSYTRF provided on entry in parameter A into the factorization",
   "output format used in CSYTRF_RK (or CSYTRF_BK) that is stored",
   "on exit in parameters A and E. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in CSYTRF into",
   "the format used in CSYTRF_RK (or CSYTRF_BK).",
   "If parameter WAY = 'R':",
   "CSYCONVF performs the conversion in reverse direction, i.e.",
   "converts the factorization output format used in CSYTRF_RK",
   "(or CSYTRF_BK) provided on entry in parametes A and E into",
   "the factorization output format used in CSYTRF that is stored",
   "on exit in parameter A. It also coverts in place details of",
   "the intechanges stored in IPIV from the format used in CSYTRF_RK",
   "(or CSYTRF_BK) into the format used in CSYTRF.",
   "CSYCONVF can also convert in Hermitian matrix case, i.e. between",
   "formats used in CHETRF and CHETRF_RK (or CHETRF_BK)."],
 "zhetrf_rook"=>
  ["ZHETRF_ROOK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (\"rook\") diagonal pivoting method.",
   "The form of the factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "clarcm"=>
  ["CLARCM performs a very simple matrix-matrix multiplication:",
   "         C := A * B,",
   "where A is M by M and real; B is M by N and complex;",
   "C is M by N and complex."],
 "sorg2l"=>
  ["SORG2L generates an m by n real matrix Q with orthonormal columns,",
   "which is defined as the last n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by SGEQLF."],
 "clarscl2"=>
  ["CLARSCL2 performs a reciprocal diagonal scaling on an vector:",
   "  x <-- inv(D) * x",
   "where the REAL diagonal matrix D is stored as a vector.",
   "Eventually to be replaced by BLAS_cge_diag_scale in the new BLAS",
   "standard."],
 "zsytri"=>
  ["ZSYTRI computes the inverse of a complex symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "ZSYTRF."],
 "zhegv"=>
  ["ZHEGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian and B is also",
   "positive definite."],
 "sgbtrs"=>
  ["SGBTRS solves a system of linear equations",
   "   A * X = B  or  A**T * X = B",
   "with a general band matrix A using the LU factorization computed",
   "by SGBTRF."],
 "dtrsna"=>
  ["DTRSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or right eigenvectors of a real upper",
   "quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q",
   "orthogonal).",
   "T must be in Schur canonical form (as returned by DHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "dposvxx"=>
  ["   DPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T",
   "   to compute the solution to a double precision system of linear equations",
   "   A * X = B, where A is an N-by-N symmetric positive definite matrix",
   "   and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. DPOSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   DPOSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   DPOSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what DPOSVXX would itself produce."],
 "ssbev"=>
  ["SSBEV computes all the eigenvalues and, optionally, eigenvectors of",
   "a real symmetric band matrix A."],
 "dgemlqt"=>
  ["DGEMQRT overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q C            C Q",
   "TRANS = 'T':   Q**T C            C Q**T",
   "where Q is a real orthogonal matrix defined as the product of K",
   "elementary reflectors:",
   "      Q = H(1) H(2) . . . H(K) = I - V T V**T",
   "generated using the compact WY representation as returned by DGELQT.",
   "Q is of order M if SIDE = 'L' and of order N  if SIDE = 'R'."],
 "zgges3"=>
  ["ZGGES3 computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the generalized complex Schur",
   "form (S, T), and optionally left and/or right Schur vectors (VSL",
   "and VSR). This gives the generalized Schur factorization",
   "        (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T. The leading",
   "columns of VSL and VSR then form an unitary basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "ZGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0, and even for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if S",
   "and T are upper triangular and, in addition, the diagonal elements",
   "of T are non-negative real numbers."],
 "dgeesx"=>
  ["DGEESX computes for an N-by-N real nonsymmetric matrix A, the",
   "eigenvalues, the real Schur form T, and, optionally, the matrix of",
   "Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "real Schur form so that selected eigenvalues are at the top left;",
   "computes a reciprocal condition number for the average of the",
   "selected eigenvalues (RCONDE); and computes a reciprocal condition",
   "number for the right invariant subspace corresponding to the",
   "selected eigenvalues (RCONDV).  The leading columns of Z form an",
   "orthonormal basis for this invariant subspace.",
   "For further explanation of the reciprocal condition numbers RCONDE",
   "and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where",
   "these quantities are called s and sep respectively).",
   "A real matrix is in real Schur form if it is upper quasi-triangular",
   "with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in",
   "the form",
   "          [  a  b  ]",
   "          [  c  a  ]",
   "where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc)."],
 "zla_gerfsx_extended"=>
  ["ZLA_GERFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by ZGERFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERRS_N",
   "and ERRS_C for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERRS_N and ERRS_C."],
 "slarre"=>
  ["To find the desired eigenvalues of a given real symmetric",
   "tridiagonal matrix T, SLARRE sets any \"small\" off-diagonal",
   "elements to zero, and for each unreduced block T_i, it finds",
   "(a) a suitable shift at one end of the block's spectrum,",
   "(b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and",
   "(c) eigenvalues of each L_i D_i L_i^T.",
   "The representations and eigenvalues found are then used by",
   "SSTEMR to compute the eigenvectors of T.",
   "The accuracy varies depending on whether bisection is used to",
   "find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to",
   "conpute all and then discard any unwanted one.",
   "As an added benefit, SLARRE also outputs the n",
   "Gerschgorin intervals for the matrices L_i D_i L_i^T."],
 "sorm2r"=>
  ["SORM2R overwrites the general real m by n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**T* C  if SIDE = 'L' and TRANS = 'T', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**T if SIDE = 'R' and TRANS = 'T',",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by SGEQRF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "zlarcm"=>
  ["ZLARCM performs a very simple matrix-matrix multiplication:",
   "         C := A * B,",
   "where A is M by M and real; B is M by N and complex;",
   "C is M by N and complex."],
 "strsna"=>
  ["STRSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or right eigenvectors of a real upper",
   "quasi-triangular matrix T (or of any matrix Q*T*Q**T with Q",
   "orthogonal).",
   "T must be in Schur canonical form (as returned by SHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "zgbsvx"=>
  ["ZGBSVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations A * X = B, A**T * X = B, or A**H * X = B,",
   "where A is a band matrix of order N with KL subdiagonals and KU",
   "superdiagonals, and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zsymv"=>
  ["ZSYMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix."],
 "ztgevc"=>
  ["ZTGEVC computes some or all of the right and/or left eigenvectors of",
   "a pair of complex matrices (S,P), where S and P are upper triangular.",
   "Matrix pairs of this type are produced by the generalized Schur",
   "factorization of a complex matrix pair (A,B):",
   "   A = Q*S*Z**H,  B = Q*P*Z**H",
   "as computed by ZGGHRD + ZHGEQZ.",
   "The right eigenvector x and the left eigenvector y of (S,P)",
   "corresponding to an eigenvalue w are defined by:",
   "   S*x = w*P*x,  (y**H)*S = w*(y**H)*P,",
   "where y**H denotes the conjugate tranpose of y.",
   "The eigenvalues are not input to this routine, but are computed",
   "directly from the diagonal elements of S and P.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of (S,P), or the products Z*X and/or Q*Y,",
   "where Z and Q are input matrices.",
   "If Q and Z are the unitary factors from the generalized Schur",
   "factorization of a matrix pair (A,B), then Z*X and Q*Y",
   "are the matrices of right and left eigenvectors of (A,B)."],
 "ssycon"=>
  ["SSYCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by SSYTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "ztpttf"=>
  ["ZTPTTF copies a triangular matrix A from standard packed format (TP)",
   "to rectangular full packed format (TF)."],
 "dppsvx"=>
  ["DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zspmv"=>
  ["ZSPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix, supplied in packed form."],
 "cporfsx"=>
  ["   CPORFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric positive",
   "   definite, and provides error bounds and backward error estimates",
   "   for the solution.  In addition to normwise error bound, the code",
   "   provides maximum componentwise error bound if possible.  See",
   "   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the",
   "   error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "claqr4"=>
  ["   CLAQR4 implements one level of recursion for CLAQR0.",
   "   It is a complete implementation of the small bulge multi-shift",
   "   QR algorithm.  It may be called by CLAQR0 and, for large enough",
   "   deflation window size, it may be called by CLAQR3.  This",
   "   subroutine is identical to CLAQR0 except that it calls CLAQR2",
   "   instead of CLAQR3.",
   "   CLAQR4 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H."],
 "clar1v"=>
  ["CLAR1V computes the (scaled) r-th column of the inverse of",
   "the sumbmatrix in rows B1 through BN of the tridiagonal matrix",
   "L D L**T - sigma I. When sigma is close to an eigenvalue, the",
   "computed vector is an accurate eigenvector. Usually, r corresponds",
   "to the index where the eigenvector is largest in magnitude.",
   "The following steps accomplish this computation :",
   "(a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,",
   "(b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,",
   "(c) Computation of the diagonal elements of the inverse of",
   "    L D L**T - sigma I by combining the above transforms, and choosing",
   "    r as the index where the diagonal of the inverse is (one of the)",
   "    largest in magnitude.",
   "(d) Computation of the (scaled) r-th column of the inverse using the",
   "    twisted factorization obtained by combining the top part of the",
   "    the stationary and the bottom part of the progressive transform."],
 "cheequb"=>
  ["CHEEQUB computes row and column scalings intended to equilibrate a",
   "Hermitian matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "dppequ"=>
  ["DPPEQU computes row and column scalings intended to equilibrate a",
   "symmetric positive definite matrix A in packed storage and reduce",
   "its condition number (with respect to the two-norm).  S contains the",
   "scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix",
   "B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.",
   "This choice of S puts the condition number of B within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "cgesvxx"=>
  ["   CGESVXX uses the LU factorization to compute the solution to a",
   "   complex system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. CGESVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   CGESVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   CGESVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what CGESVXX would itself produce."],
 "zhpgv"=>
  ["ZHPGV computes all the eigenvalues and, optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian, stored in packed format,",
   "and B is also positive definite."],
 "dlarnv"=>
  ["DLARNV returns a vector of n random real numbers from a uniform or",
   "normal distribution."],
 "sspgvx"=>
  ["SSPGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A",
   "and B are assumed to be symmetric, stored in packed storage, and B",
   "is also positive definite.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "ztgsen"=>
  ["ZTGSEN reorders the generalized Schur decomposition of a complex",
   "matrix pair (A, B) (in terms of an unitary equivalence trans-",
   "formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues",
   "appears in the leading diagonal blocks of the pair (A,B). The leading",
   "columns of Q and Z form unitary bases of the corresponding left and",
   "right eigenspaces (deflating subspaces). (A, B) must be in",
   "generalized Schur canonical form, that is, A and B are both upper",
   "triangular.",
   "ZTGSEN also computes the generalized eigenvalues",
   "         w(j)= ALPHA(j) / BETA(j)",
   "of the reordered matrix pair (A, B).",
   "Optionally, the routine computes estimates of reciprocal condition",
   "numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),",
   "(A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)",
   "between the matrix pairs (A11, B11) and (A22,B22) that correspond to",
   "the selected cluster and the eigenvalues outside the cluster, resp.,",
   "and norms of \"projections\" onto left and right eigenspaces w.r.t.",
   "the selected cluster in the (1,1)-block."],
 "zhetf2"=>
  ["ZHETF2 computes the factorization of a complex Hermitian matrix A",
   "using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**H is the conjugate transpose of U, and D is",
   "Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zgelss"=>
  ["ZGELSS computes the minimum norm solution to a complex linear",
   "least squares problem:",
   "Minimize 2-norm(| b - A*x |).",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix",
   "X.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value."],
 "clatrz"=>
  ["CLATRZ factors the M-by-(M+L) complex upper trapezoidal matrix",
   "[ A1 A2 ] = [ A(1:M,1:M) A(1:M,N-L+1:N) ] as ( R  0 ) * Z by means",
   "of unitary transformations, where  Z is an (M+L)-by-(M+L) unitary",
   "matrix and, R and A1 are M-by-M upper triangular matrices."],
 "cggsvd3"=>
  ["CGGSVD3 computes the generalized singular value decomposition (GSVD)",
   "of an M-by-N complex matrix A and P-by-N complex matrix B:",
   "      U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )",
   "where U, V and Q are unitary matrices.",
   "Let K+L = the effective numerical rank of the",
   "matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper",
   "triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\"",
   "matrices and of the following structures, respectively:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 =   L ( 0  S )",
   "            P-L ( 0  0 )",
   "                N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 )",
   "            L (  0    0   R22 )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "                  K M-K K+L-M",
   "       D1 =   K ( I  0    0   )",
   "            M-K ( 0  C    0   )",
   "                    K M-K K+L-M",
   "       D2 =   M-K ( 0  S    0  )",
   "            K+L-M ( 0  0    I  )",
   "              P-L ( 0  0    0  )",
   "                   N-K-L  K   M-K  K+L-M",
   "  ( 0 R ) =     K ( 0    R11  R12  R13  )",
   "              M-K ( 0     0   R22  R23  )",
   "            K+L-M ( 0     0    0   R33  )",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "  S = diag( BETA(K+1),  ... , BETA(M) ),",
   "  C**2 + S**2 = I.",
   "  (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored",
   "  ( 0  R22 R23 )",
   "  in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The routine computes C, S, R, and optionally the unitary",
   "transformation matrices U, V and Q.",
   "In particular, if B is an N-by-N nonsingular matrix, then the GSVD of",
   "A and B implicitly gives the SVD of A*inv(B):",
   "                     A*inv(B) = U*(D1*inv(D2))*V**H.",
   "If ( A**H,B**H)**H has orthonormal columns, then the GSVD of A and B is also",
   "equal to the CS decomposition of A and B. Furthermore, the GSVD can",
   "be used to derive the solution of the eigenvalue problem:",
   "                     A**H*A x = lambda* B**H*B x.",
   "In some literature, the GSVD of A and B is presented in the form",
   "                 U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )",
   "where U and V are orthogonal and X is nonsingular, and D1 and D2 are",
   "``diagonal''.  The former GSVD form can be converted to the latter",
   "form by taking the nonsingular matrix X as",
   "                      X = Q*(  I   0    )",
   "                            (  0 inv(R) )"],
 "zungtr"=>
  ["ZUNGTR generates a complex unitary matrix Q which is defined as the",
   "product of n-1 elementary reflectors of order N, as returned by",
   "ZHETRD:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "zlaqps"=>
  ["ZLAQPS computes a step of QR factorization with column pivoting",
   "of a complex M-by-N matrix A by using Blas-3.  It tries to factorize",
   "NB columns from A starting from the row OFFSET+1, and updates all",
   "of the matrix with Blas-3 xGEMM.",
   "In some cases, due to catastrophic cancellations, it cannot",
   "factorize NB columns.  Hence, the actual number of factorized",
   "columns is returned in KB.",
   "Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "claswp"=>
  ["CLASWP performs a series of row interchanges on the matrix A.",
   "One row interchange is initiated for each of rows K1 through K2 of A."],
 "spbcon"=>
  ["SPBCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric positive definite band matrix using the",
   "Cholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cgbbrd"=>
  ["CGBBRD reduces a complex general m-by-n band matrix A to real upper",
   "bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "The routine computes B, and optionally forms Q or P**H, or computes",
   "Q**H*C for a given matrix C."],
 "zgeqp3"=>
  ["ZGEQP3 computes a QR factorization with column pivoting of a",
   "matrix A:  A*P = Q*R  using Level 3 BLAS."],
 "zlaesy"=>
  ["ZLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix",
   "   ( ( A, B );( B, C ) )",
   "provided the norm of the matrix of eigenvectors is larger than",
   "some threshold value.",
   "RT1 is the eigenvalue of larger absolute value, and RT2 of",
   "smaller absolute value.  If the eigenvectors are computed, then",
   "on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence",
   "[  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]",
   "[ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]"],
 "cunm2r"=>
  ["CUNM2R overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by CGEQRF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "chla_transtype"=>
  ["This subroutine translates from a BLAST-specified integer constant to",
   "the character string specifying a transposition operation.",
   "CHLA_TRANSTYPE returns an CHARACTER*1.  If CHLA_TRANSTYPE is 'X',",
   "then input is not an integer indicating a transposition operator.",
   "Otherwise CHLA_TRANSTYPE returns the constant value corresponding to",
   "TRANS."],
 "slapy3"=>
  ["SLAPY3 returns sqrt(x**2+y**2+z**2), taking care not to cause",
   "unnecessary overflow."],
 "ssytri2x"=>
  ["SSYTRI2X computes the inverse of a real symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "SSYTRF."],
 "cungtr"=>
  ["CUNGTR generates a complex unitary matrix Q which is defined as the",
   "product of n-1 elementary reflectors of order N, as returned by",
   "CHETRD:",
   "if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),",
   "if UPLO = 'L', Q = H(1) H(2) . . . H(n-1)."],
 "ilauplo"=>
  ["This subroutine translated from a character string specifying a",
   "upper- or lower-triangular matrix to the relevant BLAST-specified",
   "integer constant.",
   "ILAUPLO returns an INTEGER.  If ILAUPLO < 0, then the input is not",
   "a character indicating an upper- or lower-triangular matrix.",
   "Otherwise ILAUPLO returns the constant value corresponding to UPLO."],
 "zgbsvxx"=>
  ["   ZGBSVXX uses the LU factorization to compute the solution to a",
   "   complex*16 system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. ZGBSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   ZGBSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   ZGBSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what ZGBSVXX would itself produce."],
 "clahqr"=>
  ["   CLAHQR is an auxiliary routine called by CHSEQR to update the",
   "   eigenvalues and Schur decomposition already computed by CHSEQR, by",
   "   dealing with the Hessenberg submatrix in rows and columns ILO to",
   "   IHI."],
 "sgeqp3"=>
  ["SGEQP3 computes a QR factorization with column pivoting of a",
   "matrix A:  A*P = Q*R  using Level 3 BLAS."],
 "cla_wwaddw"=>
  ["   CLA_WWADDW adds a vector W into a doubled-single vector (X, Y).",
   "   This works for all extant IBM's hex and binary floating point",
   "   arithmetics, but not for decimal."],
 "strsen"=>
  ["STRSEN reorders the real Schur factorization of a real matrix",
   "A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in",
   "the leading diagonal blocks of the upper quasi-triangular matrix T,",
   "and the leading columns of Q form an orthonormal basis of the",
   "corresponding right invariant subspace.",
   "Optionally the routine computes the reciprocal condition numbers of",
   "the cluster of eigenvalues and/or the invariant subspace.",
   "T must be in Schur canonical form (as returned by SHSEQR), that is,",
   "block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each",
   "2-by-2 diagonal block has its diagonal elements equal and its",
   "off-diagonal elements of opposite sign."],
 "spptrs"=>
  ["SPPTRS solves a system of linear equations A*X = B with a symmetric",
   "positive definite matrix A in packed storage using the Cholesky",
   "factorization A = U**T*U or A = L*L**T computed by SPPTRF."],
 "clarfg"=>
  ["CLARFG generates a complex elementary reflector H of order n, such",
   "that",
   "      H**H * ( alpha ) = ( beta ),   H**H * H = I.",
   "             (   x   )   (   0  )",
   "where alpha and beta are scalars, with beta real, and x is an",
   "(n-1)-element complex vector. H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**H ) ,",
   "                    ( v )",
   "where tau is a complex scalar and v is a complex (n-1)-element",
   "vector. Note that H is not hermitian.",
   "If the elements of x are all zero and alpha is real, then tau = 0",
   "and H is taken to be the unit matrix.",
   "Otherwise  1 <= real(tau) <= 2  and  abs(tau-1) <= 1 ."],
 "dlarf"=>
  ["DLARF applies a real elementary reflector H to a real m by n matrix",
   "C, from either the left or the right. H is represented in the form",
   "      H = I - tau * v * v**T",
   "where tau is a real scalar and v is a real vector.",
   "If tau = 0, then H is taken to be the unit matrix."],
 "sposvxx"=>
  ["   SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T",
   "   to compute the solution to a real system of linear equations",
   "   A * X = B, where A is an N-by-N symmetric positive definite matrix",
   "   and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. SPOSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   SPOSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   SPOSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what SPOSVXX would itself produce."],
 "zlarfy"=>
  ["ZLARFY applies an elementary reflector, or Householder matrix, H,",
   "to an n x n Hermitian matrix C, from both the left and the right.",
   "H is represented in the form",
   "   H = I - tau * v * v'",
   "where  tau  is a scalar and  v  is a vector.",
   "If  tau  is  zero, then  H  is taken to be the unit matrix."],
 "dsbtrd"=>
  ["DSBTRD reduces a real symmetric band matrix A to symmetric",
   "tridiagonal form T by an orthogonal similarity transformation:",
   "Q**T * A * Q = T."],
 "ctrti2"=>
  ["CTRTI2 computes the inverse of a complex upper or lower triangular",
   "matrix.",
   "This is the Level 2 BLAS version of the algorithm."],
 "zhetrs_aa"=>
  ["ZHETRS_AA solves a system of linear equations A*X = B with a complex",
   "hermitian matrix A using the factorization A = U*T*U**H or",
   "A = L*T*L**T computed by ZHETRF_AA."],
 "slasv2"=>
  ["SLASV2 computes the singular value decomposition of a 2-by-2",
   "triangular matrix",
   "   [  F   G  ]",
   "   [  0   H  ].",
   "On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the",
   "smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and",
   "right singular vectors for abs(SSMAX), giving the decomposition",
   "   [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]",
   "   [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ]."],
 "zhptrf"=>
  ["ZHPTRF computes the factorization of a complex Hermitian packed",
   "matrix A using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**H  or  A = L*D*L**H",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is Hermitian and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks."],
 "sgeqrt"=>
  ["SGEQRT computes a blocked QR factorization of a real M-by-N matrix A",
   "using the compact WY representation of Q."],
 "cuncsd2by1"=>[],
 "strevc3"=>
  ["STREVC3 computes some or all of the right and/or left eigenvectors of",
   "a real upper quasi-triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a real general matrix:  A = Q*T*Q**T, as computed by SHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "   T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal blocks of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix. If Q is the orthogonal factor that reduces a matrix",
   "A to Schur form T, then Q*X and Q*Y are the matrices of right and",
   "left eigenvectors of A.",
   "This uses a Level 3 BLAS version of the back transformation."],
 "sladiv"=>
  ["SLADIV performs complex division in  real arithmetic",
   "                      a + i*b",
   "           p + i*q = ---------",
   "                      c + i*d",
   "The algorithm is due to Michael Baudin and Robert L. Smith",
   "and can be found in the paper",
   "\"A Robust Complex Division in Scilab\""],
 "zgeesx"=>
  ["ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues, the Schur form T, and, optionally, the matrix of Schur",
   "vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).",
   "Optionally, it also orders the eigenvalues on the diagonal of the",
   "Schur form so that selected eigenvalues are at the top left;",
   "computes a reciprocal condition number for the average of the",
   "selected eigenvalues (RCONDE); and computes a reciprocal condition",
   "number for the right invariant subspace corresponding to the",
   "selected eigenvalues (RCONDV).  The leading columns of Z form an",
   "orthonormal basis for this invariant subspace.",
   "For further explanation of the reciprocal condition numbers RCONDE",
   "and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where",
   "these quantities are called s and sep respectively).",
   "A complex matrix is in Schur form if it is upper triangular."],
 "slarrb"=>
  ["Given the relatively robust representation(RRR) L D L^T, SLARRB",
   "does \"limited\" bisection to refine the eigenvalues of L D L^T,",
   "W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial",
   "guesses for these eigenvalues are input in W, the corresponding estimate",
   "of the error in these guesses and their gaps are input in WERR",
   "and WGAP, respectively. During bisection, intervals",
   "[left, right] are maintained by storing their mid-points and",
   "semi-widths in the arrays W and WERR respectively."],
 "ilaslc"=>["ILASLC scans A for its last non-zero column."],
 "cgeev"=>
  ["CGEEV computes for an N-by-N complex nonsymmetric matrix A, the",
   "eigenvalues and, optionally, the left and/or right eigenvectors.",
   "The right eigenvector v(j) of A satisfies",
   "                 A * v(j) = lambda(j) * v(j)",
   "where lambda(j) is its eigenvalue.",
   "The left eigenvector u(j) of A satisfies",
   "              u(j)**H * A = lambda(j) * u(j)**H",
   "where u(j)**H denotes the conjugate transpose of u(j).",
   "The computed eigenvectors are normalized to have Euclidean norm",
   "equal to 1 and largest component real."],
 "slaneg"=>
  ["SLANEG computes the Sturm count, the number of negative pivots",
   "encountered while factoring tridiagonal T - sigma I = L D L^T.",
   "This implementation works directly on the factors without forming",
   "the tridiagonal matrix T.  The Sturm count is also the number of",
   "eigenvalues of T less than sigma.",
   "This routine is called from SLARRB.",
   "The current routine does not use the PIVMIN parameter but rather",
   "requires IEEE-754 propagation of Infinities and NaNs.  This",
   "routine also has no input range restrictions but does require",
   "default exception handling such that x/0 produces Inf when x is",
   "non-zero, and Inf/Inf produces NaN.  For more information, see:",
   "  Marques, Riedy, and Voemel, \"Benefits of IEEE-754 Features in",
   "  Modern Symmetric Tridiagonal Eigensolvers,\" SIAM Journal on",
   "  Scientific Computing, v28, n5, 2006.  DOI 10.1137/050641624",
   "  (Tech report version in LAWN 172 with the same title.)"],
 "dsytrs"=>
  ["DSYTRS solves a system of linear equations A*X = B with a real",
   "symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by DSYTRF."],
 "dlasq4"=>
  ["DLASQ4 computes an approximation TAU to the smallest eigenvalue",
   "using values of d from the previous transform."],
 "dsbgvd"=>
  ["DSBGVD computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of the",
   "form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and",
   "banded, and B is also positive definite.  If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "cgehd2"=>
  ["CGEHD2 reduces a complex general matrix A to upper Hessenberg form H",
   "by a unitary similarity transformation:  Q**H * A * Q = H ."],
 "zgetsls"=>
  ["ZGETSLS solves overdetermined or underdetermined complex linear systems",
   "involving an M-by-N matrix A, using a tall skinny QR or short wide LQ",
   "factorization of A.  It is assumed that A has full rank.",
   "The following options are provided:",
   "1. If TRANS = 'N' and m >= n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A*X ||.",
   "2. If TRANS = 'N' and m < n:  find the minimum norm solution of",
   "   an underdetermined system A * X = B.",
   "3. If TRANS = 'C' and m >= n:  find the minimum norm solution of",
   "   an undetermined system A**T * X = B.",
   "4. If TRANS = 'C' and m < n:  find the least squares solution of",
   "   an overdetermined system, i.e., solve the least squares problem",
   "                minimize || B - A**T * X ||.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X."],
 "ztrsyl"=>
  ["ZTRSYL solves the complex Sylvester matrix equation:",
   "   op(A)*X + X*op(B) = scale*C or",
   "   op(A)*X - X*op(B) = scale*C,",
   "where op(A) = A or A**H, and A and B are both upper triangular. A is",
   "M-by-M and B is N-by-N; the right hand side C and the solution X are",
   "M-by-N; and scale is an output scale factor, set <= 1 to avoid",
   "overflow in X."],
 "dspsvx"=>
  ["DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or",
   "A = L*D*L**T to compute the solution to a real system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dtgsy2"=>
  ["DTGSY2 solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C                (1)",
   "            D * R - L * E = scale * F,",
   "using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,",
   "(A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,",
   "N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)",
   "must be in generalized Schur canonical form, i.e. A, B are upper",
   "quasi triangular and D, E are upper triangular. The solution (R, L)",
   "overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor",
   "chosen to avoid overflow.",
   "In matrix notation solving equation (1) corresponds to solve",
   "Z*x = scale*b, where Z is defined as",
   "       Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)",
   "           [ kron(In, D)  -kron(E**T, Im) ],",
   "Ik is the identity matrix of size k and X**T is the transpose of X.",
   "kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "In the process of solving (1), we solve a number of such systems",
   "where Dim(In), Dim(In) = 1 or 2.",
   "If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,",
   "which is equivalent to solve for R and L in",
   "            A**T * R  + D**T * L   = scale * C           (3)",
   "            R  * B**T + L  * E**T  = scale * -F",
   "This case is used to compute an estimate of Dif[(A, D), (B, E)] =",
   "sigma_min(Z) using reverse communicaton with DLACON.",
   "DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL",
   "of an upper bound on the separation between to matrix pairs. Then",
   "the input (A, D), (B, E) are sub-pencils of the matrix pair in",
   "DTGSYL. See DTGSYL for details."],
 "dormrz"=>
  ["DORMRZ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DTZRZF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "dptsv"=>
  ["DPTSV computes the solution to a real system of linear equations",
   "A*X = B, where A is an N-by-N symmetric positive definite tridiagonal",
   "matrix, and X and B are N-by-NRHS matrices.",
   "A is factored as A = L*D*L**T, and the factored form of A is then",
   "used to solve the system of equations."],
 "ztfttp"=>
  ["ZTFTTP copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard packed format (TP)."],
 "slarzb"=>
  ["SLARZB applies a real block reflector H or its transpose H**T to",
   "a real distributed M-by-N  C from the left or the right.",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "ssysv_rk"=>
  ["SSYSV_RK computes the solution to a real system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "SSYTRF_RK is called to compute the factorization of a real",
   "symmetric matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine SSYTRS_3."],
 "zpocon"=>
  ["ZPOCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a complex Hermitian positive definite matrix using the",
   "Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "sgetrf2"=>
  ["SGETRF2 computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = min(m,n)/2",
   "                                      [ A11 ]",
   "The subroutine calls itself to factor [ --- ],",
   "                                      [ A12 ]",
   "                [ A12 ]",
   "do the swaps on [ --- ], solve A12, update A22,",
   "                [ A22 ]",
   "then calls itself to factor A22 and do the swaps on A21."],
 "zhgeqz"=>
  ["ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),",
   "where H is an upper Hessenberg matrix and T is upper triangular,",
   "using the single-shift QZ method.",
   "Matrix pairs of this type are produced by the reduction to",
   "generalized upper Hessenberg form of a complex matrix pair (A,B):",
   "   A = Q1*H*Z1**H,  B = Q1*T*Z1**H,",
   "as computed by ZGGHRD.",
   "If JOB='S', then the Hessenberg-triangular pair (H,T) is",
   "also reduced to generalized Schur form,",
   "   H = Q*S*Z**H,  T = Q*P*Z**H,",
   "where Q and Z are unitary matrices and S and P are upper triangular.",
   "Optionally, the unitary matrix Q from the generalized Schur",
   "factorization may be postmultiplied into an input matrix Q1, and the",
   "unitary matrix Z may be postmultiplied into an input matrix Z1.",
   "If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced",
   "the matrix pair (A,B) to generalized Hessenberg form, then the output",
   "matrices Q1*Q and Z1*Z are the unitary factors from the generalized",
   "Schur factorization of (A,B):",
   "   A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.",
   "To avoid overflow, eigenvalues of the matrix pair (H,T)",
   "(equivalently, of (A,B)) are computed as a pair of complex values",
   "(alpha,beta).  If beta is nonzero, lambda = alpha / beta is an",
   "eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)",
   "   A*x = lambda*B*x",
   "and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the",
   "alternate form of the GNEP",
   "   mu*A*y = B*y.",
   "The values of alpha and beta for the i-th eigenvalue can be read",
   "directly from the generalized Schur form:  alpha = S(i,i),",
   "beta = P(i,i).",
   "Ref: C.B. Moler & G.W. Stewart, \"An Algorithm for Generalized Matrix",
   "     Eigenvalue Problems\", SIAM J. Numer. Anal., 10(1973),",
   "     pp. 241--256."],
 "cgetrf2"=>
  ["CGETRF2 computes an LU factorization of a general M-by-N matrix A",
   "using partial pivoting with row interchanges.",
   "The factorization has the form",
   "   A = P * L * U",
   "where P is a permutation matrix, L is lower triangular with unit",
   "diagonal elements (lower trapezoidal if m > n), and U is upper",
   "triangular (upper trapezoidal if m < n).",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = min(m,n)/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "                                      [ A11 ]",
   "The subroutine calls itself to factor [ --- ],",
   "                                      [ A12 ]",
   "                [ A12 ]",
   "do the swaps on [ --- ], solve A12, update A22,",
   "                [ A22 ]",
   "then calls itself to factor A22 and do the swaps on A21."],
 "dtgsyl"=>
  ["DTGSYL solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C                 (1)",
   "            D * R - L * E = scale * F",
   "where R and L are unknown m-by-n matrices, (A, D), (B, E) and",
   "(C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,",
   "respectively, with real entries. (A, D) and (B, E) must be in",
   "generalized (real) Schur canonical form, i.e. A, B are upper quasi",
   "triangular and D, E are upper triangular.",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output",
   "scaling factor chosen to avoid overflow.",
   "In matrix notation (1) is equivalent to solve  Zx = scale b, where",
   "Z is defined as",
   "           Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)",
   "               [ kron(In, D)  -kron(E**T, Im) ].",
   "Here Ik is the identity matrix of size k and X**T is the transpose of",
   "X. kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,",
   "which is equivalent to solve for R and L in",
   "            A**T * R + D**T * L = scale * C           (3)",
   "            R * B**T + L * E**T = scale * -F",
   "This case (TRANS = 'T') is used to compute an one-norm-based estimate",
   "of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)",
   "and (B,E), using DLACON.",
   "If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate",
   "of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the",
   "reciprocal of the smallest singular value of Z. See [1-2] for more",
   "information.",
   "This is a level 3 BLAS algorithm."],
 "cung2r"=>
  ["CUNG2R generates an m by n complex matrix Q with orthonormal columns,",
   "which is defined as the first n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(1) H(2) . . . H(k)",
   "as returned by CGEQRF."],
 "dlatrd"=>
  ["DLATRD reduces NB rows and columns of a real symmetric matrix A to",
   "symmetric tridiagonal form by an orthogonal similarity",
   "transformation Q**T * A * Q, and returns the matrices V and W which are",
   "needed to apply the transformation to the unreduced part of A.",
   "If UPLO = 'U', DLATRD reduces the last NB rows and columns of a",
   "matrix, of which the upper triangle is supplied;",
   "if UPLO = 'L', DLATRD reduces the first NB rows and columns of a",
   "matrix, of which the lower triangle is supplied.",
   "This is an auxiliary routine called by DSYTRD."],
 "zpbtrs"=>
  ["ZPBTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite band matrix A using the Cholesky factorization",
   "A = U**H *U or A = L*L**H computed by ZPBTRF."],
 "dtgsna"=>
  ["DTGSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or eigenvectors of a matrix pair (A, B) in",
   "generalized real Schur canonical form (or of any matrix pair",
   "(Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where",
   "Z**T denotes the transpose of Z.",
   "(A, B) must be in generalized real Schur form (as returned by DGGES),",
   "i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal",
   "blocks. B is upper triangular."],
 "zsytrs_rook"=>
  ["ZSYTRS_ROOK solves a system of linear equations A*X = B with",
   "a complex symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by ZSYTRF_ROOK."],
 "dggbal"=>
  ["DGGBAL balances a pair of general real matrices (A,B).  This",
   "involves, first, permuting A and B by similarity transformations to",
   "isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N",
   "elements on the diagonal; and second, applying a diagonal similarity",
   "transformation to rows and columns ILO to IHI to make the rows",
   "and columns as close in norm as possible. Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrices, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors in the",
   "generalized eigenvalue problem A*x = lambda*B*x."],
 "slange"=>
  ["SLANGE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real matrix A.",
   "   SLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zla_porcond_x"=>
  ["   ZLA_PORCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX*16 vector."],
 "slasd7"=>
  ["SLASD7 merges the two sets of singular values together into a single",
   "sorted set. Then it tries to deflate the size of the problem. There",
   "are two ways in which deflation can occur:  when two or more singular",
   "values are close together or if there is a tiny entry in the Z",
   "vector. For each such occurrence the order of the related",
   "secular equation problem is reduced by one.",
   "SLASD7 is called from SLASD6."],
 "csyconv"=>
  ["CSYCONV convert A given by TRF into L and D and vice-versa.",
   "Get Non-diag elements of D (returned in workspace) and",
   "apply or reverse permutation done in TRF."],
 "dlansy"=>
  ["DLANSY  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "real symmetric matrix A.",
   "   DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zgesvj"=>
  ["ZGESVJ computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, where M >= N. The SVD of A is written as",
   "                                   [++]   [xx]   [x0]   [xx]",
   "             A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]",
   "                                   [++]   [xx]",
   "where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal",
   "matrix, and V is an N-by-N unitary matrix. The diagonal elements",
   "of SIGMA are the singular values of A. The columns of U and V are the",
   "left and the right singular vectors of A, respectively."],
 "zlarz"=>
  ["ZLARZ applies a complex elementary reflector H to a complex",
   "M-by-N matrix C, from either the left or the right. H is represented",
   "in the form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "To apply H**H (the conjugate transpose of H), supply conjg(tau) instead",
   "tau.",
   "H is a product of k elementary reflectors as returned by ZTZRZF."],
 "ztbtrs"=>
  ["ZTBTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular band matrix of order N, and B is an",
   "N-by-NRHS matrix.  A check is made to verify that A is nonsingular."],
 "ctptri"=>
  ["CTPTRI computes the inverse of a complex upper or lower triangular",
   "matrix A stored in packed format."],
 "slarrd"=>
  ["SLARRD computes the eigenvalues of a symmetric tridiagonal",
   "matrix T to suitable accuracy. This is an auxiliary code to be",
   "called from SSTEMR.",
   "The user may ask for all eigenvalues, all eigenvalues",
   "in the half-open interval (VL, VU], or the IL-th through IU-th",
   "eigenvalues.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "zgelqt"=>
  ["ZGELQT computes a blocked LQ factorization of a complex M-by-N matrix A",
   "using the compact WY representation of Q."],
 "slapll"=>
  ["Given two column vectors X and Y, let",
   "                     A = ( X Y ).",
   "The subroutine first computes the QR factorization of A = Q*R,",
   "and then computes the SVD of the 2-by-2 upper triangular matrix R.",
   "The smaller singular value of R is returned in SSMIN, which is used",
   "as the measurement of the linear dependency of the vectors X and Y."],
 "spttrs"=>
  ["SPTTRS solves a tridiagonal system of the form",
   "   A * X = B",
   "using the L*D*L**T factorization of A computed by SPTTRF.  D is a",
   "diagonal matrix specified in the vector D, L is a unit bidiagonal",
   "matrix whose subdiagonal is specified in the vector E, and X and B",
   "are N by NRHS matrices."],
 "csytrf"=>
  ["CSYTRF computes the factorization of a complex symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method.  The form of the",
   "factorization is",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS."],
 "slaed6"=>
  ["SLAED6 computes the positive or negative root (closest to the origin)",
   "of",
   "                 z(1)        z(2)        z(3)",
   "f(x) =   rho + --------- + ---------- + ---------",
   "                d(1)-x      d(2)-x      d(3)-x",
   "It is assumed that",
   "      if ORGATI = .true. the root is between d(2) and d(3);",
   "      otherwise it is between d(1) and d(2)",
   "This routine will be called by SLAED4 when necessary. In most cases,",
   "the root sought is the smallest in magnitude, though it might not be",
   "in some extremely rare situations."],
 "cgecon"=>
  ["CGECON estimates the reciprocal of the condition number of a general",
   "complex matrix A, in either the 1-norm or the infinity-norm, using",
   "the LU factorization computed by CGETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "cpoequ"=>
  ["CPOEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings."],
 "dlaed5"=>
  ["This subroutine computes the I-th eigenvalue of a symmetric rank-one",
   "modification of a 2-by-2 diagonal matrix",
   "           diag( D )  +  RHO * Z * transpose(Z) .",
   "The diagonal elements in the array D are assumed to satisfy",
   "           D(i) < D(j)  for  i < j .",
   "We also assume RHO > 0 and that the Euclidean norm of the vector",
   "Z is one."],
 "zgtsv"=>
  ["ZGTSV  solves the equation",
   "   A*X = B,",
   "where A is an N-by-N tridiagonal matrix, by Gaussian elimination with",
   "partial pivoting.",
   "Note that the equation  A**T *X = B  may be solved by interchanging the",
   "order of the arguments DU and DL."],
 "dbdsqr"=>
  ["DBDSQR computes the singular values and, optionally, the right and/or",
   "left singular vectors from the singular value decomposition (SVD) of",
   "a real N-by-N (upper or lower) bidiagonal matrix B using the implicit",
   "zero-shift QR algorithm.  The SVD of B has the form",
   "   B = Q * S * P**T",
   "where S is the diagonal matrix of singular values, Q is an orthogonal",
   "matrix of left singular vectors, and P is an orthogonal matrix of",
   "right singular vectors.  If left singular vectors are requested, this",
   "subroutine actually returns U*Q instead of Q, and, if right singular",
   "vectors are requested, this subroutine returns P**T*VT instead of",
   "P**T, for given real input matrices U and VT.  When U and VT are the",
   "orthogonal matrices that reduce a general matrix A to bidiagonal",
   "form:  A = U*B*VT, as computed by DGEBRD, then",
   "   A = (U*Q) * S * (P**T*VT)",
   "is the SVD of A.  Optionally, the subroutine may also compute Q**T*C",
   "for a given real input matrix C.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,",
   "no. 5, pp. 873-912, Sept 1990) and",
   "\"Accurate singular values and differential qd algorithms,\" by",
   "B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics",
   "Department, University of California at Berkeley, July 1992",
   "for a detailed description of the algorithm."],
 "cla_geamv"=>
  ["CLA_GEAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "dgecon"=>
  ["DGECON estimates the reciprocal of the condition number of a general",
   "real matrix A, in either the 1-norm or the infinity-norm, using",
   "the LU factorization computed by DGETRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "sormrq"=>
  ["SORMRQ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by SGERQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "sgbrfs"=>
  ["SGBRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is banded, and provides",
   "error bounds and backward error estimates for the solution."],
 "zggev3"=>
  ["ZGGEV3 computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right generalized eigenvector v(j) corresponding to the",
   "generalized eigenvalue lambda(j) of (A,B) satisfies",
   "             A * v(j) = lambda(j) * B * v(j).",
   "The left generalized eigenvector u(j) corresponding to the",
   "generalized eigenvalues lambda(j) of (A,B) satisfies",
   "             u(j)**H * A = lambda(j) * u(j)**H * B",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "dlapmt"=>
  ["DLAPMT rearranges the columns of the M by N matrix X as specified",
   "by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.",
   "If FORWRD = .TRUE.,  forward permutation:",
   "     X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.",
   "If FORWRD = .FALSE., backward permutation:",
   "     X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N."],
 "zungr2"=>
  ["ZUNGR2 generates an m by n complex matrix Q with orthonormal rows,",
   "which is defined as the last m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(1)**H H(2)**H . . . H(k)**H",
   "as returned by ZGERQF."],
 "zherfs"=>
  ["ZHERFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "dggsvp3"=>
  ["DGGSVP3 computes orthogonal matrices U, V and Q such that",
   "                   N-K-L  K    L",
   " U**T*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;",
   "                L ( 0     0   A23 )",
   "            M-K-L ( 0     0    0  )",
   "                 N-K-L  K    L",
   "        =     K ( 0    A12  A13 )  if M-K-L < 0;",
   "            M-K ( 0     0   A23 )",
   "                 N-K-L  K    L",
   " V**T*B*Q =   L ( 0     0   B13 )",
   "            P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.  K+L = the effective",
   "numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.",
   "This decomposition is the preprocessing step for computing the",
   "Generalized Singular Value Decomposition (GSVD), see subroutine",
   "DGGSVD3."],
 "cpbtrf"=>
  ["CPBTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular."],
 "zgesv"=>
  ["ZGESV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as",
   "   A = P * L * U,",
   "where P is a permutation matrix, L is unit lower triangular, and U is",
   "upper triangular.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "zpttrs"=>
  ["ZPTTRS solves a tridiagonal system of the form",
   "   A * X = B",
   "using the factorization A = U**H *D* U or A = L*D*L**H computed by ZPTTRF.",
   "D is a diagonal matrix specified in the vector D, U (or L) is a unit",
   "bidiagonal matrix whose superdiagonal (subdiagonal) is specified in",
   "the vector E, and X and B are N by NRHS matrices."],
 "ssytri"=>
  ["SSYTRI computes the inverse of a real symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "SSYTRF."],
 "zgelsy"=>
  ["ZGELSY computes the minimum-norm solution to a complex linear least",
   "squares problem:",
   "    minimize || A * X - B ||",
   "using a complete orthogonal factorization of A.  A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The routine first computes a QR factorization with column pivoting:",
   "    A * P = Q * [ R11 R12 ]",
   "                [  0  R22 ]",
   "with R11 defined as the largest leading submatrix whose estimated",
   "condition number is less than 1/RCOND.  The order of R11, RANK,",
   "is the effective rank of A.",
   "Then, R22 is considered to be negligible, and R12 is annihilated",
   "by unitary transformations from the right, arriving at the",
   "complete orthogonal factorization:",
   "   A * P = Q * [ T11 0 ] * Z",
   "               [  0  0 ]",
   "The minimum-norm solution is then",
   "   X = P * Z**H [ inv(T11)*Q1**H*B ]",
   "                [        0         ]",
   "where Q1 consists of the first RANK columns of Q.",
   "This routine is basically identical to the original xGELSX except",
   "three differences:",
   "  o The permutation of matrix B (the right hand side) is faster and",
   "    more simple.",
   "  o The call to the subroutine xGEQPF has been substituted by the",
   "    the call to the subroutine xGEQP3. This subroutine is a Blas-3",
   "    version of the QR factorization with column pivoting.",
   "  o Matrix B (the right hand side) is updated with Blas-3."],
 "cla_porcond_c"=>
  ["   CLA_PORCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a REAL vector"],
 "sbbcsd"=>
  ["SBBCSD computes the CS decomposition of an orthogonal matrix in",
   "bidiagonal-block form,",
   "    [ B11 | B12 0  0 ]",
   "    [  0  |  0 -I  0 ]",
   "X = [----------------]",
   "    [ B21 | B22 0  0 ]",
   "    [  0  |  0  0  I ]",
   "                              [  C | -S  0  0 ]",
   "                  [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T",
   "                = [---------] [---------------] [---------]   .",
   "                  [    | U2 ] [  S |  C  0  0 ] [    | V2 ]",
   "                              [  0 |  0  0  I ]",
   "X is M-by-M, its top-left block is P-by-Q, and Q must be no larger",
   "than P, M-P, or M-Q. (If Q is not the smallest index, then X must be",
   "transposed and/or permuted. This can be done in constant time using",
   "the TRANS and SIGNS options. See SORCSD for details.)",
   "The bidiagonal matrices B11, B12, B21, and B22 are represented",
   "implicitly by angles THETA(1:Q) and PHI(1:Q-1).",
   "The orthogonal matrices U1, U2, V1T, and V2T are input/output.",
   "The input matrices are pre- or post-multiplied by the appropriate",
   "singular vector matrices."],
 "zpoequb"=>
  ["ZPOEQUB computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A and reduce its condition number",
   "(with respect to the two-norm).  S contains the scale factors,",
   "S(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with",
   "elements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This",
   "choice of S puts the condition number of B within a factor N of the",
   "smallest possible condition number over all possible diagonal",
   "scalings.",
   "This routine differs from ZPOEQU by restricting the scaling factors",
   "to a power of the radix.  Barring over- and underflow, scaling by",
   "these factors introduces no additional rounding errors.  However, the",
   "scaled diagonal entries are no longer approximately 1 but lie",
   "between sqrt(radix) and 1/sqrt(radix)."],
 "zlatrd"=>
  ["ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to",
   "Hermitian tridiagonal form by a unitary similarity",
   "transformation Q**H * A * Q, and returns the matrices V and W which are",
   "needed to apply the transformation to the unreduced part of A.",
   "If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a",
   "matrix, of which the upper triangle is supplied;",
   "if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a",
   "matrix, of which the lower triangle is supplied.",
   "This is an auxiliary routine called by ZHETRD."],
 "zlarfgp"=>
  ["ZLARFGP generates a complex elementary reflector H of order n, such",
   "that",
   "      H**H * ( alpha ) = ( beta ),   H**H * H = I.",
   "             (   x   )   (   0  )",
   "where alpha and beta are scalars, beta is real and non-negative, and",
   "x is an (n-1)-element complex vector.  H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**H ) ,",
   "                    ( v )",
   "where tau is a complex scalar and v is a complex (n-1)-element",
   "vector. Note that H is not hermitian.",
   "If the elements of x are all zero and alpha is real, then tau = 0",
   "and H is taken to be the unit matrix."],
 "cpstf2"=>
  ["CPSTF2 computes the Cholesky factorization with complete",
   "pivoting of a complex Hermitian positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**H * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 2 BLAS."],
 "clahef_rk"=>
  ["CLAHEF_RK computes a partial factorization of a complex Hermitian",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "CLAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "zgeqlf"=>
  ["ZGEQLF computes a QL factorization of a complex M-by-N matrix A:",
   "A = Q * L."],
 "cheevd_2stage"=>
  ["CHEEVD_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  If eigenvectors are desired, it uses a",
   "divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zlamtsqr"=>
  ["     ZLAMTSQR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**C * C       C * Q**C",
   "     where Q is a real orthogonal matrix defined as the product",
   "     of blocked elementary reflectors computed by tall skinny",
   "     QR factorization (ZLATSQR)"],
 "dtrtri"=>
  ["DTRTRI computes the inverse of a real upper or lower triangular",
   "matrix A.",
   "This is the Level 3 BLAS version of the algorithm."],
 "cptsvx"=>
  ["CPTSVX uses the factorization A = L*D*L**H to compute the solution",
   "to a complex system of linear equations A*X = B, where A is an",
   "N-by-N Hermitian positive definite tridiagonal matrix and X and B",
   "are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dla_wwaddw"=>
  ["   DLA_WWADDW adds a vector W into a doubled-single vector (X, Y).",
   "   This works for all extant IBM's hex and binary floating point",
   "   arithmetics, but not for decimal."],
 "cgebrd"=>
  ["CGEBRD reduces a general complex M-by-N matrix A to upper or lower",
   "bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "claqsp"=>
  ["CLAQSP equilibrates a symmetric matrix A using the scaling factors",
   "in the vector S."],
 "clacrm"=>
  ["CLACRM performs a very simple matrix-matrix multiplication:",
   "         C := A * B,",
   "where A is M by N and complex; B is N by N and real;",
   "C is M by N and complex."],
 "dtfsm"=>
  ["Level 3 BLAS like routine for A in RFP Format.",
   "DTFSM  solves the matrix equation",
   "   op( A )*X = alpha*B  or  X*op( A ) = alpha*B",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T.",
   "A is in Rectangular Full Packed (RFP) Format.",
   "The matrix X is overwritten on B."],
 "dgbsv"=>
  ["DGBSV computes the solution to a real system of linear equations",
   "A * X = B, where A is a band matrix of order N with KL subdiagonals",
   "and KU superdiagonals, and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as A = L * U, where L is a product of permutation",
   "and unit lower triangular matrices with KL subdiagonals, and U is",
   "upper triangular with KL+KU superdiagonals.  The factored form of A",
   "is then used to solve the system of equations A * X = B."],
 "dsteqr"=>
  ["DSTEQR computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the implicit QL or QR method.",
   "The eigenvectors of a full or band symmetric matrix can also be found",
   "if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to",
   "tridiagonal form."],
 "dpstrf"=>
  ["DPSTRF computes the Cholesky factorization with complete",
   "pivoting of a real symmetric positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**T * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 3 BLAS."],
 "crot"=>
  ["CROT   applies a plane rotation, where the cos (C) is real and the",
   "sin (S) is complex, and the vectors CX and CY are complex."],
 "sormlq"=>
  ["SORMLQ overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k) . . . H(2) H(1)",
   "as returned by SGELQF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "chetrd_he2hb"=>
  ["CHETRD_HE2HB reduces a complex Hermitian matrix A to complex Hermitian",
   "band-diagonal form AB by a unitary similarity transformation:",
   "Q**H * A * Q = AB."],
 "chetrd"=>
  ["CHETRD reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "dsyev_2stage"=>
  ["DSYEV_2STAGE computes all eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A using the 2stage technique for",
   "the reduction to tridiagonal."],
 "slaqsb"=>
  ["SLAQSB equilibrates a symmetric band matrix A using the scaling",
   "factors in the vector S."],
 "dsysvxx"=>
  ["   DSYSVXX uses the diagonal pivoting factorization to compute the",
   "   solution to a double precision system of linear equations A * X = B, where A",
   "   is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. DSYSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   DSYSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   DSYSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what DSYSVXX would itself produce."],
 "cgesvx"=>
  ["CGESVX uses the LU factorization to compute the solution to a complex",
   "system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zlatdf"=>
  ["ZLATDF computes the contribution to the reciprocal Dif-estimate",
   "by solving for x in Z * x = b, where b is chosen such that the norm",
   "of x is as large as possible. It is assumed that LU decomposition",
   "of Z has been computed by ZGETC2. On entry RHS = f holds the",
   "contribution from earlier solved sub-systems, and on return RHS = x.",
   "The factorization of Z returned by ZGETC2 has the form",
   "Z = P * L * U * Q, where P and Q are permutation matrices. L is lower",
   "triangular with unit diagonal elements and U is upper triangular."],
 "dlaed3"=>
  ["DLAED3 finds the roots of the secular equation, as defined by the",
   "values in D, W, and RHO, between 1 and K.  It makes the",
   "appropriate calls to DLAED4 and then updates the eigenvectors by",
   "multiplying the matrix of eigenvectors of the pair of eigensystems",
   "being combined by the matrix of eigenvectors of the K-by-K system",
   "which is solved here.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dspevd"=>
  ["DSPEVD computes all the eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A in packed storage. If eigenvectors are",
   "desired, it uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zgeqrt2"=>
  ["ZGEQRT2 computes a QR factorization of a complex M-by-N matrix A,",
   "using the compact WY representation of Q."],
 "zunbdb"=>
  ["ZUNBDB simultaneously bidiagonalizes the blocks of an M-by-M",
   "partitioned unitary matrix X:",
   "                                [ B11 | B12 0  0 ]",
   "    [ X11 | X12 ]   [ P1 |    ] [  0  |  0 -I  0 ] [ Q1 |    ]**H",
   "X = [-----------] = [---------] [----------------] [---------]   .",
   "    [ X21 | X22 ]   [    | P2 ] [ B21 | B22 0  0 ] [    | Q2 ]",
   "                                [  0  |  0  0  I ]",
   "X11 is P-by-Q. Q must be no larger than P, M-P, or M-Q. (If this is",
   "not the case, then X must be transposed and/or permuted. This can be",
   "done in constant time using the TRANS and SIGNS options. See ZUNCSD",
   "for details.)",
   "The unitary matrices P1, P2, Q1, and Q2 are P-by-P, (M-P)-by-",
   "(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. They are",
   "represented implicitly by Householder vectors.",
   "B11, B12, B21, and B22 are Q-by-Q bidiagonal matrices represented",
   "implicitly by angles THETA, PHI."],
 "slaqr3"=>
  ["   Aggressive early deflation:",
   "   SLAQR3 accepts as input an upper Hessenberg matrix",
   "   H and performs an orthogonal similarity transformation",
   "   designed to detect and deflate fully converged eigenvalues from",
   "   a trailing principal submatrix.  On output H has been over-",
   "   written by a new Hessenberg matrix that is a perturbation of",
   "   an orthogonal similarity transformation of H.  It is to be",
   "   hoped that the final version of H has many zero subdiagonal",
   "   entries."],
 "chpsvx"=>
  ["CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or",
   "A = L*D*L**H to compute the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N Hermitian matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "sdisna"=>
  ["SDISNA computes the reciprocal condition numbers for the eigenvectors",
   "of a real symmetric or complex Hermitian matrix or for the left or",
   "right singular vectors of a general m-by-n matrix. The reciprocal",
   "condition number is the 'gap' between the corresponding eigenvalue or",
   "singular value and the nearest other one.",
   "The bound on the error, measured by angle in radians, in the I-th",
   "computed vector is given by",
   "       SLAMCH( 'E' ) * ( ANORM / SEP( I ) )",
   "where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed",
   "to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of",
   "the error bound.",
   "SDISNA may also be used to compute error bounds for eigenvectors of",
   "the generalized symmetric definite eigenproblem."],
 "sbdsdc"=>
  ["SBDSDC computes the singular value decomposition (SVD) of a real",
   "N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,",
   "using a divide and conquer method, where S is a diagonal matrix",
   "with non-negative diagonal elements (the singular values of B), and",
   "U and VT are orthogonal matrices of left and right singular vectors,",
   "respectively. SBDSDC can be used to compute all singular values,",
   "and optionally, singular vectors or singular vectors in compact form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See SLASD3 for details.",
   "The code currently calls SLASDQ if singular values only are desired.",
   "However, it can be slightly modified to compute singular values",
   "using the divide and conquer method."],
 "dtfttp"=>
  ["DTFTTP copies a triangular matrix A from rectangular full packed",
   "format (TF) to standard packed format (TP)."],
 "shsein"=>
  ["SHSEIN uses inverse iteration to find specified right and/or left",
   "eigenvectors of a real upper Hessenberg matrix H.",
   "The right eigenvector x and the left eigenvector y of the matrix H",
   "corresponding to an eigenvalue w are defined by:",
   "             H * x = w * x,     y**h * H = w * y**h",
   "where y**h denotes the conjugate transpose of the vector y."],
 "slarfb"=>
  ["SLARFB applies a real block reflector H or its transpose H**T to a",
   "real m by n matrix C, from either the left or the right."],
 "cla_gbrcond_c"=>
  ["   CLA_GBRCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a REAL vector."],
 "clanhe"=>
  ["CLANHE  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex hermitian matrix A.",
   "   CLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zgeql2"=>
  ["ZGEQL2 computes a QL factorization of a complex m by n matrix A:",
   "A = Q * L."],
 "zunml2"=>
  ["ZUNML2 overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(k)**H . . . H(2)**H H(1)**H",
   "as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "slasq5"=>
  ["SLASQ5 computes one dqds transform in ping-pong form, one",
   "version for IEEE machines another for non IEEE machines."],
 "shseqr"=>
  ["   SHSEQR computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "dtbrfs"=>
  ["DTBRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular band",
   "coefficient matrix.",
   "The solution matrix X must be computed by DTBTRS or some other",
   "means before entering this routine.  DTBRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "dormqr"=>
  ["DORMQR overwrites the general real M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'T':      Q**T * C       C * Q**T",
   "where Q is a real orthogonal matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "clarrv"=>
  ["CLARRV computes the eigenvectors of the tridiagonal matrix",
   "T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.",
   "The input eigenvalues should have been computed by SLARRE."],
 "dlatbs"=>
  ["DLATBS solves one of the triangular systems",
   "   A *x = s*b  or  A**T*x = s*b",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular band matrix.  Here A**T denotes the transpose of A, x and b",
   "are n-element vectors, and s is a scaling factor, usually less than",
   "or equal to 1, chosen so that the components of x will be less than",
   "the overflow threshold.  If the unscaled problem will not cause",
   "overflow, the Level 2 BLAS routine DTBSV is called.  If the matrix A",
   "is singular (A(j,j) = 0 for some j), then s is set to 0 and a",
   "non-trivial solution to A*x = 0 is returned."],
 "cgebd2"=>
  ["CGEBD2 reduces a complex general m by n matrix A to upper or lower",
   "real bidiagonal form B by a unitary transformation: Q**H * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "dspcon"=>
  ["DSPCON estimates the reciprocal of the condition number (in the",
   "1-norm) of a real symmetric packed matrix A using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by DSPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dtrevc"=>
  ["DTREVC computes some or all of the right and/or left eigenvectors of",
   "a real upper quasi-triangular matrix T.",
   "Matrices of this type are produced by the Schur factorization of",
   "a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.",
   "The right eigenvector x and the left eigenvector y of T corresponding",
   "to an eigenvalue w are defined by:",
   "   T*x = w*x,     (y**H)*T = w*(y**H)",
   "where y**H denotes the conjugate transpose of y.",
   "The eigenvalues are not input to this routine, but are read directly",
   "from the diagonal blocks of T.",
   "This routine returns the matrices X and/or Y of right and left",
   "eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an",
   "input matrix.  If Q is the orthogonal factor that reduces a matrix",
   "A to Schur form T, then Q*X and Q*Y are the matrices of right and",
   "left eigenvectors of A."],
 "clar2v"=>
  ["CLAR2V applies a vector of complex plane rotations with real cosines",
   "from both sides to a sequence of 2-by-2 complex Hermitian matrices,",
   "defined by the elements of the vectors x, y and z. For i = 1,2,...,n",
   "   (       x(i)  z(i) ) :=",
   "   ( conjg(z(i)) y(i) )",
   "     (  c(i) conjg(s(i)) ) (       x(i)  z(i) ) ( c(i) -conjg(s(i)) )",
   "     ( -s(i)       c(i)  ) ( conjg(z(i)) y(i) ) ( s(i)        c(i)  )"],
 "dorg2l"=>
  ["DORG2L generates an m by n real matrix Q with orthonormal columns,",
   "which is defined as the last n columns of a product of k elementary",
   "reflectors of order m",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by DGEQLF."],
 "zhetri"=>
  ["ZHETRI computes the inverse of a complex Hermitian indefinite matrix",
   "A using the factorization A = U*D*U**H or A = L*D*L**H computed by",
   "ZHETRF."],
 "zgetrs"=>
  ["ZGETRS solves a system of linear equations",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B",
   "with a general N-by-N matrix A using the LU factorization computed",
   "by ZGETRF."],
 "chetrs"=>
  ["CHETRS solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF."],
 "dspgvx"=>
  ["DSPGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A",
   "and B are assumed to be symmetric, stored in packed storage, and B",
   "is also positive definite.  Eigenvalues and eigenvectors can be",
   "selected by specifying either a range of values or a range of indices",
   "for the desired eigenvalues."],
 "claswlq"=>
  ["         CLASWLQ computes a blocked Short-Wide LQ factorization of a",
   "         M-by-N matrix A, where N >= M:",
   "         A = L * Q"],
 "ztrsna"=>
  ["ZTRSNA estimates reciprocal condition numbers for specified",
   "eigenvalues and/or right eigenvectors of a complex upper triangular",
   "matrix T (or of any matrix Q*T*Q**H with Q unitary)."],
 "zpptrs"=>
  ["ZPPTRS solves a system of linear equations A*X = B with a Hermitian",
   "positive definite matrix A in packed storage using the Cholesky",
   "factorization A = U**H * U or A = L * L**H computed by ZPPTRF."],
 "zsysv"=>
  ["ZSYSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "zla_hercond_x"=>
  ["   ZLA_HERCOND_X computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX*16 vector."],
 "zlarft"=>
  ["ZLARFT forms the triangular factor T of a complex block reflector H",
   "of order n, which is defined as a product of k elementary reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**H",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**H * T * V"],
 "sgelq2"=>
  ["SGELQ2 computes an LQ factorization of a real m by n matrix A:",
   "A = L * Q."],
 "dorcsd"=>
  ["DORCSD computes the CS decomposition of an M-by-M partitioned",
   "orthogonal matrix X:",
   "                                [  I  0  0 |  0  0  0 ]",
   "                                [  0  C  0 |  0 -S  0 ]",
   "    [ X11 | X12 ]   [ U1 |    ] [  0  0  0 |  0  0 -I ] [ V1 |    ]**T",
   "X = [-----------] = [---------] [---------------------] [---------]   .",
   "    [ X21 | X22 ]   [    | U2 ] [  0  0  0 |  I  0  0 ] [    | V2 ]",
   "                                [  0  S  0 |  0  C  0 ]",
   "                                [  0  0  I |  0  0  0 ]",
   "X11 is P-by-Q. The orthogonal matrices U1, U2, V1, and V2 are P-by-P,",
   "(M-P)-by-(M-P), Q-by-Q, and (M-Q)-by-(M-Q), respectively. C and S are",
   "R-by-R nonnegative diagonal matrices satisfying C^2 + S^2 = I, in",
   "which R = MIN(P,M-P,Q,M-Q)."],
 "sgsvj0"=>
  ["SGSVJ0 is called from SGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as SGESVJ does, but",
   "it does not check convergence (stopping criterion). Few tuning",
   "parameters (marked by [TP]) are available for the implementer."],
 "cunmhr"=>
  ["CUNMHR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "IHI-ILO elementary reflectors, as returned by CGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "cla_porpvgrw"=>
  ["CLA_PORPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "spbtf2"=>
  ["SPBTF2 computes the Cholesky factorization of a real symmetric",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**T * U ,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix, U**T is the transpose of U, and",
   "L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "slasd6"=>
  ["SLASD6 computes the SVD of an updated upper bidiagonal matrix B",
   "obtained by merging two smaller ones by appending a row. This",
   "routine is used only for the problem which requires all singular",
   "values and optionally singular vector matrices in factored form.",
   "B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.",
   "A related subroutine, SLASD1, handles the case in which all singular",
   "values and singular vectors of the bidiagonal matrix are desired.",
   "SLASD6 computes the SVD as follows:",
   "              ( D1(in)    0    0       0 )",
   "  B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)",
   "              (   0       0   D2(in)   0 )",
   "    = U(out) * ( D(out) 0) * VT(out)",
   "where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M",
   "with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros",
   "elsewhere; and the entry b is empty if SQRE = 0.",
   "The singular values of B can be computed using D1, D2, the first",
   "components of all the right singular vectors of the lower block, and",
   "the last components of all the right singular vectors of the upper",
   "block. These components are stored and updated in VF and VL,",
   "respectively, in SLASD6. Hence U and VT are not explicitly",
   "referenced.",
   "The singular values are stored in D. The algorithm consists of two",
   "stages:",
   "      The first stage consists of deflating the size of the problem",
   "      when there are multiple singular values or if there is a zero",
   "      in the Z vector. For each such occurrence the dimension of the",
   "      secular equation problem is reduced by one. This stage is",
   "      performed by the routine SLASD7.",
   "      The second stage consists of calculating the updated",
   "      singular values. This is done by finding the roots of the",
   "      secular equation via the routine SLASD4 (as called by SLASD8).",
   "      This routine also updates VF and VL and computes the distances",
   "      between the updated singular values and the old singular",
   "      values.",
   "SLASD6 is called from SLASDA."],
 "csytrf_rk"=>
  ["CSYTRF_RK computes the factorization of a complex symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the blocked version of the algorithm, calling Level 3 BLAS.",
   "For more information see Further Details section."],
 "chetri_3"=>
  ["CHETRI_3 computes the inverse of a complex Hermitian indefinite",
   "matrix A using the factorization computed by CHETRF_RK or CHETRF_BK:",
   "    A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "CHETRI_3 sets the leading dimension of the workspace  before calling",
   "CHETRI_3X that actually computes the inverse.  This is the blocked",
   "version of the algorithm, calling Level 3 BLAS."],
 "slalsd"=>
  ["SLALSD uses the singular value decomposition of A to solve the least",
   "squares problem of finding X to minimize the Euclidean norm of each",
   "column of A*X-B, where A is N-by-N upper bidiagonal, and X and B",
   "are N-by-NRHS. The solution X overwrites B.",
   "The singular values of A smaller than RCOND times the largest",
   "singular value are treated as zero in solving the least squares",
   "problem; in this case a minimum norm solution is returned.",
   "The actual singular values are returned in D in ascending order.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zla_gbrcond_c"=>
  ["   ZLA_GBRCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector."],
 "zheevx_2stage"=>
  ["ZHEEVX_2STAGE computes selected eigenvalues and, optionally, eigenvectors",
   "of a complex Hermitian matrix A using the 2stage technique for",
   "the reduction to tridiagonal.  Eigenvalues and eigenvectors can",
   "be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "ssytf2_rk"=>
  ["SSYTF2_RK computes the factorization of a real symmetric matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "dgetrs"=>
  ["DGETRS solves a system of linear equations",
   "   A * X = B  or  A**T * X = B",
   "with a general N-by-N matrix A using the LU factorization computed",
   "by DGETRF."],
 "zla_gercond_x"=>
  ["   ZLA_GERCOND_X computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX*16 vector."],
 "dlangb"=>
  ["DLANGB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n band matrix  A,  with kl sub-diagonals and ku super-diagonals.",
   "   DLANGB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "zppsvx"=>
  ["ZPPSVX uses the Cholesky factorization A = U**H * U or A = L * L**H to",
   "compute the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix stored in",
   "packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "cpstrf"=>
  ["CPSTRF computes the Cholesky factorization with complete",
   "pivoting of a complex Hermitian positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**H * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 3 BLAS."],
 "dpotrf2"=>
  ["DPOTRF2 computes the Cholesky factorization of a real symmetric",
   "positive definite matrix A using the recursive algorithm.",
   "The factorization has the form",
   "   A = U**T * U,  if UPLO = 'U', or",
   "   A = L  * L**T,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the recursive version of the algorithm. It divides",
   "the matrix into four submatrices:",
   "       [  A11 | A12  ]  where A11 is n1 by n1 and A22 is n2 by n2",
   "   A = [ -----|----- ]  with n1 = n/2",
   "       [  A21 | A22  ]       n2 = n-n1",
   "The subroutine calls itself to factor A11. Update and scale A21",
   "or A12, update A22 then calls itself to factor A22."],
 "sspevx"=>
  ["SSPEVX computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric matrix A in packed storage.  Eigenvalues/vectors",
   "can be selected by specifying either a range of values or a range of",
   "indices for the desired eigenvalues."],
 "clarz"=>
  ["CLARZ applies a complex elementary reflector H to a complex",
   "M-by-N matrix C, from either the left or the right. H is represented",
   "in the form",
   "      H = I - tau * v * v**H",
   "where tau is a complex scalar and v is a complex vector.",
   "If tau = 0, then H is taken to be the unit matrix.",
   "To apply H**H (the conjugate transpose of H), supply conjg(tau) instead",
   "tau.",
   "H is a product of k elementary reflectors as returned by CTZRZF."],
 "zgebak"=>
  ["ZGEBAK forms the right or left eigenvectors of a complex general",
   "matrix by backward transformation on the computed eigenvectors of the",
   "balanced matrix output by ZGEBAL."],
 "slaqp2"=>
  ["SLAQP2 computes a QR factorization with column pivoting of",
   "the block A(OFFSET+1:M,1:N).",
   "The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized."],
 "cunmr2"=>
  ["CUNMR2 overwrites the general complex m-by-n matrix C with",
   "      Q * C  if SIDE = 'L' and TRANS = 'N', or",
   "      Q**H* C  if SIDE = 'L' and TRANS = 'C', or",
   "      C * Q  if SIDE = 'R' and TRANS = 'N', or",
   "      C * Q**H if SIDE = 'R' and TRANS = 'C',",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1)**H H(2)**H . . . H(k)**H",
   "as returned by CGERQF. Q is of order m if SIDE = 'L' and of order n",
   "if SIDE = 'R'."],
 "ztbcon"=>
  ["ZTBCON estimates the reciprocal of the condition number of a",
   "triangular band matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "clalsa"=>
  ["CLALSA is an itermediate step in solving the least squares problem",
   "by computing the SVD of the coefficient matrix in compact form (The",
   "singular vectors are computed as products of simple orthorgonal",
   "matrices.).",
   "If ICOMPQ = 0, CLALSA applies the inverse of the left singular vector",
   "matrix of an upper bidiagonal matrix to the right hand side; and if",
   "ICOMPQ = 1, CLALSA applies the right singular vector matrix to the",
   "right hand side. The singular vector matrices were generated in",
   "compact form by CLALSA."],
 "dorbdb5"=>[],
 "dtpttr"=>
  ["DTPTTR copies a triangular matrix A from standard packed format (TP)",
   "to standard full format (TR)."],
 "dlarzt"=>
  ["DLARZT forms the triangular factor T of a real block reflector",
   "H of order > n, which is defined as a product of k elementary",
   "reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**T",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**T * T * V",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "cppequ"=>
  ["CPPEQU computes row and column scalings intended to equilibrate a",
   "Hermitian positive definite matrix A in packed storage and reduce",
   "its condition number (with respect to the two-norm).  S contains the",
   "scale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix",
   "B with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.",
   "This choice of S puts the condition number of B within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "zlaqr1"=>
  ["     Given a 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a",
   "     scalar multiple of the first column of the product",
   "     (*)  K = (H - s1*I)*(H - s2*I)",
   "     scaling to avoid overflows and most underflows.",
   "     This is useful for starting double implicit shift bulges",
   "     in the QR algorithm."],
 "zla_gbrpvgrw"=>
  ["ZLA_GBRPVGRW computes the reciprocal pivot growth factor",
   "norm(A)/norm(U). The \"max absolute element\" norm is used. If this is",
   "much less than 1, the stability of the LU factorization of the",
   "(equilibrated) matrix A could be poor. This also means that the",
   "solution X, estimated condition numbers, and error bounds could be",
   "unreliable."],
 "slartv"=>
  ["SLARTV applies a vector of real plane rotations to elements of the",
   "real vectors x and y. For i = 1,2,...,n",
   "   ( x(i) ) := (  c(i)  s(i) ) ( x(i) )",
   "   ( y(i) )    ( -s(i)  c(i) ) ( y(i) )"],
 "dlasq1"=>
  ["DLASQ1 computes the singular values of a real N-by-N bidiagonal",
   "matrix with diagonal D and off-diagonal E. The singular values",
   "are computed to high relative accuracy, in the absence of",
   "denormalization, underflow and overflow. The algorithm was first",
   "presented in",
   "\"Accurate singular values and differential qd algorithms\" by K. V.",
   "Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,",
   "1994,",
   "and the present implementation is described in \"An implementation of",
   "the dqds Algorithm (Positive Case)\", LAPACK Working Note."],
 "zgelq"=>["ZGELQ computes a LQ factorization of an M-by-N matrix A."],
 "zlanht"=>
  ["ZLANHT  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex Hermitian tridiagonal matrix A.",
   "   ZLANHT = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "csysv_rk"=>
  ["CSYSV_RK computes the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix",
   "and X and B are N-by-NRHS matrices.",
   "The bounded Bunch-Kaufman (rook) diagonal pivoting method is used",
   "to factor A as",
   "   A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or",
   "   A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**T (or L**T) is the transpose of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is symmetric and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "CSYTRF_RK is called to compute the factorization of a complex",
   "symmetric matrix.  The factored form of A is then used to solve",
   "the system of equations A * X = B by calling BLAS3 routine CSYTRS_3."],
 "dlartv"=>
  ["DLARTV applies a vector of real plane rotations to elements of the",
   "real vectors x and y. For i = 1,2,...,n",
   "   ( x(i) ) := (  c(i)  s(i) ) ( x(i) )",
   "   ( y(i) )    ( -s(i)  c(i) ) ( y(i) )"],
 "clacp2"=>
  ["CLACP2 copies all or part of a real two-dimensional matrix A to a",
   "complex matrix B."],
 "zlaswlq"=>
  ["         ZLASWLQ computes a blocked Short-Wide LQ factorization of a",
   "         M-by-N matrix A, where N >= M:",
   "         A = L * Q"],
 "cbbcsd"=>
  ["CBBCSD computes the CS decomposition of a unitary matrix in",
   "bidiagonal-block form,",
   "    [ B11 | B12 0  0 ]",
   "    [  0  |  0 -I  0 ]",
   "X = [----------------]",
   "    [ B21 | B22 0  0 ]",
   "    [  0  |  0  0  I ]",
   "                              [  C | -S  0  0 ]",
   "                  [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H",
   "                = [---------] [---------------] [---------]   .",
   "                  [    | U2 ] [  S |  C  0  0 ] [    | V2 ]",
   "                              [  0 |  0  0  I ]",
   "X is M-by-M, its top-left block is P-by-Q, and Q must be no larger",
   "than P, M-P, or M-Q. (If Q is not the smallest index, then X must be",
   "transposed and/or permuted. This can be done in constant time using",
   "the TRANS and SIGNS options. See CUNCSD for details.)",
   "The bidiagonal matrices B11, B12, B21, and B22 are represented",
   "implicitly by angles THETA(1:Q) and PHI(1:Q-1).",
   "The unitary matrices U1, U2, V1T, and V2T are input/output.",
   "The input matrices are pre- or post-multiplied by the appropriate",
   "singular vector matrices."],
 "slatsqr"=>
  ["SLATSQR computes a blocked Tall-Skinny QR factorization of",
   "an M-by-N matrix A, where M >= N:",
   "A = Q * R ."],
 "dtftri"=>
  ["DTFTRI computes the inverse of a triangular matrix A stored in RFP",
   "format.",
   "This is a Level 3 BLAS version of the algorithm."],
 "zporfs"=>
  ["ZPORFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is Hermitian positive definite,",
   "and provides error bounds and backward error estimates for the",
   "solution."],
 "sgebal"=>
  ["SGEBAL balances a general real matrix A.  This involves, first,",
   "permuting A by a similarity transformation to isolate eigenvalues",
   "in the first 1 to ILO-1 and last IHI+1 to N elements on the",
   "diagonal; and second, applying a diagonal similarity transformation",
   "to rows and columns ILO to IHI to make the rows and columns as",
   "close in norm as possible.  Both steps are optional.",
   "Balancing may reduce the 1-norm of the matrix, and improve the",
   "accuracy of the computed eigenvalues and/or eigenvectors."],
 "stbtrs"=>
  ["STBTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular band matrix of order N, and B is an",
   "N-by NRHS matrix.  A check is made to verify that A is nonsingular."],
 "sptsvx"=>
  ["SPTSVX uses the factorization A = L*D*L**T to compute the solution",
   "to a real system of linear equations A*X = B, where A is an N-by-N",
   "symmetric positive definite tridiagonal matrix and X and B are",
   "N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "dsyequb"=>
  ["DSYEQUB computes row and column scalings intended to equilibrate a",
   "symmetric matrix A (with respect to the Euclidean norm) and reduce",
   "its condition number. The scale factors S are computed by the BIN",
   "algorithm (see references) so that the scaled matrix B with elements",
   "B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of",
   "the smallest possible condition number over all possible diagonal",
   "scalings."],
 "iladiag"=>
  ["This subroutine translated from a character string specifying if a",
   "matrix has unit diagonal or not to the relevant BLAST-specified",
   "integer constant.",
   "ILADIAG returns an INTEGER.  If ILADIAG < 0, then the input is not a",
   "character indicating a unit or non-unit diagonal.  Otherwise ILADIAG",
   "returns the constant value corresponding to DIAG."],
 "dsytri_rook"=>
  ["DSYTRI_ROOK computes the inverse of a real symmetric",
   "matrix A using the factorization A = U*D*U**T or A = L*D*L**T",
   "computed by DSYTRF_ROOK."],
 "sggevx"=>
  ["SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)",
   "the generalized eigenvalues, and optionally, the left and/or right",
   "generalized eigenvectors.",
   "Optionally also, it computes a balancing transformation to improve",
   "the conditioning of the eigenvalues and eigenvectors (ILO, IHI,",
   "LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for",
   "the eigenvalues (RCONDE), and reciprocal condition numbers for the",
   "right eigenvectors (RCONDV).",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right eigenvector v(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 A * v(j) = lambda(j) * B * v(j) .",
   "The left eigenvector u(j) corresponding to the eigenvalue lambda(j)",
   "of (A,B) satisfies",
   "                 u(j)**H * A  = lambda(j) * u(j)**H * B.",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "zunmhr"=>
  ["ZUNMHR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix of order nq, with nq = m if",
   "SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of",
   "IHI-ILO elementary reflectors, as returned by ZGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "dsptrs"=>
  ["DSPTRS solves a system of linear equations A*X = B with a real",
   "symmetric matrix A stored in packed format using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by DSPTRF."],
 "dlarrk"=>
  ["DLARRK computes one eigenvalue of a symmetric tridiagonal",
   "matrix T to suitable accuracy. This is an auxiliary code to be",
   "called from DSTEMR.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "dlasyf"=>
  ["DLASYF computes a partial factorization of a real symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method. The partial",
   "factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**T U22**T )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "ctptrs"=>
  ["CTPTRS solves a triangular system of the form",
   "   A * X = B,  A**T * X = B,  or  A**H * X = B,",
   "where A is a triangular matrix of order N stored in packed format,",
   "and B is an N-by-NRHS matrix.  A check is made to verify that A is",
   "nonsingular."],
 "clacon"=>
  ["CLACON estimates the 1-norm of a square, complex matrix A.",
   "Reverse communication is used for evaluating matrix-vector products."],
 "dorbdb1"=>[],
 "ilatrans"=>
  ["This subroutine translates from a character string specifying a",
   "transposition operation to the relevant BLAST-specified integer",
   "constant.",
   "ILATRANS returns an INTEGER.  If ILATRANS < 0, then the input is not",
   "a character indicating a transposition operator.  Otherwise ILATRANS",
   "returns the constant value corresponding to TRANS."],
 "dgtcon"=>
  ["DGTCON estimates the reciprocal of the condition number of a real",
   "tridiagonal matrix A using the LU factorization as computed by",
   "DGTTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "cgesvd"=>
  ["CGESVD computes the singular value decomposition (SVD) of a complex",
   "M-by-N matrix A, optionally computing the left and/or right singular",
   "vectors. The SVD is written",
   "     A = U * SIGMA * conjugate-transpose(V)",
   "where SIGMA is an M-by-N matrix which is zero except for its",
   "min(m,n) diagonal elements, U is an M-by-M unitary matrix, and",
   "V is an N-by-N unitary matrix.  The diagonal elements of SIGMA",
   "are the singular values of A; they are real and non-negative, and",
   "are returned in descending order.  The first min(m,n) columns of",
   "U and V are the left and right singular vectors of A.",
   "Note that the routine returns V**H, not V."],
 "slasd5"=>
  ["This subroutine computes the square root of the I-th eigenvalue",
   "of a positive symmetric rank-one modification of a 2-by-2 diagonal",
   "matrix",
   "           diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .",
   "The diagonal entries in the array D are assumed to satisfy",
   "           0 <= D(i) < D(j)  for  i < j .",
   "We also assume RHO > 0 and that the Euclidean norm of the vector",
   "Z is one."],
 "clauum"=>
  ["CLAUUM computes the product U * U**H or L**H * L, where the triangular",
   "factor U or L is stored in the upper or lower triangular part of",
   "the array A.",
   "If UPLO = 'U' or 'u' then the upper triangle of the result is stored,",
   "overwriting the factor U in A.",
   "If UPLO = 'L' or 'l' then the lower triangle of the result is stored,",
   "overwriting the factor L in A.",
   "This is the blocked form of the algorithm, calling Level 3 BLAS."],
 "chetf2_rk"=>
  ["CHETF2_RK computes the factorization of a complex Hermitian matrix A",
   "using the bounded Bunch-Kaufman (rook) diagonal pivoting method:",
   "   A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),",
   "where U (or L) is unit upper (or lower) triangular matrix,",
   "U**H (or L**H) is the conjugate of U (or L), P is a permutation",
   "matrix, P**T is the transpose of P, and D is Hermitian and block",
   "diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS.",
   "For more information see Further Details section."],
 "chpgv"=>
  ["CHPGV computes all the eigenvalues and, optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian, stored in packed format,",
   "and B is also positive definite."],
 "ztrrfs"=>
  ["ZTRRFS provides error bounds and backward error estimates for the",
   "solution to a system of linear equations with a triangular",
   "coefficient matrix.",
   "The solution matrix X must be computed by ZTRTRS or some other",
   "means before entering this routine.  ZTRRFS does not do iterative",
   "refinement because doing so cannot improve the backward error."],
 "dgeqrf"=>
  ["DGEQRF computes a QR factorization of a real M-by-N matrix A:",
   "A = Q * R."],
 "zhegv_2stage"=>
  ["ZHEGV_2STAGE computes all the eigenvalues, and optionally, the eigenvectors",
   "of a complex generalized Hermitian-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.",
   "Here A and B are assumed to be Hermitian and B is also",
   "positive definite.",
   "This routine use the 2stage technique for the reduction to tridiagonal",
   "which showed higher performance on recent architecture and for large"],
 "cggev3"=>
  ["CGGEV3 computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, and optionally, the left and/or",
   "right generalized eigenvectors.",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar",
   "lambda or a ratio alpha/beta = lambda, such that A - lambda*B is",
   "singular. It is usually represented as the pair (alpha,beta), as",
   "there is a reasonable interpretation for beta=0, and even for both",
   "being zero.",
   "The right generalized eigenvector v(j) corresponding to the",
   "generalized eigenvalue lambda(j) of (A,B) satisfies",
   "             A * v(j) = lambda(j) * B * v(j).",
   "The left generalized eigenvector u(j) corresponding to the",
   "generalized eigenvalues lambda(j) of (A,B) satisfies",
   "             u(j)**H * A = lambda(j) * u(j)**H * B",
   "where u(j)**H is the conjugate-transpose of u(j)."],
 "cspsvx"=>
  ["CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or",
   "A = L*D*L**T to compute the solution to a complex system of linear",
   "equations A * X = B, where A is an N-by-N symmetric matrix stored",
   "in packed format and X and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zsptri"=>
  ["ZSPTRI computes the inverse of a complex symmetric indefinite matrix",
   "A in packed storage using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by ZSPTRF."],
 "dpttrf"=>
  ["DPTTRF computes the L*D*L**T factorization of a real symmetric",
   "positive definite tridiagonal matrix A.  The factorization may also",
   "be regarded as having the form A = U**T*D*U."],
 "zspr"=>
  ["ZSPR    performs the symmetric rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a complex scalar, x is an n element vector and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "ssysv"=>
  ["SSYSV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric matrix and X and B are N-by-NRHS",
   "matrices.",
   "The diagonal pivoting method is used to factor A as",
   "   A = U * D * U**T,  if UPLO = 'U', or",
   "   A = L * D * L**T,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and D is symmetric and block diagonal with",
   "1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then",
   "used to solve the system of equations A * X = B."],
 "zlacpy"=>
  ["ZLACPY copies all or part of a two-dimensional matrix A to another",
   "matrix B."],
 "dorgl2"=>
  ["DORGL2 generates an m by n real matrix Q with orthonormal rows,",
   "which is defined as the first m rows of a product of k elementary",
   "reflectors of order n",
   "      Q  =  H(k) . . . H(2) H(1)",
   "as returned by DGELQF."],
 "stptrs"=>
  ["STPTRS solves a triangular system of the form",
   "   A * X = B  or  A**T * X = B,",
   "where A is a triangular matrix of order N stored in packed format,",
   "and B is an N-by-NRHS matrix.  A check is made to verify that A is",
   "nonsingular."],
 "cggglm"=>
  ["CGGGLM solves a general Gauss-Markov linear model (GLM) problem:",
   "        minimize || y ||_2   subject to   d = A*x + B*y",
   "            x",
   "where A is an N-by-M matrix, B is an N-by-P matrix, and d is a",
   "given N-vector. It is assumed that M <= N <= M+P, and",
   "           rank(A) = M    and    rank( A B ) = N.",
   "Under these assumptions, the constrained equation is always",
   "consistent, and there is a unique solution x and a minimal 2-norm",
   "solution y, which is obtained using a generalized QR factorization",
   "of the matrices (A, B) given by",
   "   A = Q*(R),   B = Q*T*Z.",
   "         (0)",
   "In particular, if matrix B is square nonsingular, then the problem",
   "GLM is equivalent to the following weighted linear least squares",
   "problem",
   "             minimize || inv(B)*(d-A*x) ||_2",
   "                 x",
   "where inv(B) denotes the inverse of B."],
 "cstemr"=>
  ["CSTEMR computes selected eigenvalues and, optionally, eigenvectors",
   "of a real symmetric tridiagonal matrix T. Any such unreduced matrix has",
   "a well defined set of pairwise different real eigenvalues, the corresponding",
   "real eigenvectors are pairwise orthogonal.",
   "The spectrum may be computed either completely or partially by specifying",
   "either an interval (VL,VU] or a range of indices IL:IU for the desired",
   "eigenvalues.",
   "Depending on the number of desired eigenvalues, these are computed either",
   "by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are",
   "computed by the use of various suitable L D L^T factorizations near clusters",
   "of close eigenvalues (referred to as RRRs, Relatively Robust",
   "Representations). An informal sketch of the algorithm follows.",
   "For each unreduced block (submatrix) of T,",
   "   (a) Compute T - sigma I  = L D L^T, so that L and D",
   "       define all the wanted eigenvalues to high relative accuracy.",
   "       This means that small relative changes in the entries of D and L",
   "       cause only small relative changes in the eigenvalues and",
   "       eigenvectors. The standard (unfactored) representation of the",
   "       tridiagonal matrix T does not have this property in general.",
   "   (b) Compute the eigenvalues to suitable accuracy.",
   "       If the eigenvectors are desired, the algorithm attains full",
   "       accuracy of the computed eigenvalues only right before",
   "       the corresponding vectors have to be computed, see steps c) and d).",
   "   (c) For each cluster of close eigenvalues, select a new",
   "       shift close to the cluster, find a new factorization, and refine",
   "       the shifted eigenvalues to suitable accuracy.",
   "   (d) For each eigenvalue with a large enough relative separation compute",
   "       the corresponding eigenvector by forming a rank revealing twisted",
   "       factorization. Go back to (c) for any clusters that remain.",
   "For more details, see:",
   "- Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations",
   "  to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"",
   "  Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.",
   "- Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and",
   "  Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,",
   "  2004.  Also LAPACK Working Note 154.",
   "- Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric",
   "  tridiagonal eigenvalue/eigenvector problem\",",
   "  Computer Science Division Technical Report No. UCB/CSD-97-971,",
   "  UC Berkeley, May 1997.",
   "Further Details",
   "1.CSTEMR works only on machines which follow IEEE-754",
   "floating-point standard in their handling of infinities and NaNs.",
   "This permits the use of efficient inner loops avoiding a check for",
   "zero divisors.",
   "2. LAPACK routines can be used to reduce a complex Hermitean matrix to",
   "real symmetric tridiagonal form.",
   "(Any complex Hermitean tridiagonal matrix has real values on its diagonal",
   "and potentially complex numbers on its off-diagonals. By applying a",
   "similarity transform with an appropriate diagonal matrix",
   "diag(1,e^{i \\phy_1}, ... , e^{i \\phy_{n-1}}), the complex Hermitean",
   "matrix can be transformed into a real symmetric matrix and complex",
   "arithmetic can be entirely avoided.)",
   "While the eigenvectors of the real symmetric tridiagonal matrix are real,",
   "the eigenvectors of original complex Hermitean matrix have complex entries",
   "in general.",
   "Since LAPACK drivers overwrite the matrix data with the eigenvectors,",
   "CSTEMR accepts complex workspace to facilitate interoperability",
   "with CUNMTR or CUPMTR."],
 "zsytri_rook"=>
  ["ZSYTRI_ROOK computes the inverse of a complex symmetric",
   "matrix A using the factorization A = U*D*U**T or A = L*D*L**T",
   "computed by ZSYTRF_ROOK."],
 "zla_geamv"=>
  ["ZLA_GEAMV  performs one of the matrix-vector operations",
   "        y := alpha*abs(A)*abs(x) + beta*abs(y),",
   "   or   y := alpha*abs(A)**T*abs(x) + beta*abs(y),",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix.",
   "This function is primarily used in calculating error bounds.",
   "To protect against underflow during evaluation, components in",
   "the resulting vector are perturbed away from zero by (N+1)",
   "times the underflow threshold.  To prevent unnecessarily large",
   "errors for block-structure embedded in general matrices,",
   "\"symbolically\" zero components are not perturbed.  A zero",
   "entry is considered \"symbolic\" if all multiplications involved",
   "in computing that entry have at least one zero multiplicand."],
 "zsytrs_aa"=>
  ["ZSYTRS_AA solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A using the factorization A = U*T*U**T or",
   "A = L*T*L**T computed by ZSYTRF_AA."],
 "slaed3"=>
  ["SLAED3 finds the roots of the secular equation, as defined by the",
   "values in D, W, and RHO, between 1 and K.  It makes the",
   "appropriate calls to SLAED4 and then updates the eigenvectors by",
   "multiplying the matrix of eigenvectors of the pair of eigensystems",
   "being combined by the matrix of eigenvectors of the K-by-K system",
   "which is solved here.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dsytrs_rook"=>
  ["DSYTRS_ROOK solves a system of linear equations A*X = B with",
   "a real symmetric matrix A using the factorization A = U*D*U**T or",
   "A = L*D*L**T computed by DSYTRF_ROOK."],
 "dlalsd"=>
  ["DLALSD uses the singular value decomposition of A to solve the least",
   "squares problem of finding X to minimize the Euclidean norm of each",
   "column of A*X-B, where A is N-by-N upper bidiagonal, and X and B",
   "are N-by-NRHS. The solution X overwrites B.",
   "The singular values of A smaller than RCOND times the largest",
   "singular value are treated as zero in solving the least squares",
   "problem; in this case a minimum norm solution is returned.",
   "The actual singular values are returned in D in ascending order.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dlabad"=>
  ["DLABAD takes as input the values computed by DLAMCH for underflow and",
   "overflow, and returns the square root of each of these values if the",
   "log of LARGE is sufficiently large.  This subroutine is intended to",
   "identify machines with a large exponent range, such as the Crays, and",
   "redefine the underflow and overflow limits to be the square roots of",
   "the values computed by DLAMCH.  This subroutine is needed because",
   "DLAMCH does not compensate for poor arithmetic in the upper half of",
   "the exponent range, as is found on a Cray."],
 "zlahef"=>
  ["ZLAHEF computes a partial factorization of a complex Hermitian",
   "matrix A using the Bunch-Kaufman diagonal pivoting method. The",
   "partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'",
   "      ( L21  I ) (  0  A22 ) (  0      I     )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "Note that U**H denotes the conjugate transpose of U.",
   "ZLAHEF is an auxiliary routine called by ZHETRF. It uses blocked code",
   "(calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or",
   "A22 (if UPLO = 'L')."],
 "zlaset"=>
  ["ZLASET initializes a 2-D array A to BETA on the diagonal and",
   "ALPHA on the offdiagonals."],
 "zlahef_rk"=>
  ["ZLAHEF_RK computes a partial factorization of a complex Hermitian",
   "matrix A using the bounded Bunch-Kaufman (rook) diagonal",
   "pivoting method. The partial factorization has the form:",
   "A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:",
   "      ( 0  U22 ) (  0   D  ) ( U12**H U22**H )",
   "A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',",
   "      ( L21  I ) (  0  A22 ) (  0       I    )",
   "where the order of D is at most NB. The actual order is returned in",
   "the argument KB, and is either NB or NB-1, or N if N <= NB.",
   "ZLAHEF_RK is an auxiliary routine called by ZHETRF_RK. It uses",
   "blocked code (calling Level 3 BLAS) to update the submatrix",
   "A11 (if UPLO = 'U') or A22 (if UPLO = 'L')."],
 "csytri2x"=>
  ["CSYTRI2X computes the inverse of a real symmetric indefinite matrix",
   "A using the factorization A = U*D*U**T or A = L*D*L**T computed by",
   "CSYTRF."],
 "dlaed6"=>
  ["DLAED6 computes the positive or negative root (closest to the origin)",
   "of",
   "                 z(1)        z(2)        z(3)",
   "f(x) =   rho + --------- + ---------- + ---------",
   "                d(1)-x      d(2)-x      d(3)-x",
   "It is assumed that",
   "      if ORGATI = .true. the root is between d(2) and d(3);",
   "      otherwise it is between d(1) and d(2)",
   "This routine will be called by DLAED4 when necessary. In most cases,",
   "the root sought is the smallest in magnitude, though it might not be",
   "in some extremely rare situations."],
 "cggbak"=>
  ["CGGBAK forms the right or left eigenvectors of a complex generalized",
   "eigenvalue problem A*x = lambda*B*x, by backward transformation on",
   "the computed eigenvectors of the balanced pair of matrices output by",
   "CGGBAL."],
 "slar1v"=>
  ["SLAR1V computes the (scaled) r-th column of the inverse of",
   "the sumbmatrix in rows B1 through BN of the tridiagonal matrix",
   "L D L**T - sigma I. When sigma is close to an eigenvalue, the",
   "computed vector is an accurate eigenvector. Usually, r corresponds",
   "to the index where the eigenvector is largest in magnitude.",
   "The following steps accomplish this computation :",
   "(a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,",
   "(b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,",
   "(c) Computation of the diagonal elements of the inverse of",
   "    L D L**T - sigma I by combining the above transforms, and choosing",
   "    r as the index where the diagonal of the inverse is (one of the)",
   "    largest in magnitude.",
   "(d) Computation of the (scaled) r-th column of the inverse using the",
   "    twisted factorization obtained by combining the top part of the",
   "    the stationary and the bottom part of the progressive transform."],
 "zhesv_aa"=>
  ["ZHESV_AA computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS",
   "matrices.",
   "Aasen's algorithm is used to factor A as",
   "   A = U * T * U**H,  if UPLO = 'U', or",
   "   A = L * T * L**H,  if UPLO = 'L',",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, and T is Hermitian and tridiagonal. The factored form",
   "of A is then used to solve the system of equations A * X = B."],
 "ssbtrd"=>
  ["SSBTRD reduces a real symmetric band matrix A to symmetric",
   "tridiagonal form T by an orthogonal similarity transformation:",
   "Q**T * A * Q = T."],
 "sstedc"=>
  ["SSTEDC computes all eigenvalues and, optionally, eigenvectors of a",
   "symmetric tridiagonal matrix using the divide and conquer method.",
   "The eigenvectors of a full or band real symmetric matrix can also be",
   "found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this",
   "matrix to tridiagonal form.",
   "This code makes very mild assumptions about floating point",
   "arithmetic. It will work on machines with a guard digit in",
   "add/subtract, or on those binary machines without guard digits",
   "which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.",
   "It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none.  See SLAED3 for details."],
 "dstebz"=>
  ["DSTEBZ computes the eigenvalues of a symmetric tridiagonal",
   "matrix T.  The user may ask for all eigenvalues, all eigenvalues",
   "in the half-open interval (VL, VU], or the IL-th through IU-th",
   "eigenvalues.",
   "To avoid overflow, the matrix must be scaled so that its",
   "largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest",
   "accuracy, it should not be much smaller than that.",
   "See W. Kahan \"Accurate Eigenvalues of a Symmetric Tridiagonal",
   "Matrix\", Report CS41, Computer Science Dept., Stanford",
   "University, July 21, 1966."],
 "slaein"=>
  ["SLAEIN uses inverse iteration to find a right or left eigenvector",
   "corresponding to the eigenvalue (WR,WI) of a real upper Hessenberg",
   "matrix H."],
 "dla_gbrfsx_extended"=>
  ["DLA_GBRFSX_EXTENDED improves the computed solution to a system of",
   "linear equations by performing extra-precise iterative refinement",
   "and provides error bounds and backward error estimates for the solution.",
   "This subroutine is called by DGBRFSX to perform iterative refinement.",
   "In addition to normwise error bound, the code provides maximum",
   "componentwise error bound if possible. See comments for ERR_BNDS_NORM",
   "and ERR_BNDS_COMP for details of the error bounds. Note that this",
   "subroutine is only resonsible for setting the second fields of",
   "ERR_BNDS_NORM and ERR_BNDS_COMP."],
 "cgelss"=>
  ["CGELSS computes the minimum norm solution to a complex linear",
   "least squares problem:",
   "Minimize 2-norm(| b - A*x |).",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix",
   "X.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value."],
 "zgerfs"=>
  ["ZGERFS improves the computed solution to a system of linear",
   "equations and provides error bounds and backward error estimates for",
   "the solution."],
 "cgelqf"=>
  ["CGELQF computes an LQ factorization of a complex M-by-N matrix A:",
   "A = L * Q."],
 "zlanhp"=>
  ["ZLANHP  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the  element of  largest absolute value  of a",
   "complex hermitian matrix A,  supplied in packed form.",
   "   ZLANHP = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "sgesc2"=>
  ["SGESC2 solves a system of linear equations",
   "          A * X = scale* RHS",
   "with a general N-by-N matrix A using the LU factorization with",
   "complete pivoting computed by SGETC2."],
 "sgsvj1"=>
  ["SGSVJ1 is called from SGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as SGESVJ does, but",
   "it targets only particular pivots and it does not check convergence",
   "(stopping criterion). Few tunning parameters (marked by [TP]) are",
   "available for the implementer.",
   "Further Details",
   "~~~~~~~~~~~~~~~",
   "SGSVJ1 applies few sweeps of Jacobi rotations in the column space of",
   "the input M-by-N matrix A. The pivot pairs are taken from the (1,2)",
   "off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The",
   "block-entries (tiles) of the (1,2) off-diagonal block are marked by the",
   "[x]'s in the following scheme:",
   "   | *  *  * [x] [x] [x]|",
   "   | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.",
   "   | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "In terms of the columns of A, the first N1 columns are rotated 'against'",
   "the remaining N-N1 columns, trying to increase the angle between the",
   "corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is",
   "tiled using quadratic tiles of side KBL. Here, KBL is a tunning parmeter.",
   "The number of sweeps is given in NSWEEP and the orthogonality threshold",
   "is given in TOL."],
 "dgesv"=>
  ["DGESV computes the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "The LU decomposition with partial pivoting and row interchanges is",
   "used to factor A as",
   "   A = P * L * U,",
   "where P is a permutation matrix, L is unit lower triangular, and U is",
   "upper triangular.  The factored form of A is then used to solve the",
   "system of equations A * X = B."],
 "slatps"=>
  ["SLATPS solves one of the triangular systems",
   "   A *x = s*b  or  A**T*x = s*b",
   "with scaling to prevent overflow, where A is an upper or lower",
   "triangular matrix stored in packed form.  Here A**T denotes the",
   "transpose of A, x and b are n-element vectors, and s is a scaling",
   "factor, usually less than or equal to 1, chosen so that the",
   "components of x will be less than the overflow threshold.  If the",
   "unscaled problem will not cause overflow, the Level 2 BLAS routine",
   "STPSV is called. If the matrix A is singular (A(j,j) = 0 for some j),",
   "then s is set to 0 and a non-trivial solution to A*x = 0 is returned."],
 "cunmqr"=>
  ["CUNMQR overwrites the general complex M-by-N matrix C with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "where Q is a complex unitary matrix defined as the product of k",
   "elementary reflectors",
   "      Q = H(1) H(2) . . . H(k)",
   "as returned by CGEQRF. Q is of order M if SIDE = 'L' and of order N",
   "if SIDE = 'R'."],
 "zlacrt"=>
  ["ZLACRT performs the operation",
   "   (  c  s )( x )  ==> ( x )",
   "   ( -s  c )( y )      ( y )",
   "where c and s are complex and the vectors x and y are complex."],
 "slaqr1"=>
  ["     Given a 2-by-2 or 3-by-3 matrix H, SLAQR1 sets v to a",
   "     scalar multiple of the first column of the product",
   "     (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)",
   "     scaling to avoid overflows and most underflows. It",
   "     is assumed that either",
   "             1) sr1 = sr2 and si1 = -si2",
   "         or",
   "             2) si1 = si2 = 0.",
   "     This is useful for starting double implicit shift bulges",
   "     in the QR algorithm."],
 "ssbgv"=>
  ["SSBGV computes all the eigenvalues, and optionally, the eigenvectors",
   "of a real generalized symmetric-definite banded eigenproblem, of",
   "the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric",
   "and banded, and B is also positive definite."],
 "stbcon"=>
  ["STBCON estimates the reciprocal of the condition number of a",
   "triangular band matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "dlarfy"=>
  ["DLARFY applies an elementary reflector, or Householder matrix, H,",
   "to an n x n symmetric matrix C, from both the left and the right.",
   "H is represented in the form",
   "   H = I - tau * v * v'",
   "where  tau  is a scalar and  v  is a vector.",
   "If  tau  is  zero, then  H  is taken to be the unit matrix."],
 "csyrfs"=>
  ["CSYRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is symmetric indefinite, and",
   "provides error bounds and backward error estimates for the solution."],
 "dgtsvx"=>
  ["DGTSVX uses the LU factorization to compute the solution to a real",
   "system of linear equations A * X = B or A**T * X = B,",
   "where A is a tridiagonal matrix of order N and X and B are N-by-NRHS",
   "matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "zgelqf"=>
  ["ZGELQF computes an LQ factorization of a complex M-by-N matrix A:",
   "A = L * Q."],
 "slantb"=>
  ["SLANTB  returns the value of the one norm,  or the Frobenius norm, or",
   "the  infinity norm,  or the element of  largest absolute value  of an",
   "n by n triangular band matrix A,  with ( k + 1 ) diagonals.",
   "   SLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'",
   "            (",
   "            ( norm1(A),         NORM = '1', 'O' or 'o'",
   "            (",
   "            ( normI(A),         NORM = 'I' or 'i'",
   "            (",
   "            ( normF(A),         NORM = 'F', 'f', 'E' or 'e'",
   "where  norm1  denotes the  one norm of a matrix (maximum column sum),",
   "normI  denotes the  infinity norm  of a matrix  (maximum row sum) and",
   "normF  denotes the  Frobenius norm of a matrix (square root of sum of",
   "squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm."],
 "dgtrfs"=>
  ["DGTRFS improves the computed solution to a system of linear",
   "equations when the coefficient matrix is tridiagonal, and provides",
   "error bounds and backward error estimates for the solution."],
 "cbdsqr"=>
  ["CBDSQR computes the singular values and, optionally, the right and/or",
   "left singular vectors from the singular value decomposition (SVD) of",
   "a real N-by-N (upper or lower) bidiagonal matrix B using the implicit",
   "zero-shift QR algorithm.  The SVD of B has the form",
   "   B = Q * S * P**H",
   "where S is the diagonal matrix of singular values, Q is an orthogonal",
   "matrix of left singular vectors, and P is an orthogonal matrix of",
   "right singular vectors.  If left singular vectors are requested, this",
   "subroutine actually returns U*Q instead of Q, and, if right singular",
   "vectors are requested, this subroutine returns P**H*VT instead of",
   "P**H, for given complex input matrices U and VT.  When U and VT are",
   "the unitary matrices that reduce a general matrix A to bidiagonal",
   "form: A = U*B*VT, as computed by CGEBRD, then",
   "   A = (U*Q) * S * (P**H*VT)",
   "is the SVD of A.  Optionally, the subroutine may also compute Q**H*C",
   "for a given complex input matrix C.",
   "See \"Computing  Small Singular Values of Bidiagonal Matrices With",
   "Guaranteed High Relative Accuracy,\" by J. Demmel and W. Kahan,",
   "LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,",
   "no. 5, pp. 873-912, Sept 1990) and",
   "\"Accurate singular values and differential qd algorithms,\" by",
   "B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics",
   "Department, University of California at Berkeley, July 1992",
   "for a detailed description of the algorithm."],
 "zlargv"=>
  ["ZLARGV generates a vector of complex plane rotations with real",
   "cosines, determined by elements of the complex vectors x and y.",
   "For i = 1,2,...,n",
   "   (        c(i)   s(i) ) ( x(i) ) = ( r(i) )",
   "   ( -conjg(s(i))  c(i) ) ( y(i) ) = (   0  )",
   "   where c(i)**2 + ABS(s(i))**2 = 1",
   "The following conventions are used (these are the same as in ZLARTG,",
   "but differ from the BLAS1 routine ZROTG):",
   "   If y(i)=0, then c(i)=1 and s(i)=0.",
   "   If x(i)=0, then c(i)=0 and s(i) is chosen so that r(i) is real."],
 "claqr0"=>
  ["   CLAQR0 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**H, where T is an upper triangular matrix (the",
   "   Schur form), and Z is the unitary matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input unitary",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H."],
 "cgeqrf"=>
  ["CGEQRF computes a QR factorization of a complex M-by-N matrix A:",
   "A = Q * R."],
 "dlaqr4"=>
  ["   DLAQR4 implements one level of recursion for DLAQR0.",
   "   It is a complete implementation of the small bulge multi-shift",
   "   QR algorithm.  It may be called by DLAQR0 and, for large enough",
   "   deflation window size, it may be called by DLAQR3.  This",
   "   subroutine is identical to DLAQR0 except that it calls DLAQR2",
   "   instead of DLAQR3.",
   "   DLAQR4 computes the eigenvalues of a Hessenberg matrix H",
   "   and, optionally, the matrices T and Z from the Schur decomposition",
   "   H = Z T Z**T, where T is an upper quasi-triangular matrix (the",
   "   Schur form), and Z is the orthogonal matrix of Schur vectors.",
   "   Optionally Z may be postmultiplied into an input orthogonal",
   "   matrix Q so that this routine can give the Schur factorization",
   "   of a matrix A which has been reduced to the Hessenberg form H",
   "   by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T."],
 "claqr5"=>
  ["   CLAQR5 called by CLAQR0 performs a",
   "   single small-bulge multi-shift QR sweep."],
 "csytf2"=>
  ["CSYTF2 computes the factorization of a complex symmetric matrix A",
   "using the Bunch-Kaufman diagonal pivoting method:",
   "   A = U*D*U**T  or  A = L*D*L**T",
   "where U (or L) is a product of permutation and unit upper (lower)",
   "triangular matrices, U**T is the transpose of U, and D is symmetric and",
   "block diagonal with 1-by-1 and 2-by-2 diagonal blocks.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zhfrk"=>
  ["Level 3 BLAS like routine for C in RFP Format.",
   "ZHFRK performs one of the Hermitian rank--k operations",
   "   C := alpha*A*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*A + beta*C,",
   "where alpha and beta are real scalars, C is an n--by--n Hermitian",
   "matrix and A is an n--by--k matrix in the first case and a k--by--n",
   "matrix in the second case."],
 "dtbcon"=>
  ["DTBCON estimates the reciprocal of the condition number of a",
   "triangular band matrix A, in either the 1-norm or the infinity-norm.",
   "The norm of A is computed and an estimate is obtained for",
   "norm(inv(A)), then the reciprocal of the condition number is",
   "computed as",
   "   RCOND = 1 / ( norm(A) * norm(inv(A)) )."],
 "ssygvx"=>
  ["SSYGVX computes selected eigenvalues, and optionally, eigenvectors",
   "of a real generalized symmetric-definite eigenproblem, of the form",
   "A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A",
   "and B are assumed to be symmetric and B is also positive definite.",
   "Eigenvalues and eigenvectors can be selected by specifying either a",
   "range of values or a range of indices for the desired eigenvalues."],
 "zgsvj1"=>
  ["ZGSVJ1 is called from ZGESVJ as a pre-processor and that is its main",
   "purpose. It applies Jacobi rotations in the same way as ZGESVJ does, but",
   "it targets only particular pivots and it does not check convergence",
   "(stopping criterion). Few tunning parameters (marked by [TP]) are",
   "available for the implementer.",
   "Further Details",
   "~~~~~~~~~~~~~~~",
   "ZGSVJ1 applies few sweeps of Jacobi rotations in the column space of",
   "the input M-by-N matrix A. The pivot pairs are taken from the (1,2)",
   "off-diagonal block in the corresponding N-by-N Gram matrix A^T * A. The",
   "block-entries (tiles) of the (1,2) off-diagonal block are marked by the",
   "[x]'s in the following scheme:",
   "   | *  *  * [x] [x] [x]|",
   "   | *  *  * [x] [x] [x]|    Row-cycling in the nblr-by-nblc [x] blocks.",
   "   | *  *  * [x] [x] [x]|    Row-cyclic pivoting inside each [x] block.",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "   |[x] [x] [x] *  *  * |",
   "In terms of the columns of A, the first N1 columns are rotated 'against'",
   "the remaining N-N1 columns, trying to increase the angle between the",
   "corresponding subspaces. The off-diagonal block is N1-by(N-N1) and it is",
   "tiled using quadratic tiles of side KBL. Here, KBL is a tunning parmeter.",
   "The number of sweeps is given in NSWEEP and the orthogonality threshold",
   "is given in TOL."],
 "ztpttr"=>
  ["ZTPTTR copies a triangular matrix A from standard packed format (TP)",
   "to standard full format (TR)."],
 "cposv"=>
  ["CPOSV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N Hermitian positive definite matrix and X and B",
   "are N-by-NRHS matrices.",
   "The Cholesky decomposition is used to factor A as",
   "   A = U**H* U,  if UPLO = 'U', or",
   "   A = L * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and  L is a lower triangular",
   "matrix.  The factored form of A is then used to solve the system of",
   "equations A * X = B."],
 "cgges3"=>
  ["CGGES3 computes for a pair of N-by-N complex nonsymmetric matrices",
   "(A,B), the generalized eigenvalues, the generalized complex Schur",
   "form (S, T), and optionally left and/or right Schur vectors (VSL",
   "and VSR). This gives the generalized Schur factorization",
   "        (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )",
   "where (VSR)**H is the conjugate-transpose of VSR.",
   "Optionally, it also orders the eigenvalues so that a selected cluster",
   "of eigenvalues appears in the leading diagonal blocks of the upper",
   "triangular matrix S and the upper triangular matrix T. The leading",
   "columns of VSL and VSR then form an unitary basis for the",
   "corresponding left and right eigenspaces (deflating subspaces).",
   "(If only the generalized eigenvalues are needed, use the driver",
   "CGGEV instead, which is faster.)",
   "A generalized eigenvalue for a pair of matrices (A,B) is a scalar w",
   "or a ratio alpha/beta = w, such that  A - w*B is singular.  It is",
   "usually represented as the pair (alpha,beta), as there is a",
   "reasonable interpretation for beta=0, and even for both being zero.",
   "A pair of matrices (S,T) is in generalized complex Schur form if S",
   "and T are upper triangular and, in addition, the diagonal elements",
   "of T are non-negative real numbers."],
 "spbsvx"=>
  ["SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to",
   "compute the solution to a real system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N symmetric positive definite band matrix and X",
   "and B are N-by-NRHS matrices.",
   "Error bounds on the solution and a condition estimate are also",
   "provided."],
 "ctgsy2"=>
  ["CTGSY2 solves the generalized Sylvester equation",
   "            A * R - L * B = scale *  C               (1)",
   "            D * R - L * E = scale * F",
   "using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,",
   "(A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,",
   "N-by-N and M-by-N, respectively. A, B, D and E are upper triangular",
   "(i.e., (A,D) and (B,E) in generalized Schur form).",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output",
   "scaling factor chosen to avoid overflow.",
   "In matrix notation solving equation (1) corresponds to solve",
   "Zx = scale * b, where Z is defined as",
   "       Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)",
   "           [ kron(In, D)  -kron(E**H, Im) ],",
   "Ik is the identity matrix of size k and X**H is the transpose of X.",
   "kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b",
   "is solved for, which is equivalent to solve for R and L in",
   "            A**H * R  + D**H * L   = scale * C           (3)",
   "            R  * B**H + L  * E**H  = scale * -F",
   "This case is used to compute an estimate of Dif[(A, D), (B, E)] =",
   "= sigma_min(Z) using reverse communicaton with CLACON.",
   "CTGSY2 also (IJOB >= 1) contributes to the computation in CTGSYL",
   "of an upper bound on the separation between to matrix pairs. Then",
   "the input (A, D), (B, E) are sub-pencils of two matrix pairs in",
   "CTGSYL."],
 "dgbsvxx"=>
  ["   DGBSVXX uses the LU factorization to compute the solution to a",
   "   double precision system of linear equations  A * X = B,  where A is an",
   "   N-by-N matrix and X and B are N-by-NRHS matrices.",
   "   If requested, both normwise and maximum componentwise error bounds",
   "   are returned. DGBSVXX will return a solution with a tiny",
   "   guaranteed error (O(eps) where eps is the working machine",
   "   precision) unless the matrix is very ill-conditioned, in which",
   "   case a warning is returned. Relevant condition numbers also are",
   "   calculated and returned.",
   "   DGBSVXX accepts user-provided factorizations and equilibration",
   "   factors; see the definitions of the FACT and EQUED options.",
   "   Solving with refinement and using a factorization from a previous",
   "   DGBSVXX call will also produce a solution with either O(eps)",
   "   errors or warnings, but we cannot make that claim for general",
   "   user-provided factorizations and equilibration factors if they",
   "   differ from what DGBSVXX would itself produce."],
 "ctfsm"=>
  ["Level 3 BLAS like routine for A in RFP Format.",
   "CTFSM solves the matrix equation",
   "   op( A )*X = alpha*B  or  X*op( A ) = alpha*B",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**H.",
   "A is in Rectangular Full Packed (RFP) Format.",
   "The matrix X is overwritten on B."],
 "dgebrd"=>
  ["DGEBRD reduces a general real M-by-N matrix A to upper or lower",
   "bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.",
   "If m >= n, B is upper bidiagonal; if m < n, B is lower bidiagonal."],
 "chetd2"=>
  ["CHETD2 reduces a complex Hermitian matrix A to real symmetric",
   "tridiagonal form T by a unitary similarity transformation:",
   "Q**H * A * Q = T."],
 "zlahef_aa"=>
  ["DLAHEF_AA factorizes a panel of a complex hermitian matrix A using",
   "the Aasen's algorithm. The panel consists of a set of NB rows of A",
   "when UPLO is U, or a set of NB columns when UPLO is L.",
   "In order to factorize the panel, the Aasen's algorithm requires the",
   "last row, or column, of the previous panel. The first row, or column,",
   "of A is set to be the first row, or column, of an identity matrix,",
   "which is used to factorize the first panel.",
   "The resulting J-th row of U, or J-th column of L, is stored in the",
   "(J-1)-th row, or column, of A (without the unit diagonals), while",
   "the diagonal and subdiagonal of A are overwritten by those of T."],
 "checon_rook"=>
  ["CHECON_ROOK estimates the reciprocal of the condition number of a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "zunmbr"=>
  ["If VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      Q * C          C * Q",
   "TRANS = 'C':      Q**H * C       C * Q**H",
   "If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C",
   "with",
   "                SIDE = 'L'     SIDE = 'R'",
   "TRANS = 'N':      P * C          C * P",
   "TRANS = 'C':      P**H * C       C * P**H",
   "Here Q and P**H are the unitary matrices determined by ZGEBRD when",
   "reducing a complex matrix A to bidiagonal form: A = Q * B * P**H. Q",
   "and P**H are defined as products of elementary reflectors H(i) and",
   "G(i) respectively.",
   "Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the",
   "order of the unitary matrix Q or P**H that is applied.",
   "If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:",
   "if nq >= k, Q = H(1) H(2) . . . H(k);",
   "if nq < k, Q = H(1) H(2) . . . H(nq-1).",
   "If VECT = 'P', A is assumed to have been a K-by-NQ matrix:",
   "if k < nq, P = G(1) G(2) . . . G(k);",
   "if k >= nq, P = G(1) G(2) . . . G(nq-1)."],
 "dlarrj"=>
  ["Given the initial eigenvalue approximations of T, DLARRJ",
   "does  bisection to refine the eigenvalues of T,",
   "W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial",
   "guesses for these eigenvalues are input in W, the corresponding estimate",
   "of the error in these guesses in WERR. During bisection, intervals",
   "[left, right] are maintained by storing their mid-points and",
   "semi-widths in the arrays W and WERR respectively."],
 "dggrqf"=>
  ["DGGRQF computes a generalized RQ factorization of an M-by-N matrix A",
   "and a P-by-N matrix B:",
   "            A = R*Q,        B = Z*T*Q,",
   "where Q is an N-by-N orthogonal matrix, Z is a P-by-P orthogonal",
   "matrix, and R and T assume one of the forms:",
   "if M <= N,  R = ( 0  R12 ) M,   or if M > N,  R = ( R11 ) M-N,",
   "                 N-M  M                           ( R21 ) N",
   "                                                     N",
   "where R12 or R21 is upper triangular, and",
   "if P >= N,  T = ( T11 ) N  ,   or if P < N,  T = ( T11  T12 ) P,",
   "                (  0  ) P-N                         P   N-P",
   "                   N",
   "where T11 is upper triangular.",
   "In particular, if B is square and nonsingular, the GRQ factorization",
   "of A and B implicitly gives the RQ factorization of A*inv(B):",
   "             A*inv(B) = (R*inv(T))*Z**T",
   "where inv(B) denotes the inverse of the matrix B, and Z**T denotes the",
   "transpose of the matrix Z."],
 "chbevd"=>
  ["CHBEVD computes all the eigenvalues and, optionally, eigenvectors of",
   "a complex Hermitian band matrix A.  If eigenvectors are desired, it",
   "uses a divide and conquer algorithm.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "dorghr"=>
  ["DORGHR generates a real orthogonal matrix Q which is defined as the",
   "product of IHI-ILO elementary reflectors of order N, as returned by",
   "DGEHRD:",
   "Q = H(ilo) H(ilo+1) . . . H(ihi-1)."],
 "sspev"=>
  ["SSPEV computes all the eigenvalues and, optionally, eigenvectors of a",
   "real symmetric matrix A in packed storage."],
 "dsyrfsx"=>
  ["   DSYRFSX improves the computed solution to a system of linear",
   "   equations when the coefficient matrix is symmetric indefinite, and",
   "   provides error bounds and backward error estimates for the",
   "   solution.  In addition to normwise error bound, the code provides",
   "   maximum componentwise error bound if possible.  See comments for",
   "   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.",
   "   The original system of linear equations may have been equilibrated",
   "   before calling this routine, as described by arguments EQUED and S",
   "   below. In this case, the solution and error bounds returned are",
   "   for the original unequilibrated system.",
   "    Some optional parameters are bundled in the PARAMS array.  These",
   "    settings determine how refinement is performed, but often the",
   "    defaults are acceptable.  If the defaults are acceptable, users",
   "    can pass NPARAMS = 0 which prevents the source code from accessing",
   "    the PARAMS argument."],
 "slaic1"=>
  ["SLAIC1 applies one step of incremental condition estimation in",
   "its simplest version:",
   "Let x, twonorm(x) = 1, be an approximate singular vector of an j-by-j",
   "lower triangular matrix L, such that",
   "         twonorm(L*x) = sest",
   "Then SLAIC1 computes sestpr, s, c such that",
   "the vector",
   "                [ s*x ]",
   "         xhat = [  c  ]",
   "is an approximate singular vector of",
   "                [ L      0  ]",
   "         Lhat = [ w**T gamma ]",
   "in the sense that",
   "         twonorm(Lhat*xhat) = sestpr.",
   "Depending on JOB, an estimate for the largest or smallest singular",
   "value is computed.",
   "Note that [s c]**T and sestpr**2 is an eigenpair of the system",
   "    diag(sest*sest, 0) + [alpha  gamma] * [ alpha ]",
   "                                          [ gamma ]",
   "where  alpha =  x**T*w."],
 "cpbtf2"=>
  ["CPBTF2 computes the Cholesky factorization of a complex Hermitian",
   "positive definite band matrix A.",
   "The factorization has the form",
   "   A = U**H * U ,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix, U**H is the conjugate transpose",
   "of U, and L is lower triangular.",
   "This is the unblocked version of the algorithm, calling Level 2 BLAS."],
 "zhecon_rook"=>
  ["ZHECON_ROOK estimates the reciprocal of the condition number of a complex",
   "Hermitian matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by CHETRF_ROOK.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "ztpqrt"=>
  ["ZTPQRT computes a blocked QR factorization of a complex",
   "\"triangular-pentagonal\" matrix C, which is composed of a",
   "triangular block A and pentagonal block B, using the compact",
   "WY representation for Q."],
 "cla_porcond_x"=>
  ["   CLA_PORCOND_X Computes the infinity norm condition number of",
   "   op(A) * diag(X) where X is a COMPLEX vector."],
 "dlarfgp"=>
  ["DLARFGP generates a real elementary reflector H of order n, such",
   "that",
   "      H * ( alpha ) = ( beta ),   H**T * H = I.",
   "          (   x   )   (   0  )",
   "where alpha and beta are scalars, beta is non-negative, and x is",
   "an (n-1)-element real vector.  H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**T ) ,",
   "                    ( v )",
   "where tau is a real scalar and v is a real (n-1)-element",
   "vector.",
   "If the elements of x are all zero, then tau = 0 and H is taken to be",
   "the unit matrix."],
 "slarfgp"=>
  ["SLARFGP generates a real elementary reflector H of order n, such",
   "that",
   "      H * ( alpha ) = ( beta ),   H**T * H = I.",
   "          (   x   )   (   0  )",
   "where alpha and beta are scalars, beta is non-negative, and x is",
   "an (n-1)-element real vector.  H is represented in the form",
   "      H = I - tau * ( 1 ) * ( 1 v**T ) ,",
   "                    ( v )",
   "where tau is a real scalar and v is a real (n-1)-element",
   "vector.",
   "If the elements of x are all zero, then tau = 0 and H is taken to be",
   "the unit matrix."],
 "zhptrs"=>
  ["ZHPTRS solves a system of linear equations A*X = B with a complex",
   "Hermitian matrix A stored in packed format using the factorization",
   "A = U*D*U**H or A = L*D*L**H computed by ZHPTRF."],
 "iladlc"=>["ILADLC scans A for its last non-zero column."],
 "zpstf2"=>
  ["ZPSTF2 computes the Cholesky factorization with complete",
   "pivoting of a complex Hermitian positive semidefinite matrix A.",
   "The factorization has the form",
   "   P**T * A * P = U**H * U ,  if UPLO = 'U',",
   "   P**T * A * P = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular, and",
   "P is stored as vector PIV.",
   "This algorithm does not attempt to check that A is positive",
   "semidefinite. This version of the algorithm calls level 2 BLAS."],
 "sgelqt"=>
  ["DGELQT computes a blocked LQ factorization of a real M-by-N matrix A",
   "using the compact WY representation of Q."],
 "cla_syrcond_c"=>
  ["   CLA_SYRCOND_C Computes the infinity norm condition number of",
   "   op(A) * inv(diag(C)) where C is a REAL vector."],
 "slahqr"=>
  ["   SLAHQR is an auxiliary routine called by SHSEQR to update the",
   "   eigenvalues and Schur decomposition already computed by SHSEQR, by",
   "   dealing with the Hessenberg submatrix in rows and columns ILO to",
   "   IHI."],
 "dlartgp"=>
  ["DLARTGP generates a plane rotation so that",
   "   [  CS  SN  ]  .  [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.",
   "   [ -SN  CS  ]     [ G ]     [ 0 ]",
   "This is a slower, more accurate version of the Level 1 BLAS routine DROTG,",
   "with the following other differences:",
   "   F and G are unchanged on return.",
   "   If G=0, then CS=(+/-)1 and SN=0.",
   "   If F=0 and (G .ne. 0), then CS=0 and SN=(+/-)1.",
   "The sign is chosen so that R >= 0."],
 "claqge"=>
  ["CLAQGE equilibrates a general M by N matrix A using the row and",
   "column scaling factors in the vectors R and C."],
 "dlascl"=>
  ["DLASCL multiplies the M by N real matrix A by the real scalar",
   "CTO/CFROM.  This is done without over/underflow as long as the final",
   "result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that",
   "A may be full, upper triangular, lower triangular, upper Hessenberg,",
   "or banded."],
 "dlarfb"=>
  ["DLARFB applies a real block reflector H or its transpose H**T to a",
   "real m by n matrix C, from either the left or the right."],
 "cgelsd"=>
  ["CGELSD computes the minimum-norm solution to a real linear least",
   "squares problem:",
   "    minimize 2-norm(| b - A*x |)",
   "using the singular value decomposition (SVD) of A. A is an M-by-N",
   "matrix which may be rank-deficient.",
   "Several right hand side vectors b and solution vectors x can be",
   "handled in a single call; they are stored as the columns of the",
   "M-by-NRHS right hand side matrix B and the N-by-NRHS solution",
   "matrix X.",
   "The problem is solved in three steps:",
   "(1) Reduce the coefficient matrix A to bidiagonal form with",
   "    Householder transformations, reducing the original problem",
   "    into a \"bidiagonal least squares problem\" (BLS)",
   "(2) Solve the BLS using a divide and conquer approach.",
   "(3) Apply back all the Householder transformations to solve",
   "    the original least squares problem.",
   "The effective rank of A is determined by treating as zero those",
   "singular values which are less than RCOND times the largest singular",
   "value.",
   "The divide and conquer algorithm makes very mild assumptions about",
   "floating point arithmetic. It will work on machines with a guard",
   "digit in add/subtract, or on those binary machines without guard",
   "digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or",
   "Cray-2. It could conceivably fail on hexadecimal or decimal machines",
   "without guard digits, but we know of none."],
 "zsptrs"=>
  ["ZSPTRS solves a system of linear equations A*X = B with a complex",
   "symmetric matrix A stored in packed format using the factorization",
   "A = U*D*U**T or A = L*D*L**T computed by ZSPTRF."],
 "zpotri"=>
  ["ZPOTRI computes the inverse of a complex Hermitian positive definite",
   "matrix A using the Cholesky factorization A = U**H*U or A = L*L**H",
   "computed by ZPOTRF."],
 "zhpcon"=>
  ["ZHPCON estimates the reciprocal of the condition number of a complex",
   "Hermitian packed matrix A using the factorization A = U*D*U**H or",
   "A = L*D*L**H computed by ZHPTRF.",
   "An estimate is obtained for norm(inv(A)), and the reciprocal of the",
   "condition number is computed as RCOND = 1 / (ANORM * norm(inv(A)))."],
 "dtgsja"=>
  ["DTGSJA computes the generalized singular value decomposition (GSVD)",
   "of two real upper triangular (or trapezoidal) matrices A and B.",
   "On entry, it is assumed that matrices A and B have the following",
   "forms, which may be obtained by the preprocessing subroutine DGGSVP",
   "from a general M-by-N matrix A and P-by-N matrix B:",
   "             N-K-L  K    L",
   "   A =    K ( 0    A12  A13 ) if M-K-L >= 0;",
   "          L ( 0     0   A23 )",
   "      M-K-L ( 0     0    0  )",
   "           N-K-L  K    L",
   "   A =  K ( 0    A12  A13 ) if M-K-L < 0;",
   "      M-K ( 0     0   A23 )",
   "           N-K-L  K    L",
   "   B =  L ( 0     0   B13 )",
   "      P-L ( 0     0    0  )",
   "where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular",
   "upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,",
   "otherwise A23 is (M-K)-by-L upper trapezoidal.",
   "On exit,",
   "       U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),",
   "where U, V and Q are orthogonal matrices.",
   "R is a nonsingular upper triangular matrix, and D1 and D2 are",
   "``diagonal'' matrices, which are of the following structures:",
   "If M-K-L >= 0,",
   "                    K  L",
   "       D1 =     K ( I  0 )",
   "                L ( 0  C )",
   "            M-K-L ( 0  0 )",
   "                  K  L",
   "       D2 = L   ( 0  S )",
   "            P-L ( 0  0 )",
   "               N-K-L  K    L",
   "  ( 0 R ) = K (  0   R11  R12 ) K",
   "            L (  0    0   R22 ) L",
   "where",
   "  C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),",
   "  S = diag( BETA(K+1),  ... , BETA(K+L) ),",
   "  C**2 + S**2 = I.",
   "  R is stored in A(1:K+L,N-K-L+1:N) on exit.",
   "If M-K-L < 0,",
   "               K M-K K+L-M",
   "    D1 =   K ( I  0    0   )",
   "         M-K ( 0  C    0   )",
   "                 K M-K K+L-M",
   "    D2 =   M-K ( 0  S    0   )",
   "         K+L-M ( 0  0    I   )",
   "           P-L ( 0  0    0   )",
   "               N-K-L  K   M-K  K+L-M",
   "( 0 R ) =    K ( 0    R11  R12  R13  )",
   "          M-K ( 0     0   R22  R23  )",
   "        K+L-M ( 0     0    0   R33  )",
   "where",
   "C = diag( ALPHA(K+1), ... , ALPHA(M) ),",
   "S = diag( BETA(K+1),  ... , BETA(M) ),",
   "C**2 + S**2 = I.",
   "R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored",
   "    (  0  R22 R23 )",
   "in B(M-K+1:L,N+M-K-L+1:N) on exit.",
   "The computation of the orthogonal transformation matrices U, V or Q",
   "is optional.  These matrices may either be formed explicitly, or they",
   "may be postmultiplied into input matrices U1, V1, or Q1."],
 "zla_lin_berr"=>
  ["   ZLA_LIN_BERR computes componentwise relative backward error from",
   "   the formula",
   "       max(i) ( abs(R(i)) / ( abs(op(A_s))*abs(Y) + abs(B_s) )(i) )",
   "   where abs(Z) is the componentwise absolute value of the matrix",
   "   or vector Z."],
 "zcgesv"=>
  ["ZCGESV computes the solution to a complex system of linear equations",
   "   A * X = B,",
   "where A is an N-by-N matrix and X and B are N-by-NRHS matrices.",
   "ZCGESV first attempts to factorize the matrix in COMPLEX and use this",
   "factorization within an iterative refinement procedure to produce a",
   "solution with COMPLEX*16 normwise backward error quality (see below).",
   "If the approach fails the method switches to a COMPLEX*16",
   "factorization and solve.",
   "The iterative refinement is not going to be a winning strategy if",
   "the ratio COMPLEX performance over COMPLEX*16 performance is too",
   "small. A reasonable strategy should take the number of right-hand",
   "sides and the size of the matrix into account. This might be done",
   "with a call to ILAENV in the future. Up to now, we always try",
   "iterative refinement.",
   "The iterative refinement process is stopped if",
   "    ITER > ITERMAX",
   "or for all the RHS we have:",
   "    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX",
   "where",
   "    o ITER is the number of the current iteration in the iterative",
   "      refinement process",
   "    o RNRM is the infinity-norm of the residual",
   "    o XNRM is the infinity-norm of the solution",
   "    o ANRM is the infinity-operator-norm of the matrix A",
   "    o EPS is the machine epsilon returned by DLAMCH('Epsilon')",
   "The value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00",
   "respectively."],
 "clarzt"=>
  ["CLARZT forms the triangular factor T of a complex block reflector",
   "H of order > n, which is defined as a product of k elementary",
   "reflectors.",
   "If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;",
   "If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.",
   "If STOREV = 'C', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th column of the array V, and",
   "   H  =  I - V * T * V**H",
   "If STOREV = 'R', the vector which defines the elementary reflector",
   "H(i) is stored in the i-th row of the array V, and",
   "   H  =  I - V**H * T * V",
   "Currently, only STOREV = 'R' and DIRECT = 'B' are supported."],
 "izmax1"=>
  ["IZMAX1 finds the index of the first vector element of maximum absolute value.",
   "Based on IZAMAX from Level 1 BLAS.",
   "The change is to use the 'genuine' absolute value."],
 "stgsyl"=>
  ["STGSYL solves the generalized Sylvester equation:",
   "            A * R - L * B = scale * C                 (1)",
   "            D * R - L * E = scale * F",
   "where R and L are unknown m-by-n matrices, (A, D), (B, E) and",
   "(C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,",
   "respectively, with real entries. (A, D) and (B, E) must be in",
   "generalized (real) Schur canonical form, i.e. A, B are upper quasi",
   "triangular and D, E are upper triangular.",
   "The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output",
   "scaling factor chosen to avoid overflow.",
   "In matrix notation (1) is equivalent to solve  Zx = scale b, where",
   "Z is defined as",
   "           Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)",
   "               [ kron(In, D)  -kron(E**T, Im) ].",
   "Here Ik is the identity matrix of size k and X**T is the transpose of",
   "X. kron(X, Y) is the Kronecker product between the matrices X and Y.",
   "If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,",
   "which is equivalent to solve for R and L in",
   "            A**T * R + D**T * L = scale * C           (3)",
   "            R * B**T + L * E**T = scale * -F",
   "This case (TRANS = 'T') is used to compute an one-norm-based estimate",
   "of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)",
   "and (B,E), using SLACON.",
   "If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate",
   "of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the",
   "reciprocal of the smallest singular value of Z. See [1-2] for more",
   "information.",
   "This is a level 3 BLAS algorithm."],
 "cpftrf"=>
  ["CPFTRF computes the Cholesky factorization of a complex Hermitian",
   "positive definite matrix A.",
   "The factorization has the form",
   "   A = U**H * U,  if UPLO = 'U', or",
   "   A = L  * L**H,  if UPLO = 'L',",
   "where U is an upper triangular matrix and L is lower triangular.",
   "This is the block version of the algorithm, calling Level 3 BLAS."],
 "zlaed8"=>
  ["ZLAED8 merges the two sets of eigenvalues together into a single",
   "sorted set.  Then it tries to deflate the size of the problem.",
   "There are two ways in which deflation can occur:  when two or more",
   "eigenvalues are close together or if there is a tiny element in the",
   "Z vector.  For each such occurrence the order of the related secular",
   "equation problem is reduced by one."],
 "slaed9"=>
  ["SLAED9 finds the roots of the secular equation, as defined by the",
   "values in D, Z, and RHO, between KSTART and KSTOP.  It makes the",
   "appropriate calls to SLAED4 and then stores the new matrix of",
   "eigenvectors for use in calculating the next level of Z vectors."]}
