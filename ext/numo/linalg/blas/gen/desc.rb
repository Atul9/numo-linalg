{"srotm"=>
  ["   APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX",
   "   (SX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF SX ARE IN",
   "   (SX**T)",
   "   SX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE",
   "   LX = (-INCX)*N, AND SIMILARLY FOR SY USING USING LY AND INCY.",
   "   WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS..",
   "   SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0",
   "     (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0)",
   "   H=(          )    (          )    (          )    (          )",
   "     (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0).",
   "   SEE  SROTMG FOR A DESCRIPTION OF DATA STORAGE IN SPARAM."],
 "ssbmv"=>
  ["SSBMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric band matrix, with k super-diagonals."],
 "cgemm"=>
  ["CGEMM  performs one of the matrix-matrix operations",
   "   C := alpha*op( A )*op( B ) + beta*C,",
   "where  op( X ) is one of",
   "   op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,",
   "alpha and beta are scalars, and A, B and C are matrices, with op( A )",
   "an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix."],
 "csymm"=>
  ["CSYMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where  alpha and beta are scalars, A is a symmetric matrix and  B and",
   "C are m by n matrices."],
 "csyrk"=>
  ["CSYRK  performs one of the symmetric rank k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where  alpha and beta  are scalars,  C is an  n by n symmetric matrix",
   "and  A  is an  n by k  matrix in the first case and a  k by n  matrix",
   "in the second case."],
 "ssymv"=>
  ["SSYMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix."],
 "cher2"=>
  ["CHER2  performs the hermitian rank 2 operation",
   "   A := alpha*x*y**H + conjg( alpha )*y*x**H + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an n",
   "by n hermitian matrix."],
 "dtrmv"=>
  ["DTRMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix."],
 "srotmg"=>
  ["   CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS",
   "   THE SECOND COMPONENT OF THE 2-VECTOR  (SQRT(SD1)*SX1,SQRT(SD2)*>    SY2)**T.",
   "   WITH SPARAM(1)=SFLAG, H HAS ONE OF THE FOLLOWING FORMS..",
   "   SFLAG=-1.E0     SFLAG=0.E0        SFLAG=1.E0     SFLAG=-2.E0",
   "     (SH11  SH12)    (1.E0  SH12)    (SH11  1.E0)    (1.E0  0.E0)",
   "   H=(          )    (          )    (          )    (          )",
   "     (SH21  SH22),   (SH21  1.E0),   (-1.E0 SH22),   (0.E0  1.E0).",
   "   LOCATIONS 2-4 OF SPARAM CONTAIN SH11,SH21,SH12, AND SH22",
   "   RESPECTIVELY. (VALUES OF 1.E0, -1.E0, OR 0.E0 IMPLIED BY THE",
   "   VALUE OF SPARAM(1) ARE NOT STORED IN SPARAM.)",
   "   THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE",
   "   INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE",
   "   OF SD1 AND SD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM."],
 "zsyrk"=>
  ["ZSYRK  performs one of the symmetric rank k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where  alpha and beta  are scalars,  C is an  n by n symmetric matrix",
   "and  A  is an  n by k  matrix in the first case and a  k by n  matrix",
   "in the second case."],
 "zher2k"=>
  ["ZHER2K  performs one of the hermitian rank 2k operations",
   "   C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C,",
   "where  alpha and beta  are scalars with  beta  real,  C is an  n by n",
   "hermitian matrix and  A and B  are  n by k matrices in the first case",
   "and  k by n  matrices in the second case."],
 "sgemm"=>
  ["SGEMM  performs one of the matrix-matrix operations",
   "   C := alpha*op( A )*op( B ) + beta*C,",
   "where  op( X ) is one of",
   "   op( X ) = X   or   op( X ) = X**T,",
   "alpha and beta are scalars, and A, B and C are matrices, with op( A )",
   "an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix."],
 "zgerc"=>
  ["ZGERC  performs the rank 1 operation",
   "   A := alpha*x*y**H + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "dznrm2"=>
  ["DZNRM2 returns the euclidean norm of a vector via the function",
   "name, so that",
   "   DZNRM2 := sqrt( x**H*x )"],
 "ztrsv"=>
  ["ZTRSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "zhpmv"=>
  ["ZHPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian matrix, supplied in packed form."],
 "ddot"=>
  ["   DDOT forms the dot product of two vectors.",
   "   uses unrolled loops for increments equal to one."],
 "idamax"=>
  ["   IDAMAX finds the index of the first element having maximum absolute value."],
 "zdrot"=>
  ["Applies a plane rotation, where the cos and sin (c and s) are real",
   "and the vectors cx and cy are complex.",
   "jack dongarra, linpack, 3/11/78."],
 "ztbmv"=>
  ["ZTBMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular band matrix, with ( k + 1 ) diagonals."],
 "dsbmv"=>
  ["DSBMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric band matrix, with k super-diagonals."],
 "cgbmv"=>
  ["CGBMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or",
   "   y := alpha*A**H*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n band matrix, with kl sub-diagonals and ku super-diagonals."],
 "csrot"=>
  ["CSROT applies a plane rotation, where the cos and sin (c and s) are real",
   "and the vectors cx and cy are complex.",
   "jack dongarra, linpack, 3/11/78."],
 "sspmv"=>
  ["SSPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix, supplied in packed form."],
 "izamax"=>
  ["   IZAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|"],
 "snrm2"=>
  ["SNRM2 returns the euclidean norm of a vector via the function",
   "name, so that",
   "   SNRM2 := sqrt( x'*x )."],
 "chpr2"=>
  ["CHPR2  performs the hermitian rank 2 operation",
   "   A := alpha*x*y**H + conjg( alpha )*y*x**H + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an",
   "n by n hermitian matrix, supplied in packed form."],
 "dcopy"=>
  ["   DCOPY copies a vector, x, to a vector, y.",
   "   uses unrolled loops for increments equal to one."],
 "ctrmv"=>
  ["CTRMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix."],
 "dsyr2k"=>
  ["DSYR2K  performs one of the symmetric rank 2k operations",
   "   C := alpha*A*B**T + alpha*B*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*B + alpha*B**T*A + beta*C,",
   "where  alpha and beta  are scalars, C is an  n by n  symmetric matrix",
   "and  A and B  are  n by k  matrices  in the  first  case  and  k by n",
   "matrices in the second case."],
 "cgeru"=>
  ["CGERU  performs the rank 1 operation",
   "   A := alpha*x*y**T + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "sscal"=>
  ["   scales a vector by a constant.",
   "   uses unrolled loops for increment equal to 1."],
 "sswap"=>
  ["   interchanges two vectors.",
   "   uses unrolled loops for increments equal to 1."],
 "ztrmm"=>
  ["ZTRMM  performs one of the matrix-matrix operations",
   "   B := alpha*op( A )*B,   or   B := alpha*B*op( A )",
   "where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H."],
 "zrotg"=>["   ZROTG determines a double complex Givens rotation."],
 "zscal"=>["   ZSCAL scales a vector by a constant."],
 "ssyr2"=>
  ["SSYR2  performs the symmetric rank 2 operation",
   "   A := alpha*x*y**T + alpha*y*x**T + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an n",
   "by n symmetric matrix."],
 "icamax"=>
  ["   ICAMAX finds the index of the first element having maximum |Re(.)| + |Im(.)|"],
 "cscal"=>["   CSCAL scales a vector by a constant."],
 "ztpmv"=>
  ["ZTPMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix, supplied in packed form."],
 "zdotu"=>
  ["ZDOTU forms the dot product of two complex vectors",
   "     ZDOTU = X^T * Y"],
 "xerbla_array"=>
  ["XERBLA_ARRAY assists other languages in calling XERBLA, the LAPACK",
   "and BLAS error handler.  Rather than taking a Fortran string argument",
   "as the function's name, XERBLA_ARRAY takes an array of single",
   "characters along with the array's length.  XERBLA_ARRAY then copies",
   "up to 32 characters of that array into a Fortran string and passes",
   "that to XERBLA.  If called with a non-positive SRNAME_LEN,",
   "XERBLA_ARRAY will call XERBLA with a string of all blank characters.",
   "Say some macro or other device makes XERBLA_ARRAY available to C99",
   "by a name lapack_xerbla and with a common Fortran calling convention.",
   "Then a C99 program could invoke XERBLA via:",
   "   {",
   "     int flen = strlen(__func__);",
   "     lapack_xerbla(__func__, &flen, &info);",
   "   }",
   "Providing XERBLA_ARRAY is not necessary for intercepting LAPACK",
   "errors.  XERBLA_ARRAY calls XERBLA."],
 "dtrsv"=>
  ["DTRSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "ctrsm"=>
  ["CTRSM  solves one of the matrix equations",
   "   op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.",
   "The matrix X is overwritten on B."],
 "zher2"=>
  ["ZHER2  performs the hermitian rank 2 operation",
   "   A := alpha*x*y**H + conjg( alpha )*y*x**H + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an n",
   "by n hermitian matrix."],
 "xerbla"=>
  ["XERBLA  is an error handler for the LAPACK routines.",
   "It is called by an LAPACK routine if an input parameter has an",
   "invalid value.  A message is printed and execution stops.",
   "Installers may consider modifying the STOP statement in order to",
   "call system-specific exception-handling facilities."],
 "ctrmm"=>
  ["CTRMM  performs one of the matrix-matrix operations",
   "   B := alpha*op( A )*B,   or   B := alpha*B*op( A )",
   "where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H."],
 "cgerc"=>
  ["CGERC  performs the rank 1 operation",
   "   A := alpha*x*y**H + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "crotg"=>["CROTG determines a complex Givens rotation."],
 "drotm"=>
  ["   APPLY THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX",
   "   (DX**T) , WHERE **T INDICATES TRANSPOSE. THE ELEMENTS OF DX ARE IN",
   "   (DY**T)",
   "   DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX .GE. 0, ELSE",
   "   LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY.",
   "   WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..",
   "   DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0",
   "     (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)",
   "   H=(          )    (          )    (          )    (          )",
   "     (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).",
   "   SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM."],
 "scabs1"=>["SCABS1 computes |Re(.)| + |Im(.)| of a complex number"],
 "sger"=>
  ["SGER   performs the rank 1 operation",
   "   A := alpha*x*y**T + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "lsame"=>
  ["LSAME returns .TRUE. if CA is the same letter as CB regardless of",
   "case."],
 "sasum"=>
  ["   SASUM takes the sum of the absolute values.",
   "   uses unrolled loops for increment equal to one."],
 "scopy"=>
  ["   SCOPY copies a vector, x, to a vector, y.",
   "   uses unrolled loops for increments equal to 1."],
 "srotg"=>["   SROTG construct givens plane rotation."],
 "sgemv"=>
  ["SGEMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix."],
 "daxpy"=>
  ["   DAXPY constant times a vector plus a vector.",
   "   uses unrolled loops for increments equal to one."],
 "dcabs1"=>["DCABS1 computes |Re(.)| + |Im(.)| of a double complex number"],
 "ctpsv"=>
  ["CTPSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix, supplied in packed form.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "zaxpy"=>["   ZAXPY constant times a vector plus a vector."],
 "dger"=>
  ["DGER   performs the rank 1 operation",
   "   A := alpha*x*y**T + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "dspr2"=>
  ["DSPR2  performs the symmetric rank 2 operation",
   "   A := alpha*x*y**T + alpha*y*x**T + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "sdot"=>
  ["   SDOT forms the dot product of two vectors.",
   "   uses unrolled loops for increments equal to one."],
 "zdscal"=>["   ZDSCAL scales a vector by a constant."],
 "dsyr"=>
  ["DSYR   performs the symmetric rank 1 operation",
   "   A := alpha*x*x**T + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n symmetric matrix."],
 "ztbsv"=>
  ["ZTBSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular band matrix, with ( k + 1 )",
   "diagonals.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "dtrmm"=>
  ["DTRMM  performs one of the matrix-matrix operations",
   "   B := alpha*op( A )*B,   or   B := alpha*B*op( A ),",
   "where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T."],
 "sdsdot"=>[],
 "csyr2k"=>
  ["CSYR2K  performs one of the symmetric rank 2k operations",
   "   C := alpha*A*B**T + alpha*B*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*B + alpha*B**T*A + beta*C,",
   "where  alpha and beta  are scalars,  C is an  n by n symmetric matrix",
   "and  A and B  are  n by k  matrices  in the  first  case  and  k by n",
   "matrices in the second case."],
 "ssyr"=>
  ["SSYR   performs the symmetric rank 1 operation",
   "   A := alpha*x*x**T + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n symmetric matrix."],
 "strmm"=>
  ["STRMM  performs one of the matrix-matrix operations",
   "   B := alpha*op( A )*B,   or   B := alpha*B*op( A ),",
   "where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T."],
 "cher2k"=>
  ["CHER2K  performs one of the hermitian rank 2k operations",
   "   C := alpha*A*B**H + conjg( alpha )*B*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*B + conjg( alpha )*B**H*A + beta*C,",
   "where  alpha and beta  are scalars with  beta  real,  C is an  n by n",
   "hermitian matrix and  A and B  are  n by k matrices in the first case",
   "and  k by n  matrices in the second case."],
 "zhemv"=>
  ["ZHEMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian matrix."],
 "dgemm"=>
  ["DGEMM  performs one of the matrix-matrix operations",
   "   C := alpha*op( A )*op( B ) + beta*C,",
   "where  op( X ) is one of",
   "   op( X ) = X   or   op( X ) = X**T,",
   "alpha and beta are scalars, and A, B and C are matrices, with op( A )",
   "an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix."],
 "strmv"=>
  ["STRMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix."],
 "sspr2"=>
  ["SSPR2  performs the symmetric rank 2 operation",
   "   A := alpha*x*y**T + alpha*y*x**T + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "zgemm"=>
  ["ZGEMM  performs one of the matrix-matrix operations",
   "   C := alpha*op( A )*op( B ) + beta*C,",
   "where  op( X ) is one of",
   "   op( X ) = X   or   op( X ) = X**T   or   op( X ) = X**H,",
   "alpha and beta are scalars, and A, B and C are matrices, with op( A )",
   "an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix."],
 "ctbsv"=>
  ["CTBSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular band matrix, with ( k + 1 )",
   "diagonals.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "strsv"=>
  ["STRSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "dtpmv"=>
  ["DTPMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix, supplied in packed form."],
 "ztrmv"=>
  ["ZTRMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix."],
 "dasum"=>["   DASUM takes the sum of the absolute values."],
 "ccopy"=>["   CCOPY copies a vector x to a vector y."],
 "caxpy"=>["   CAXPY constant times a vector plus a vector."],
 "zgemv"=>
  ["ZGEMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or",
   "   y := alpha*A**H*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix."],
 "chbmv"=>
  ["CHBMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian band matrix, with k super-diagonals."],
 "chemm"=>
  ["CHEMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where alpha and beta are scalars, A is an hermitian matrix and  B and",
   "C are m by n matrices."],
 "sgbmv"=>
  ["SGBMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n band matrix, with kl sub-diagonals and ku super-diagonals."],
 "dtrsm"=>
  ["DTRSM  solves one of the matrix equations",
   "   op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T.",
   "The matrix X is overwritten on B."],
 "zsymm"=>
  ["ZSYMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where  alpha and beta are scalars, A is a symmetric matrix and  B and",
   "C are m by n matrices."],
 "dtpsv"=>
  ["DTPSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix, supplied in packed form.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "dtbsv"=>
  ["DTBSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular band matrix, with ( k + 1 )",
   "diagonals.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "scasum"=>
  ["   SCASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and",
   "   returns a single precision result."],
 "dsymv"=>
  ["DSYMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix."],
 "ctbmv"=>
  ["CTBMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular band matrix, with ( k + 1 ) diagonals."],
 "ssyrk"=>
  ["SSYRK  performs one of the symmetric rank k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where  alpha and beta  are scalars, C is an  n by n  symmetric matrix",
   "and  A  is an  n by k  matrix in the first case and a  k by n  matrix",
   "in the second case."],
 "cdotu"=>
  ["CDOTU forms the dot product of two complex vectors",
   "     CDOTU = X^T * Y"],
 "ctrsv"=>
  ["CTRSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "stbmv"=>
  ["STBMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular band matrix, with ( k + 1 ) diagonals."],
 "zcopy"=>["   ZCOPY copies a vector, x, to a vector, y."],
 "zhemm"=>
  ["ZHEMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where alpha and beta are scalars, A is an hermitian matrix and  B and",
   "C are m by n matrices."],
 "zhbmv"=>
  ["ZHBMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian band matrix, with k super-diagonals."],
 "dgbmv"=>
  ["DGBMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n band matrix, with kl sub-diagonals and ku super-diagonals."],
 "cgemv"=>
  ["CGEMV performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or",
   "   y := alpha*A**H*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix."],
 "cherk"=>
  ["CHERK  performs one of the hermitian rank k operations",
   "   C := alpha*A*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*A + beta*C,",
   "where  alpha and beta  are  real scalars,  C is an  n by n  hermitian",
   "matrix and  A  is an  n by k  matrix in the  first case and a  k by n",
   "matrix in the second case."],
 "dsdot"=>
  ["Compute the inner product of two vectors with extended",
   "precision accumulation and result.",
   "Returns D.P. dot product accumulated in D.P., for S.P. SX and SY",
   "DSDOT = sum for I = 0 to N-1 of  SX(LX+I*INCX) * SY(LY+I*INCY),",
   "where LX = 1 if INCX .GE. 0, else LX = 1+(1-N)*INCX, and LY is",
   "defined in a similar way using INCY."],
 "stbsv"=>
  ["STBSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular band matrix, with ( k + 1 )",
   "diagonals.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "zdotc"=>
  ["ZDOTC forms the dot product of two complex vectors",
   "     ZDOTC = X^H * Y"],
 "stpsv"=>
  ["STPSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix, supplied in packed form.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "zgbmv"=>
  ["ZGBMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,   or",
   "   y := alpha*A**H*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n band matrix, with kl sub-diagonals and ku super-diagonals."],
 "zhpr"=>
  ["ZHPR    performs the hermitian rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n hermitian matrix, supplied in packed form."],
 "dsyr2"=>
  ["DSYR2  performs the symmetric rank 2 operation",
   "   A := alpha*x*y**T + alpha*y*x**T + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an n",
   "by n symmetric matrix."],
 "zherk"=>
  ["ZHERK  performs one of the hermitian rank k operations",
   "   C := alpha*A*A**H + beta*C,",
   "or",
   "   C := alpha*A**H*A + beta*C,",
   "where  alpha and beta  are  real scalars,  C is an  n by n  hermitian",
   "matrix and  A  is an  n by k  matrix in the  first case and a  k by n",
   "matrix in the second case."],
 "dspr"=>
  ["DSPR    performs the symmetric rank 1 operation",
   "   A := alpha*x*x**T + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "chpmv"=>
  ["CHPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian matrix, supplied in packed form."],
 "dtbmv"=>
  ["DTBMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular band matrix, with ( k + 1 ) diagonals."],
 "dspmv"=>
  ["DSPMV  performs the matrix-vector operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n symmetric matrix, supplied in packed form."],
 "dnrm2"=>
  ["DNRM2 returns the euclidean norm of a vector via the function",
   "name, so that",
   "   DNRM2 := sqrt( x'*x )"],
 "drotg"=>["   DROTG construct givens plane rotation."],
 "drot"=>["   DROT applies a plane rotation."],
 "cswap"=>["  CSWAP interchanges two vectors."],
 "srot"=>["   applies a plane rotation."],
 "ssyr2k"=>
  ["SSYR2K  performs one of the symmetric rank 2k operations",
   "   C := alpha*A*B**T + alpha*B*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*B + alpha*B**T*A + beta*C,",
   "where  alpha and beta  are scalars, C is an  n by n  symmetric matrix",
   "and  A and B  are  n by k  matrices  in the  first  case  and  k by n",
   "matrices in the second case."],
 "dgemv"=>
  ["DGEMV  performs one of the matrix-vector operations",
   "   y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,",
   "where alpha and beta are scalars, x and y are vectors and A is an",
   "m by n matrix."],
 "drotmg"=>
  ["   CONSTRUCT THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS",
   "   THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*>    DY2)**T.",
   "   WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS..",
   "   DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0",
   "     (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)",
   "   H=(          )    (          )    (          )    (          )",
   "     (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).",
   "   LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22",
   "   RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE",
   "   VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)",
   "   THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE",
   "   INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE",
   "   OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM."],
 "isamax"=>
  ["   ISAMAX finds the index of the first element having maximum absolute value."],
 "zher"=>
  ["ZHER   performs the hermitian rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n hermitian matrix."],
 "dsyrk"=>
  ["DSYRK  performs one of the symmetric rank k operations",
   "   C := alpha*A*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*A + beta*C,",
   "where  alpha and beta  are scalars, C is an  n by n  symmetric matrix",
   "and  A  is an  n by k  matrix in the first case and a  k by n  matrix",
   "in the second case."],
 "scnrm2"=>
  ["SCNRM2 returns the euclidean norm of a vector via the function",
   "name, so that",
   "   SCNRM2 := sqrt( x**H*x )"],
 "ztrsm"=>
  ["ZTRSM  solves one of the matrix equations",
   "   op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T   or   op( A ) = A**H.",
   "The matrix X is overwritten on B."],
 "dswap"=>
  ["   interchanges two vectors.",
   "   uses unrolled loops for increments equal one."],
 "zgeru"=>
  ["ZGERU  performs the rank 1 operation",
   "   A := alpha*x*y**T + A,",
   "where alpha is a scalar, x is an m element vector, y is an n element",
   "vector and A is an m by n matrix."],
 "dscal"=>
  ["   DSCAL scales a vector by a constant.",
   "   uses unrolled loops for increment equal to one."],
 "csscal"=>["   CSSCAL scales a complex vector by a real constant."],
 "saxpy"=>
  ["   SAXPY constant times a vector plus a vector.",
   "   uses unrolled loops for increments equal to one."],
 "ssymm"=>
  ["SSYMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where alpha and beta are scalars,  A is a symmetric matrix and  B and",
   "C are  m by n matrices."],
 "ctpmv"=>
  ["CTPMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,   or   x := A**H*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix, supplied in packed form."],
 "ztpsv"=>
  ["ZTPSV  solves one of the systems of equations",
   "   A*x = b,   or   A**T*x = b,   or   A**H*x = b,",
   "where b and x are n element vectors and A is an n by n unit, or",
   "non-unit, upper or lower triangular matrix, supplied in packed form.",
   "No test for singularity or near-singularity is included in this",
   "routine. Such tests must be performed before calling this routine."],
 "chemv"=>
  ["CHEMV  performs the matrix-vector  operation",
   "   y := alpha*A*x + beta*y,",
   "where alpha and beta are scalars, x and y are n element vectors and",
   "A is an n by n hermitian matrix."],
 "chpr"=>
  ["CHPR    performs the hermitian rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n hermitian matrix, supplied in packed form."],
 "stpmv"=>
  ["STPMV  performs one of the matrix-vector operations",
   "   x := A*x,   or   x := A**T*x,",
   "where x is an n element vector and  A is an n by n unit, or non-unit,",
   "upper or lower triangular matrix, supplied in packed form."],
 "zswap"=>["   ZSWAP interchanges two vectors."],
 "sspr"=>
  ["SSPR    performs the symmetric rank 1 operation",
   "   A := alpha*x*x**T + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n symmetric matrix, supplied in packed form."],
 "dsymm"=>
  ["DSYMM  performs one of the matrix-matrix operations",
   "   C := alpha*A*B + beta*C,",
   "or",
   "   C := alpha*B*A + beta*C,",
   "where alpha and beta are scalars,  A is a symmetric matrix and  B and",
   "C are  m by n matrices."],
 "dzasum"=>
  ["   DZASUM takes the sum of the (|Re(.)| + |Im(.)|)'s of a complex vector and",
   "   returns a single precision result."],
 "zsyr2k"=>
  ["ZSYR2K  performs one of the symmetric rank 2k operations",
   "   C := alpha*A*B**T + alpha*B*A**T + beta*C,",
   "or",
   "   C := alpha*A**T*B + alpha*B**T*A + beta*C,",
   "where  alpha and beta  are scalars,  C is an  n by n symmetric matrix",
   "and  A and B  are  n by k  matrices  in the  first  case  and  k by n",
   "matrices in the second case."],
 "cher"=>
  ["CHER   performs the hermitian rank 1 operation",
   "   A := alpha*x*x**H + A,",
   "where alpha is a real scalar, x is an n element vector and A is an",
   "n by n hermitian matrix."],
 "zhpr2"=>
  ["ZHPR2  performs the hermitian rank 2 operation",
   "   A := alpha*x*y**H + conjg( alpha )*y*x**H + A,",
   "where alpha is a scalar, x and y are n element vectors and A is an",
   "n by n hermitian matrix, supplied in packed form."],
 "cdotc"=>
  ["CDOTC forms the dot product of two complex vectors",
   "     CDOTC = X^H * Y"],
 "strsm"=>
  ["STRSM  solves one of the matrix equations",
   "   op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,",
   "where alpha is a scalar, X and B are m by n matrices, A is a unit, or",
   "non-unit,  upper or lower triangular matrix  and  op( A )  is one  of",
   "   op( A ) = A   or   op( A ) = A**T.",
   "The matrix X is overwritten on B."]}
